isabelle /opt/Isabelle2016-1, theory PrgEnc.

classical var k : key.
classical var s : key.

# Variables for adversary communication
classical var m1 : msg.
classical var m2 : msg.
classical var c : msg.
classical var r : msg.
classical var b : bit.

quantum var qglobA : string.
classical var cglobA : string.

# A: inputs: none; outputs m1,m2
adversary A1 vars m1,m2,cglobA,qglobA.
# A: inputs: c; outputs: b
adversary A2 vars c,b,cglobA,qglobA.

# B: inputs: r; outputs: b
program B1 := { call A1; c <- r+m1; call A2; }.
program B2 := { call A1; c <- r+m2; call A2; }.


program indcpa0 := {
  k <$ uniform UNIV;
  call A1;
  c <- enc(k,m1);
  call A2;
}.

program indcpa1 := {
  k <$ uniform UNIV;
  call A1;
  c <- enc(k,m2);
  call A2;
}.

program prg0B1 := {
  s <$ uniform UNIV;
  r <- G(s);
  call B1;
}.

program prg1B1 := {
  r <$ uniform UNIV;
  call B1;
}.

program prg0B2 := {
  s <$ uniform UNIV;
  r <- G(s);
  call B2;
}.

program prg1B2 := {
  r <$ uniform UNIV;
  call B2;
}.

program middle := {
  call A1;
  c <$ uniform UNIV;
  call A2;
}.

qrhl {Cla[b1=b2 ∧ c1=c2 ∧ m11=m12 ∧ m21=m22 ∧ cglobA1=cglobA2] ⊓ ⟦qglobA1⟧ ≡𝔮 ⟦qglobA2⟧}
        call indcpa0; ~ call prg0B1;
     {Cla[b1=b2]}.
    
 inline indcpa0.
 inline prg0B1.
 inline B1.
 call.
 wp left.
 wp right.
 simp.
 call.
 simp.
 wp right.
 rnd.
 skip.
 simp.
 true.

qed.

qrhl {Cla[b1=b2 ∧ c1=c2 ∧ m11=m12 ∧ m21=m22 ∧ cglobA1=cglobA2] ⊓ ⟦qglobA1⟧ ≡𝔮 ⟦qglobA2⟧}
        call prg1B1; ~ call prg1B2;
     {Cla[b1=b2]}.

 inline prg1B1.
 inline prg1B2.
 inline B1.
 inline B2.
 call.
 wp left.
 wp right.
 swap left.
 swap right.
 rnd r,r <- map_distr (λr. (r,r+m11+m22)) (uniform UNIV).
 simp aux_bij mysimp2.
 call.
 simp.
 skip.
 simp.
 true.

qed.

    
qrhl {Cla[b1=b2 ∧ c1=c2 ∧ m11=m12 ∧ m21=m22 ∧ cglobA1=cglobA2] ⊓ ⟦qglobA1⟧ ≡𝔮 ⟦qglobA2⟧}
        call indcpa1; ~ call prg0B2;
     {Cla[b1=b2]}.

 inline indcpa1.
 inline prg0B2.
 inline B2.
 call.
 wp left.
 wp right.
 simp.
 call.
 simp.
 wp right.
 rnd.
 skip.
 simp.
 true.
    
qed.
