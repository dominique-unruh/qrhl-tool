\newif\ifdraft

%\drafttrue

\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,paralist,stmaryrd,mathpartir,mathtools,tabularx,xcolor,centernot,tabto}
\usepackage{tocloft}

\usepackage[backend=bibtex,maxbibnames=100]{biblatex}

\usepackage{makeidx}\makeindex
\usepackage[font=footnotesize,labelfont=bf]{caption}
\usepackage{graphicx}
\usepackage[section]{placeins}
\usepackage{idxlayout}
\usepackage{yfonts}
\usepackage{listings}
\usepackage{longtable}
\usepackage{declmath}
\usepackage{version}
\usepackage{xr}
\usepackage[framemethod=tikz]{mdframed}
% don't load geometry if preview is to be loaded
% (the ifx-statement detects \PassOptionsToPackage{preview}{...})
\expandafter\ifx\csname opt@preview.sty\endcsname\relax
\usepackage[a4paper,margin=1in]{geometry}
\fi
\usepackage[users=Q]{uchanges}
\usepackage{circuits}
\ChangesSetUserColor[Dominique]{Q}{red}
\ChangesSetUserColor[Reviewer]{R}{invalid}
\usepackage[pdfborderstyle={/S/U/W 0.3}]{hyperref}
\usepackage[delaytext,envcountsame,multiautoref]{latexhacks}

\usetikzlibrary{decorations.pathreplacing}

\lstdefinelanguage{qrhl}{
  morekeywords={vars,inner,calls,if,then,else,local,isabelle,classical,var,quantum,program,qrhl,lemma,qed,ambient,include,call,adversary,measure,with,inline,simp,wp,conseq,post,rule,skip},
  sensitive=true,
  commentstyle=\empty,
  extendedchars=false,
  string=[b]",
  stringstyle=\ttfamily,
  escapeinside=\^^A\^^B,
  %backgroundcolor=\color{gray!10},
  numbers=left,
  numbersep=5pt,
  numberstyle=\tiny\color{gray}
}

\lstdefinelanguage{isabelle}{
  morekeywords={axiomatization,where,simp,and,definition},
  sensitive=true,
  extendedchars=false,
  commentstyle=\empty,
  escapeinside=\^^A\^^B,
  %backgroundcolor=\color{gray!10},
  numbers=left,
  numbersep=5pt,
  numberstyle=\tiny\color{gray}
}

\DeclareUnicodeCharacter{2265}{\ensuremath{\geq}}
\DeclareUnicodeCharacter{27F7}{\ensuremath{\longleftrightarrow}}
\DeclareUnicodeCharacter{22C3}{\ensuremath{\bigcup}}
\DeclareUnicodeCharacter{2A06}{\ensuremath{\bigsqcup}}
\DeclareUnicodeCharacter{27F9}{\ensuremath{\Longrightarrow}}
\DeclareUnicodeCharacter{212D}{\ensuremath{\mathfrak C}}
\DeclareUnicodeCharacter{1D529}{\ensuremath{\mathfrak l}}
\DeclareUnicodeCharacter{1D51E}{\ensuremath{\mathfrak a}}
\DeclareUnicodeCharacter{1D52E}{\ensuremath{\mathfrak q}}
\DeclareUnicodeCharacter{2260}{\ensuremath{\neq}}
\DeclareUnicodeCharacter{3BB}{\ensuremath{\lambda}}
\DeclareUnicodeCharacter{2293}{\ensuremath{\sqcap}}
\DeclareUnicodeCharacter{27E6}{\ensuremath{\llbracket}}
\DeclareUnicodeCharacter{301A}{\ensuremath{\llbracket}}
\DeclareUnicodeCharacter{27E7}{\ensuremath{\rrbracket}}
\DeclareUnicodeCharacter{301B}{\ensuremath{\rrbracket}}
\DeclareUnicodeCharacter{2297}{\ensuremath{\otimes}}
\DeclareUnicodeCharacter{22C5}{\ensuremath{\cdot}}
\DeclareUnicodeCharacter{B7}{\ensuremath{\cdot}}
\DeclareUnicodeCharacter{BB}{\text\guillemotright}
\DeclareUnicodeCharacter{2227}{\ensuremath{\land}}
\DeclareUnicodeCharacter{2261}{\ensuremath{\equiv}}
\DeclareUnicodeCharacter{2208}{\ensuremath\in}
\DeclareUnicodeCharacter{2264}{\ensuremath\leq}
\DeclareUnicodeCharacter{2228}{\ensuremath\vee}
\DeclareUnicodeCharacter{2200}{\ensuremath\forall}
\DeclareUnicodeCharacter{22A5}{\ensuremath\bot}
\DeclareUnicodeCharacter{AC}{\ensuremath\lnot}
\DeclareUnicodeCharacter{2286}{\ensuremath\subseteq}
\DeclareUnicodeCharacter{2209}{\ensuremath\notin}
\DeclareUnicodeCharacter{21D2}{\ensuremath\Rightarrow}
\DeclareUnicodeCharacter{3B4}{\ensuremath\delta}
\DeclareUnicodeCharacter{27F6}{\ensuremath\rightarrow}

\newcommand\mytilde{\raise.17ex\hbox{$\scriptstyle\sim$}}


\makeatletter



%\hyphenation{proof-script}

\input{macros}
%\input{pastebin}

\sloppy


\DeclareUnicodeCharacter{212D}{\textswab C}
\DeclareUnicodeCharacter{1D529}{\textswab l}
\DeclareUnicodeCharacter{1D51E}{\textswab a}
\DeclareUnicodeCharacter{2260}{\ensuremath{\neq}}
\DeclareUnicodeCharacter{27E6}{\ensuremath{\llbracket}}
\DeclareUnicodeCharacter{27E7}{\ensuremath{\rrbracket}}
\DeclareUnicodeCharacter{2297}{\ensuremath{\otimes}}
\DeclareUnicodeCharacter{22C5}{\ensuremath{\cdot}}
\DeclareUnicodeCharacter{2264}{\ensuremath{\leq}}
\DeclareUnicodeCharacter{2293}{\ensuremath{\sqcap}}

\hyphenation{Isa-belle}
\hyphenation{Isa-belle/HOL}


\lstset{
  basicstyle=\small\ttfamily,
  literate={~} \mytilde {1},
  breaklines=true,
  escapeinside=\^^A\^^B,
}

\makeatletter

\DeclareCaptionFormat{myformat}{#1#2#3\leavevmode\leaders\hrule height .1pt\hfill\kern\z@}
\captionsetup[figure]{format=myformat}


%\fullshort{
\renewcommand\sectionautorefname{Section}
\renewcommand\subsectionautorefname{Section}
\renewcommand\subsubsectionautorefname{Section}
\newcommand\lemmaautorefname{Lemma}
\newcommand\conjectureautorefname{Conjecture}
\newcommand\definitionautorefname{Definition}
\newcommand\corollaryautorefname{Corollary}
\newcommand\claimautorefname{Claim}
% }{
% \renewcommand\sectionautorefname{Sec.}
% \renewcommand\subsectionautorefname{Sec.}
% \renewcommand\subsubsectionautorefname{Sec.}
% \renewcommand\theoremautorefname{Thm.}
% \newcommand\lemmaautorefname{Lemma}
% \newcommand\conjectureautorefname{Conjecture}
% \newcommand\definitionautorefname{Def.}
% \newcommand\corollaryautorefname{Coro.}
% \newcommand\claimautorefname{Claim}
% }


\mdfdefinestyle{theoremstyle}{%
  linecolor=black,
  backgroundcolor=black!10!white,
  frametitlebelowskip=0pt,
  innerleftmargin=5pt,
  innerrightmargin=5pt,
}

\mdtheorem[style=theoremstyle]{definition}{Definition}
\mdtheorem[style=theoremstyle]{lemma}{Lemma}
\mdtheorem[style=theoremstyle]{corollary}{Corollary}


\newtheorem{theorem}{Theorem}
\newtheorem{conjecture}{Conjecture}

\newcounter{claimstep}
\newtheorem{claim}{Claim}[claimstep]
\renewcommand\theclaim{\arabic{claim}}


\newcommand\toolidx[1]{\index{#1@\textttOLD{#1} (tool command)}}


\AtBeginDocument{
  \ifx\PreviewMacro\undefined\else
  \PreviewEnvironment*{figure}
  \PreviewMacro*\footnote
  \PreviewMacro[!]\boardpic
  \PreviewMacro*\lstinputlisting
  \PreviewMacro[{[]{}{}{}}]\RULE
  \fi}

\bibliography{qrhl}


\newcommand\PROOFREAD[1]{\TODOQ{proofread\ifx!#1!\else #1\fi}}
%\renewcommand\PROOFREAD[1]{}

\newcommand\giturl[1]{\url{https://raw.githubusercontent.com/dominique-unruh/qrhl-tool/master/#1}}

\newenvironment{citemize}{\begin{itemize}}{\end{itemize}}

\allowdisplaybreaks


\externaldocument[main:]{qrhl}

\newcommand\qrhlautoref[1]{\autoref*{main:#1} in~\cite{qrhl-paper-from-manual}}
\newcommand\qrhlautorefx[1]{\autoref*{main:#1}}

\renewcommand\refrule[1]{\hbox{\textsc{#1}} rule}
\renewcommand\ruleref[1]{rule \hbox{\textsc{#1}}}
\renewcommand\rulerefx[1]{\hbox{\textsc{#1}}}
\renewcommand\Ruleref[1]{Rule \hbox{\textsc{#1}}}


\begin{document}

\title{qRHL tool -- Manual}
\author{Dominique Unruh\\\small University of Tartu}
\date{}


\maketitle

\ifdraft
\begin{center}
  \LARGE\bfseries
  % Do not change this wording, it is used by Makefile and build.sbt
  THIS IS A DRAFT
\end{center}
\fi

\let\subsubsection\subsection
\let\subsection\section

\tableofcontents


\bigskip
\bigskip
\bigskip

{\centering\framebox{
  \parbox{.9\hsize}{
This is a user manual for our proof assistant for
performing qRHL-based security proofs.  The tool is a prototype to
demonstrate the logic and to experiment with security proofs. At this
point, it is not yet meant for larger developments.

This manual assumes knowledge of the underlying qRHL formalism, see
\cite{qrhl-paper-from-manual}.

The source code is published on GitHub \cite{github-source}.

For installation instructions see the webpage \cite{install-instructions}.
}}\par}


\bigskip





\subsection{Architecture}

The tool consists of three main components: a ProofGeneral
\cite{proofgeneral} frontend, the core tool written in Scala, and an
Isabelle/HOL \cite{isabelle} backend with custom theories. The
ProofGeneral frontend merely eases the interactive development of
proofs; once a proof script is finished, it can also be checked by the
core tool directly. The core tool implements a theorem prover for qRHL
(with tactics-based backward reasoning). Only tactics for manipulating
qRHL judgements are built-in into the core tool. Many tactics produce
subgoals that are not qRHL judgments.
(We call those \emph{``ambient'' subgoals}%
\index{ambient subgoal} because they are expressed in the ambient logic.)
Those ambient subgoals are outsourced to
the Isabelle/HOL backend for simplification or solving. This way, the
overall tool supports arbitrarily complex pre- and post-conditions in
qRHL statements, and arbitrarily complex expressions within programs
(only limited by what can be expressed in Isabelle/HOL). The
Isabelle/HOL backend is automatically executed by the core tool (via scala-isabelle \cite{scala-isabelle}).
  

More precisely, when parsing a program, all expressions (e.g.,
\texttt{1+2} in an assignment \texttt{a <- 1+2}) are sent as literal
strings to Isabelle/HOL for parsing. And in a qRHL judgement such as
\texttt{\{ℭ𝔩𝔞[x1=x2]\} x <- x+1; \mytilde{} skip; \{ℭ𝔩𝔞[x1≠x2]\}}, the
predicates \texttt{ℭ𝔩𝔞[x1=x2]} and \texttt{ℭ𝔩𝔞[x1≠x2]} are also parsed
by Isabelle/HOL. In order to support the different constructions used
in predicates (see \qrhlautoref{sec:predicates}, e.g., $\CL{\dots}$
or $\quanteq$),
we include an Isabelle/HOL theory \texttt{QRHL.thy} in the tool that
contains the definitions and simplification rules needed for reasoning
about quantum predicates.

We stress that although we use Isabelle/HOL as a backend, this does
not mean that our tool is an LCF-style theorem prover (i.e., one that
breaks down all proofs to elementary mathematical proof steps).  All
tactics in the tool, and many of the simplification rules in
\texttt{QRHL.thy} are axiomatized (and backed by the proofs in this
paper).\footnote{The theory \texttt{QRHL.thy} is integrated in executable in the binary distribution
  but can be inspected 
  at \url{https://github.com/dominique-unruh/qrhl-tool/blob/master/src/main/isabelle/QRHL.thy}.}
We simply use Isabelle/HOL as a backend because it comes with
rich existing theories and tools. Embedding it in our tool avoids
duplication of effort.

A proof script for our tool consists of a UTF-8 encoded qRHL file
\texttt{example.qrhl}, optionally accompanied by an Isabelle/HOL
theory \texttt{Example.thy}. See \autoref{fig:example}. The
accompanying Isabelle/HOL theory can define additional constants
(e.g., \texttt{square}) and simplification rules (e.g.,
\texttt{square\_simp}), etc.  

\begin{figure}[t]\centering
  \lstset{aboveskip=0pt,belowskip=0pt,frame=single}
  \centering
  \begin{tabular}{p{.45\hsize}p{.45\hsize}}
    \textbf{example.qrhl}
    &
      \textbf{Example.thy}
    \\[-5pt]
    \lstinputlisting{example.qrhl.lst}
    &
      \lstinputlisting{Example.thy.lst}
  \end{tabular}
  \vspace*{-5mm}
  \caption{Example qRHL proof script. The files are bundled with the tool.}
  \label{fig:example}
\end{figure}

To execute the example, execute \texttt{proofgeneral.sh
  example.qrhl}\footnote{Or \texttt{proofgeneral.ps1} on Windows.
  And see \cite{proofgeneral-config} for more information how to install/invoke ProofGeneral for \texttt{qrhl-tool}.}
  and then use, e.g., \texttt{Ctrl-C Ctrl-N} to evaluate
the file step by step. (If emacs is not available, you can also run
\texttt{bin/qrhl example.qrhl} noninteractively.) To edit
\texttt{Example.thy}, execute \texttt{run-isabelle.sh Example.thy}.

\paragraph{Configutation file.}%
\index{configuration file}\index{qrhl-tool.conf@\texttt{qrhl-tool.conf}}
General configuration of the tool is done via the file \texttt{qrhl-tool.conf}.
More specifically, \texttt{qrhl-tool} looks for \texttt{\textnormal{\textit{installation\_dir}}/qrhl-tool.conf} and
\texttt{\textnormal{\textit{home\_directory}}/.qrhl-tool.conf}, in that order.
All found configuration files are loaded, with entries in the later ones overriding earlier ones.
The following entries are supported (one per line):
\begin{itemize}
\item \texttt{isabelle-home = \textnormal{\textit{dir}}} \\
  This specifies the location of the Isabelle distribution.
  (I.e., the directory that contains files such as \texttt{Isabelle2021-1}, \texttt{ROOTS}, etc.)
\item \texttt{afp-root = \textnormal{\texttt{dir}}} \\
  This specifies the location of the AFP (Archive of Formal Proofs).
  (I.e., the directory that contains subdirectories such as \texttt{thys}, \texttt{etc}, \texttt{tools}.)
  If your Isabelle installation is already configured to find the AFP (e.g., via the steps from \cite{using-afp}), this key is optional.
% \item \texttt{session = \textnormal{\textit{session}}} \\
%   This specifies a different base session for Isabelle to load inside \texttt{qrhl-tool}.
%   The default is the session \texttt{QRHL} which is predefined by the \texttt{qrhl-tool} distribution.
%   Specifying a different session can be used to speed up starting \texttt{qrhl-tool} since the theories contained in that session do not have to be loaded upon each activation.
%   If you configure a session here, it is highly recommended that this session includes the theories \texttt{QRHL.QRHL} and \texttt{QRHL.QRHL\_Operations}.
%   See \cite[Section 2.1 ``Session ROOT specifications'']{isabelle-system} for information how to specify Isabelle sessions.
% \item \texttt{session-dirs = \textnormal{\textit{dir1}}, \textnormal{\textit{dir2}}, ..., \textnormal{\textit{dirn}}} \\
%   Additional directories where Isabelle should look for sessions.
%   (E.g., the directory where you defined the session specified with \texttt{session}.)
%   Several directories are separated by commands.
%   Spaces after the commas are mandatory.
\end{itemize}
Furthermore, \texttt{qrhl-tool} reads Isabelle configuration files (files \texttt{ROOT} and \texttt{ROOTS}, see \cite{isabelle-system}) from the directory containing the .qrhl-files containing the \hyperref[command:isabelle]{\texttt{isabelle} command}.


\subsection{Proof scripts}
\label{sec:tool.proofscripts}

qRHL proof scripts contain a mixture of declarations (e.g., defining a
variable or a program), claims (e.g., qRHL judgements), and proofs.
Syntactically, the script is a sequence of commands.

A command is a single or multiline string, terminated with a
``\texttt{.}''.
Inside a command, line breaks are treated like spaces.

Comments start with ``\texttt{\#}'' and continue till the end of the line.
Comments need to be on their own line or separated by whitespace from preceding code.\footnote{%
  I.e., ``\texttt{\# comment}'' is a comment, ``\texttt{isabelle. \# comment}'' is a command followed by a comment,
  but ``\texttt{isabelle.\# comment}'' does not contain a comment (and leads to an error).
  This allows us to use the \texttt{\#} character (used by Isabelle for list cons) inside formulas as long as it is not prefixed by space.}

\paragraph{Isabelle initialization.} The first command in a proof
script must be ``\texttt{isabelle.}''\pagelabel{command:isabelle}\toolidx{isabelle} This
initializes Isabelle/HOL. If a
custom Isabelle/HOL theory ``\texttt{Example.thy}'' is to be used, use
the command ``\texttt{isabelle Example.}'' instead.
Custom Isabelle/HOL theories should import the theory \texttt{QRHL} to get
access to qRHL-related definitions, lemmas, and simplification rules.
(But this is not mandatory.)
Several theories can be specified in one \texttt{isabelle} command (comma separated). 
Repeated \emph{identical} \texttt{isabelle} commands are allowed.
See \autoref{sec:isabelle} for more information on accompanying theories.

By default, Isabelle is loaded with the session \texttt{QRHL} (defined by the \texttt{qrhl-tool} distribution).
A different base session can be specified using the syntax ``\texttt{isabelle [session\_name] theories.}''.
This session needs to be known to Isabelle, it can be configured via \texttt{ROOT} and \texttt{ROOTS} files in the same directory as the .qrhl-file containing the \texttt{isabelle} command.
It is strongly recommended that the session is based on the session \texttt{QRHL} or includes the theories \texttt{QRHL.QRHL} and \texttt{QRHL.QRHL\_Operations}, otherwise loading will be very slow.
See \cite{isabelle-system} for more information on specifying sessions.

It is also possible to include individual Isabelle commands directly inside the \texttt{.qrhl} file using the ``\texttt{isabelle\_cmd}''\toolidx{isabelle\_cmd}\phantomlabel{command:isabelle_cmd} command.
For example:
\begin{center}
  \begin{lstlisting}
    isabelle_cmd typedef my_type = "UNIV :: nat set" by auto.
  \end{lstlisting}
\end{center}
Note that \texttt{isabelle\_cmd} must not be used inside a proof (but see the \hyperref[tactic:isa]{\texttt{isa}} tactic for using Isabelle methods in a proof).
And if the command starts a proof on the Isabelle level (as \texttt{typedef} does in the above example), then the same command must finish the proof (as \texttt{by auto} does in the above example).
It is not possible to split this into two \texttt{isabelle\_cmd} commands.
(For complex situations, it is therefore recommended to edit Isabelle commands directly using Isabelle in a \texttt{.thy} file.)


\paragraph{Including files.} The \toolidx{include}\texttt{include}
command allows us to include a another qrhl file. ``\texttt{include
  "filename".} includes the file \texttt{filename}.  The effect of
including a file is the same as directly copying its content into the
current file, with two differences:
\begin{compactitem}
\item A command to include a file that has already been included will
  be ignored. This means that several files can include the same file without
  duplicating declarations, allowing for a dag dependency structure.
\item In interactive mode (i.e., in ProofGeneral), the content of an
  included file is executed in ``cheat mode''\index{cheat mode}.  That
  is, the proofs in those files are assumed to be correct and not
  checked.  This speeds up development.  (To check a file
  \texttt{file.qrhl} and all recursively included files, use the
  command line \texttt{bin/qrhl file.qrhl}.)
\end{compactitem}


\paragraph{Declaring variables.} There are three different kinds of
variables: classical, quantum, and ambient variables. Classical and
quantum variables represent classical and quantum program variables as
defined in \cite{qrhl-paper-from-manual}. These can be declared using the following commands
\begin{center}
  \toolidx{classical var}%
  \index{var@\texttt{var} (tool syntax)!classical@\texttt{classical}}%
  \toolidx{quantum var}%
  \index{var@\texttt{var} (tool syntax)!quantum@\texttt{quantum}}%
  \begin{lstlisting}
    classical var x : type.
    quantum var q : type.
  \end{lstlisting}
\end{center}
respectively. Here \texttt{x},\texttt{q} are the variable names, and \texttt{type}
is the type of the variable.
That is, in the notation of \cite{qrhl-paper-from-manual}, $\typev{\mathtt{x}}=\mathrm{UNIV}_{\mathtt{type}}$ where
$\mathrm{UNIV}_{\mathtt{type}}$ is the universe of all values of type \texttt{type}.
\texttt{type} can be an arbitrary type
that is understood by Isabelle/HOL.
(If custom types are needed, they
can be defined in an accompanying theory. Simple examples of
predefined types are \texttt{bit}, \texttt{bool}, \texttt{nat}
(natural numbers), \texttt{int} (integers).) Any program variable that
is used anywhere in the proof script must be declared. If a variable
\texttt{x} was defined, then the names \texttt{x1} and \texttt{x2} are
available in predicates to refer to that variable in the left/right
program.

Types used with \texttt{classical var} and
\texttt{quantum var} must satisfy an important condition. Namely, they
must be in the type class\footnote{A type class represents a property
  of a type, for example, the type class \texttt{finite} applies only
  to types with finite domain.} \texttt{universe}%
\index{universe@\texttt{universe} (Isabelle typeclass)}.\footnote{%
  \label{footnote:universe}The
  type class \texttt{universe} guarantees that the type
  is small enough (its cardinality is at most $\beth_i$ for some $i\in\setN$).
  Without this restriction, it would
  be possible, e.g., to have a program variable of type
  $P\ \mathtt{set}$,
  where $P$
  is the type of all programs. That would mean that programs can
  contain arbitrary elements of $P\ \mathtt{set}$.
  Hence the powerset of $P$
  can be embedded in $P$
  which is impossible. Restricting program variables to small types
  makes it possible to define $P$ (and related types).
  This is not a restriction in practice since all types built from
  basic types using powersets, functions, and inductive datatypes
  are small in this sense.}
  For most predeclared types, this will already be the case,
  but if not, follow the instructions in \autoref{sec:deftypes}.

An ambient variable simply stands for a fixed but arbitrary value.
That is, ambient variables are implicitly all-quantified.  In other
words, ambient variables are free variables of the ambient
logic. Ambient variables are declared using
\begin{center}
  \toolidx{ambient var}%
  \index{var@\texttt{var} (tool syntax)!ambient@\texttt{ambient}}%
  \begin{lstlisting}
    ambient var x : type.
  \end{lstlisting}
\end{center}
where \texttt{type} is again an arbitrary Isabelle/HOL type.


\paragraph{Program declarations.} There are two kinds of declarations
for programs. The first is
\begin{center}
  \toolidx{program}\pagelabel{command:program}
  \begin{lstlisting}
    program name := { code }.
  \end{lstlisting}
\end{center}
which defines \texttt{name} to refer to the program described by
\texttt{code}. Logically, this simply introduces an abbreviation for
referring to a concrete code fragment. This code fragment can then be
embedded in other code fragments (see the \texttt{call} statement in
the syntax of programs, \autoref{sec:tool.programs}). For the syntax of \texttt{code},
see \autoref{sec:tool.programs}.


The second kind of declaration declares an unspecified program:
\begin{center}
  \toolidx{adversary}
  \begin{lstlisting}
    adversary name free v1,v2,v3,...,vn.
  \end{lstlisting}
\end{center}
That is, after this declaration, \texttt{name} is assumed to refer to
some program containing (at most) the free program variables
\texttt{v1},\dots,\texttt{vn}. Nothing beyond that restriction on its
variables is assumed. Thus, if we prove a statement referring to
\texttt{name}, this statement holds for any program \texttt{name}. We
use these declarations to model adversaries.

In some cases, an adversary may invoke other programs (e.g., an encryption oracle).
In that case, we declare an adversary with ``holes'' using:
\begin{center}
  \toolidx{adversary}
  \begin{lstlisting}
    adversary name free v1,v2,v3,...,vn calls ?,?,...,?.
  \end{lstlisting}
\end{center}
This means the program \texttt{name} contains variables \texttt{v1,v2,v3,...,vn},
as well as $n$ ``holes'' (one for each question mark).\footnote{Formally,
  it declares \texttt{name} to refer to a multi-hole context with $n$ holes in the sense of
  \qrhlautoref{footnote:context}.}
We write \texttt{name(p1,...,pn)} to refer to \texttt{name} with \texttt{p1},\dots,\texttt{pn}
inserted instead of the holes.
(For example, \texttt{name(enc,dec)} would run the adversary \texttt{name} and allow it to invoke the
programs \texttt{enc} and \texttt{dec}.)
Note that the variables \texttt{v1,v2,v3,...,vn} do not have to include variables contained
in the programs \texttt{p1,\dots,pn}.

In addition to specifying the free variables of \texttt{name}, the
\texttt{adversary} command allows us to specify various other variable
sets. The full syntax of the command is:
\begin{center}
  \toolidx{adversary}
  \begin{lstlisting}
    adversary $A$ free $F$
              readonly $R$
              overwritten $O$
              inner $I$
              covered $C$
              calls ?,?,...,?.
  \end{lstlisting}
\end{center}
All variable specifications except \texttt{free $F$} are optional but
they have to occur in this order.  $F$ are (an upper bound on) the
free variables of \texttt{name}.  $A$. $R$ are a lower bound on the
readonly variables.\footnote{That is, $F\setminus R$ is an upper bound
  for the written variables of $A$.} $O$ is a lower bound
on the overwritten variables, that is, variables in $O$ are guaranteed
to be overwritten before they are read by $A$ (or any of the oracles
invoked by $A$). $I$ is an upper bound on the inner variables of $A$,
that is, all local variables that have an oracle call in their
scope. $C$ are a lower bound for the covered variables of $A$, i.e.,
those variables that are local over \emph{every} hole of $A$. Precise
definitions of these variable sets are given in \cite{local-variables}.
The default value for all these variable sets are the empty set.

These variable sets are necessary to avoid certain subtleties
involving oracle calls. For example, an oracle $O$ may access a global
variable $\xx$, but the adversary may invoke $O$ in a context where
$\xx$ is declared as a local variable. This will hide the global state
of $\xx$ from $O$. Thus we need to know for which variables this
happens. This is precisely described by the inner variables $I$.

Note that besides declaring the different variable sets, the user does
not have to care about them. When defining programs explicitly (using
the \texttt{program} command), all variable sets will be automatically
derived. Some tactics such as the \hyperref[tactic:frame]{\texttt{frame}} and the
\hyperref[tactic:equal]{\texttt{equal}} tactic heavily rely on the various variable sets to
decide whether they can be applied.

Since the language in this paper does not model procedure calls,
adversaries are simply program fragments that get executed as part of
a larger program. In particular, there is no syntactic provision for
inputs and outputs of an adversary. Instead, all communication with
the adversary has to take place through global variables. We recommend
the following approach to the definition of adversaries: One declares
two variables for the internal state of the adversary (one classical,
one quantum), declares some variables for input/output of the
adversary (as needed in the specific context where the adversary is
used), and then declares an adversary that uses all those variables
(with an informal comment detailing which variables are intended as input and
output). For example, in \texttt{prg-enc-rorcpa.qrhl} (see \autoref{sec:ex.ror}), we have an
adversary \texttt{A2} that takes an message \texttt{c} and returns
a bit \texttt{b}. The declaration is:
\begin{center}
  \begin{lstlisting}
    quantum var qglobA : string.
    classical var cglobA : string.
    classical var c : msg.
    classical var b : bit.
    # A2: inputs: c; outputs: b
    adversary A2 free c,b,cglobA,qglobA.
  \end{lstlisting}
\end{center}
(Here the adversary state is in \texttt{cglobA} and \texttt{qglobA}.
Those variables are also shared with other program fragments
representing different invocations of the same adversary. We use the
type \texttt{string} for the state to ensure that the type is big enough to allow to represent any computation.)

Note that this approach also allows us to model adversaries that
cannot communicate by simply giving them no shared global variables.

Furthermore, in a reduction-based security proof, we need to construct
a new adversary \texttt{B} from an existing adversary \texttt{A}. This
can be done by using the \texttt{program}-command to define a new adversary
\texttt{B} that invokes the existing (unspecified) adversary program
\texttt{A}. For example, 
\texttt{prg-enc-rorcpa.qrhl} defines:
\begin{center}
  \begin{lstlisting}
    # B: inputs: r; outputs: b
    program B := { call A1; c <- r+m; call A2; }.
  \end{lstlisting}
\end{center}


\paragraph{Goals.} To start a proof, one first needs to state a
goal. There are two kinds of goals: qRHL judgements, and ambient logic
statements. A qRHL judgement goal is opened using the
\texttt{qrhl}-command:
\begin{center}
  \toolidx{qrhl}
  \begin{lstlisting}
    qrhl name: {pre} code1 ~ code2 {post}.
  \end{lstlisting}
\end{center}
Here \texttt{name} is the name under which the proven fact will be
stored. And \texttt{pre} and \texttt{post} are quantum predicates (parsed by
Isabelle/HOL, see \autoref{sec:tool.pred}), and \texttt{code1},
\texttt{code2} are programs (see \autoref{sec:tool.programs} for the
syntax). The meaning of this command is that we start a proof of the
qRHL judgment
$\rhl{\mathtt{pre}}{\mathtt{code1}}{\mathtt{code2}}{\mathtt{post}}$.

The second kind of goal is an ambient logic goal, opened using the
\texttt{lemma}-command:
\begin{center}
  \toolidx{lemma}
  \begin{lstlisting}
    lemma name: formula.
  \end{lstlisting}
\end{center}
Here \texttt{formula} is an arbitrary formula that Isabelle/HOL
understands (ambient logic). For example,
\begin{center}
  \toolidx{qed}
  \begin{lstlisting}
    lemma test: 1+1=2.
  \end{lstlisting}
\end{center}
starts the proof of a lemma called \texttt{test} of the fact that
$1+1=2$.
Once a lemma is proven, the new fact can be referred to like any other
fact known to Isabelle/HOL, for example when using the tactic
\texttt{simp}.

Note that \texttt{formula} cannot contain qRHL judgments.\footnote{Strictly speaking, they can. But there is currently no convenient input syntax for this, and reasoning support is limited.}
It is, however, possible to refer to
named programs (declared using the \texttt{program}-command or the
\texttt{adversary}-command) in Isabelle/HOL expressions of the
following form:
\begin{center}
  \begin{lstlisting}
    Pr[b:prog(rho)]
  \end{lstlisting}
\end{center}
Here \texttt{b} must be an expression of type \texttt{bool},
and \texttt{prog} must be the name of a
declared program, and \texttt{rho} must be an expression of type
\texttt{program\_state} (typically \texttt{rho} is simply an
uninterpreted ambient variable).  Then \texttt{Pr[b:prog(rho)]} 
denotes the probability that $\mathtt{b}=\true$
after executing \texttt{prog} with initial state $\rho$
(as in \qrhlautoref{def:prafter}).  For example,
\begin{center}
  \begin{lstlisting}
    lemma secure: Pr[b=1:game1(rho)] = Pr[b=1:game2(rho)].
  \end{lstlisting}
\end{center}
would start a goal stating that the programs \texttt{game1} and
\texttt{game2} have the same probability of outputting~$1$
in variable \texttt{b}, for any initial state. Such goals can be
transformed into qRHL goals using the tactic \texttt{byqrhl}, but they
can also be reasoned about in Isabelle/HOL (via the \texttt{simp}
tactic) which treats those probabilities as uninterpreted values $\in[0,1]$.


\paragraph{Proofs.} Once a goal has been opened using either
\texttt{qrhl} or \texttt{lemma}, the tool is in proof mode. In this
mode, the state consists of a list of subgoals. (In ProofGeneral, the
current list of subgoals are listed in the \texttt{*goals*} window.)
Each subgoal is either a qRHL judgment (like the ones created by the
\texttt{qrhl} command) or an ambient logic formula (like the ones
created by \texttt{lemma}). (A qRHL subgoal can additionally contain a
list of assumptions $A_1,\dots,A_n$
that are ambient logic formulas. In this case, the interpretation is
that the qRHL judgments holds whenever those assumptions are satisfied.)

A proof consists of a sequence of tactic invocations. Each tactic
transforms the first subgoal into zero or more subgoals.  (With the
guarantee that the new goals together imply the original subgoal.)
The available tactics are described in \autoref{sec:tactics} below.

When the list of subgoals is empty, the proof must be finished by
\begin{center}
  \begin{lstlisting}
    qed.
  \end{lstlisting}
\end{center}
This finishes the proof, and further declarations can be made, or new
goals opened. If the current proof started with a \texttt{lemma}
command, the proven fact is stored under the name specified in the
\texttt{lemma} command.

\paragraph{Focusing.}
To structure proofs better, \texttt{qrhl-tool} supports \emph{focusing}\index{focusing} on subgoals.
The command \texttt{\{}\toolidx{\{} opens a subproof that contains only the first subgoal.
When that subgoal is fully solved, the command \texttt{\}}\toolidx{\}} closes the subproof and continues with the remaining subgoals.
When \texttt{\{} is prefixed with a subgoal selector, e.g., \texttt{1,3,4:} or \texttt{1-2:}, then a subproof containing only the selected goals is opened.

Alternatively, it is possible to focus on all current subgoals one after the other with \texttt{+}.
Each \texttt{+} symbol focuses on the next one of the subgoals that were present when the first \texttt{+} was encountered.
When one \texttt{+} is encountered, all current subgoals must be focused upon with \texttt{+} commands one-by-one.
Before the next subgoal can be focused upon with \texttt{+}, the current one needs to be solved.
Instead of \texttt{+}, any combination of \texttt{+-*} can be used as a marker for focusing.
The same symbol needs to be used for all subgoals on one level, using different symbols allows nesting of focused subproofs.
A goal selector can prefix the \texttt{+} command but it needs to select all goals.
(The effect is to reorder the goals. E.g., \texttt{3,2,1:} can be used when there are three goals to solve them in reverse order.)

See \texttt{examples/focus.qrhl} for simple examples of the focusing syntax.

\paragraph{Getting information.}
The \toolidx{print}\texttt{print} can be used to show the definition of declared mathematic objects.
Specifically, if \texttt{name} is the name of a variable (declared in qrhl-tool), a program (declared in qrhl-tool), a lemma (declared in qrhl-tool or in Isabelle), or a constant (declared in Isabelle), then
\begin{center}
  \begin{lstlisting}
    print name.
  \end{lstlisting}
\end{center}
outputs the declaration of that object.
(If \texttt{name} is simultaneously the name of several of the above, several declarations are printed.)

For programs, qrhl-tool also prints the various sets of variables
(e.g., free classical variables, quantum variables, written variables,
etc.)

For constants, it provides the full Isabelle name (incl. the name of the theory) and the type.

For lemmas, it provides the statement of the lemma.

\medskip

When invoked as\phantomlabel{command:print-goal}
\begin{center}
  \begin{lstlisting}
    print goal.
  \end{lstlisting}
\end{center}
it prints the current subgoals in notation understandable to Isabelle.
This is useful for copy-and-pasting the subgoal to an Isabelle-theory (see \autoref{sec:isabelle}) and proving the lemma there.
(After that, the tactic \texttt{rule lemmaname} can be used to prove the subgoal in qrhl-tool, where \texttt{lemmaname} is the name chosen for the copy-and-pasted lemma.)
The qrhl-tool makes an effort to make the printed subgoal suitable for including in Isabelle without further editing.
In particular, it attempts to include all necessary type annotations to disambiguate the lemma.
(However, no guarantee can be made that this always works, especially in the presence of complicated user-defined syntax.)


%\TODOQ{remove this newpage if the table in programs doesn't break badly then}
%\newpage

\subsection{Programs}
\label{sec:tool.programs}

A program is represented as a list of statements.\footnote{This
  deviates slightly from the syntax of programs described in
  \qrhlautoref{sec:syn.prog}. There, larger programs are composed from
  smaller ones by using the binary sequential composition operation
  ``$\seq{}{}$''.
  However, since the sequential composition is associative (up to
  denotational equivalence), we can instead represent a nested
  application of sequential compositions as a simple list of
  statements.} Each statement is one of the following:

\newcommand\toolprog[1]{\index{#1@\textttOLD{#1} (tool program syntax)}}

%\edef\oldparindent{\the\parindent}
\begin{longtable}{|p{.275\hsize}|>{\parskip=\medskipamount}p{.66\hsize}|}
  \hline
  \textbf{Syntax} & \textbf{Meaning} \\
  \hline
  \hline
  \texttt{skip;}\toolprog{skip} & The empty program $\Skip$. \\
  \hline
  \texttt{$x$ <- $\mathit{expr}$;}%
  \symbolindexmark\TOOLassign
  & The assignment $\assign x{\emph{expr}}$.

  $x$
  must be declared as a classical variable of some Isabelle/HOL type~$T$,
  and $\emph{expr}$
  must be an Isabelle/HOL term of the same type $T$.
  $\emph{expr}$
  may contain classical and ambient variables as free variables.

  \textbf{Example:} ``\texttt{x <- x+1;}'' increases \texttt{x}.
  \\
  \hline
  \texttt{$x$ <\$ $\mathit{expr}$;}%
  \symbolindexmark\TOOLsample
  &
  The sampling $\sample x{\emph{expr}}$.

  $x$
  must be declared as a classical variable of some Isabelle/HOL type~$T$,
  and $\emph{expr}$
  must be an Isabelle/HOL term of the type $T\ \mathtt{distr}$, the type of distributions over $T$.
  (See the tables below for constants for constructing distributions.)
  $\emph{expr}$
  may contain classical and ambient variables as free variables.

  \textbf{Example:} ``\texttt{x <\$ uniform UNIV;}'' samples \texttt{x} uniformly
  from the type of $\mathtt{x}$ (assuming the type of \texttt{x} is finite).
  \\
  \hline
  \texttt{$q_1$,\dots,$q_n$ <q $\mathit{expr}$;}%
  \symbolindexmark\TOOLqinit
  & The quantum initialization $\Qinit{q_1,\dots,q_n}{\emph{expr}}$.

  $q_1,\dots,q_n$
  must be declared as quantum variables with some Isabelle/HOL types
  $T_1,\dots, T_n$.
  All $q_i$
  must be distinct variables. $\emph{expr}$
  must be an Isabelle/HOL expression of type
  $(T_1\times\dots\times T_n)\ \mathtt{ell2}$,
  the type of vectors with basis $T_1\times\dots\times T_n$.
  (See the tables below for constants for constructing states.)
  $\emph{expr}$
  may contain classical and ambient variables as free variables.

  
  Note that our definition of well-typed programs
  (\qrhlautoref{sec:syn.prog}) requires $\mathit{expr}$
  to be a unit vector, while in our tool, we allow $\emph{expr}$
  to be a non-normalized vector. This is simply to avoid having to define
  too many different types in Isabelle/HOL (which would lead to the
  need of applying type conversions very often). The tactics in the
  tool take this into account and create an explicit precondition that
  $\mathit{expr}$
  has unit length (specifically, the tactic \texttt{wp} which implements
  \ruleref{QInit1}).\footnote{\label{footnote:mkUnit}Formally, changing the type of programs
    is justified as follows: A program
    \texttt{$q_1$,\dots,$q_n$ <q $\mathit{expr}$;}
    is interpreted as $\Qinit{q_1,\dots,q_n}{\mathit{mkUnit}(e)}$
    where $\mathit{mkUnit}(\psi)=\psi$\index{mkUnit}
    for unit vectors $\psi$,
    and $\mathit{mkUnit}(\psi)$
    is an arbitrary unit vector if $\psi$
    is not a unit vector. With this interpretation, programs as
    implemented in our tool match the typing-rules and semantics
    in \cite{qrhl-paper-from-manual}.
    %
    See \autoref{footnote:wp.qinit} for how this affects the rules implemented by the tactics.
  }

  
  \textbf{Example:} ``\texttt{x,y <q EPR;}'' initializes \texttt{x},\texttt{y} to
  contain an EPR pair. (Assuming that \texttt{x} and \texttt{y} are
  quantum variables of type \texttt{bit}.)
  \\
  \hline \texttt{$x$
    <- measure $q_1$,\dots,$q_n$
    with $\mathit{measurement}$;}%
  \toolprog{measure ... with}
  & The measurement
  \[
    \Qmeasure{x}{q_1,\dots,q_n}{\mathit{measurement}}
  \]

  $x$
  must be declared as a classical variable of some Isabelle/HOL type
  $T_x$.
  $q_1,\dots,q_n$
  must be declared as quantum variables of some Isabelle/HOL types
  $T_1,\dots, T_n$.
  All $q_i$
  must be distinct variables.  $\mathit{measurement}$
  must be an Isabelle/HOL expression of type
  $(T_x,T_1\times\dots\times T_n)\ \mathtt{measurement}$,
  the type of measurements with outcomes of type $T_x$.
  (See the tables below for constants for constructing measurements.)
  $\emph{expr}$
  may contain classical and ambient variables as free variables.
  
  \textbf{Example:} ``\texttt{x <- measure q with computational\_basis;}'' measures
  the quantum variable \texttt{q} in the computational basis and
  assigns the outcome to the classical variable \texttt{x}. Both
  variables must have the same type.
  \\
  \hline
  \texttt{on $q_1$,\dots,$q_n$ apply $\mathit{expr}$;}%
  \toolprog{on ... apply}%
  \index{apply@\texttt{apply} (tool program syntax)!on@\texttt{on ...}}
  &
  The unitary quantum operation\quad $\Qapply{\mathit{expr}}{q_1,\dots,q_n}$.

  $q_1,\dots,q_n$
  must be declared as quantum variables of some Isabelle/HOL types
  $T_1,\dots, T_n$.
  All $q_i$
  must be distinct variables.   

  $\mathit{expr}$
  must be an Isabelle/HOL expression of type
  $(T_1\times\dots\times T_n,T_1\times\dots\times T_n)\ \mathtt{l2bounded}$,
  the type of bounded operators.
  (See the tables below for constants for constructing bounded operators.)
  $\emph{expr}$
  may contain classical and ambient variables as free variables.


  Note that our definition of well-typed programs
  (\qrhlautoref{sec:syn.prog}) requires $\mathit{expr}$
  to be an isometry, while in our tool, we allow $\emph{expr}$
  to be any bounded operator. This is simply to avoid having to define
  too many different types in Isabelle/HOL (which would lead to the
  need of applying type conversions very often). The tactics in the
  tool take this into account and create an explicit precondition that
  $\mathit{expr}$
  is an isometry (specifically, the tactic \texttt{wp} which implements
  \ruleref{QApply1}).\footnote{\label{footnote:mkIso}Formally, changing the type of programs
    is justified as follows: A program \texttt{on $q_1,\dots,q_n$
      apply $e$;}
    is interpreted as $\Qapply{\mathit{mkIso}(e)}{q_1,\dots,q_n}$
    where $\mathit{mkIso}(U)=U$\index{mkIso}
    for isometries $U$,
    and $\mathit{mkIso}(U)$
    is an arbitrary isometry (e.g., the identity) if $U$
    is not an isometry. With this interpretation, programs as
    implemented in our tool match the typing-rules and semantics
    in \cite{qrhl-paper-from-manual}.
    %
    %
    See \autoref{footnote:wp.qapply} for how this affects the rules implemented by the tactics.
  }

  \textbf{Example:} ``\texttt{on x,y apply CNOT;}'' applies a CNOT to the quantum
  variables \texttt{x},\texttt{y}. (They are assumed to be of type
  \texttt{bit}.)
  \\
  \hline
  \texttt{if ($c$) then $P_1$ else $P_2$}
  \toolprog{if ... then ... else}
  &
  The conditional\quad $\langif{c}{P_1}{P_2}$.

  $c$
  must be an Isabelle/HOL expression of type \texttt{bool}.  $c$
  may contain classical and ambient variables as free variables.


  The programs $P_1$
  and $P_2$
  are either single statements, or blocks of the form \texttt{\{ $s_1$
    $s_2$
    \dots{} $s_n$
    \}} where each $s_i$
  is a statement. (Note that each $s_i$ will end with a semicolon.)

  \textbf{Example:} ``\texttt{if (x=0) then x <- x+1; else skip;}'' is
  equivalent to \texttt{x <- 1;} (assuming \texttt{x} is of type
  \texttt{bit}).
  
  \textbf{Example:} ``\texttt{if (x=0) then \{ x <- 1; y <- 1; \} else
    \{ x <- 0; y <- 0; \}}'' sets \texttt{x} and \texttt{y} to $1$
  if \texttt{x=0}, and to \texttt{0} otherwise.
  \\
  \hline
  \texttt{while ($c$) then $P$}
  \toolprog{if ... then ... else}
  &
  The conditional\quad $\while{c}{P}$.

  $c$
  must be an Isabelle/HOL expression of type \texttt{bool}.  $c$
  may contain classical and ambient variables as free variables.


  The programs $P$ is either a single statement, or a block of the form \texttt{\{ $s_1$
    $s_2$
    \dots{} $s_n$
    \}} where each $s_i$
  is a statement. (Note that each $s_i$ will end with a semicolon.)

  \textbf{Example:} ``\texttt{while (x≤0) x <- x+1;}'' increases
    \texttt{x} until it is positive (assuming \texttt{x} is of type
    \texttt{int}).
  
    \textbf{Example:} ``\texttt{while (x≤0) \{ x <- x+1; y <- y+1; \}}''
    increases both \texttt{x} and \texttt{y} until \texttt{x} is positive.
    \\
    \hline
    \texttt{\{ local $X$; P \}}
    \toolprog{local}
    &
    Declares local variables $X$ in the program $P$.

    $X$ is a comma separated list of quantum and classical
    variables. Those variables must have been declared using the
    \texttt{classical\textnormal/quantum var} command. The variables
    $X$ will then be local in the program $P$. $P$ may be a single or
    several statements.

    Semantically, \texttt{\{ local $X$; P \}} first stores the
    variables $X$ on a stack and initializes them with a default
    value, then runs $P$, and then restores the original value of $X$.

    \textbf{Example:} ``\texttt{\{ local z; z <- x; x <- y; y <- z
      \}}'' swaps \texttt{x} and \texttt{y} without any side effect on
    \texttt{z}.
    \\
  \hline
  \texttt{call $\mathit{prog}$;}
  \toolprog{call}
  & The program $\mathit{prog}$ itself.

  $\mathit{prog}$
  must be the name of a program (declared with \texttt{program} or
  \texttt{adversary}).
  If the \texttt{adversary}-command declared a program ``with $n$ holes''
  (using \texttt{adversary ... calls ?,...,?}),
  then \textit{prog} is an expression of the form \texttt{name(arg1,\dots,argn)}
  where each \texttt{arg1,\dots,argn} is again the name of a program (or an expression
  of the form \texttt{name(arg1,\dots,argn)}).

  Logically, \texttt{call $\mathit{prog}$;}
  is simply an abbreviation for the code of $\mathit{prog}$
  (possibly after substituting \texttt{arg1,\dots,argn} for its holes).
  And if $\mathit{prog}$
  was defined using \texttt{program}, it would be equivalent to simply
  write the code from the definition of the program instead of
  \texttt{call $\mathit{prog}$;}.
  (Although some tactics may treat the two cases differently.)
  However, if $\mathit{prog}$
  was defined using \texttt{adversary}, the \texttt{call
    $\mathit{prog}$;}
  syntax is necessary since the code of $\mathit{prog}$ is not known.

  We do not have a corresponding construct in the syntax from
  \qrhlautoref{sec:syn.prog} because we can simply write $\mathit{prog}$
  instead of \texttt{call \textit{prog};}. (For example, \texttt{x <-
    1; call A; x <- 0;} translates to $\assign x1;A;\assign x0$.)

  Note that \texttt{call} is not a procedure call. In particular, we
  cannot pass arguments, have local variables, or get a return
  value. However, arguments and return values can be emulated
  by using global variables (see the discussion of program
  declarations in \autoref{sec:tool.proofscripts}).

  \textbf{Example:} ``\texttt{call A;}'' invokes the adversary \texttt{A}
  (assuming \texttt{A} was declared using \texttt{adversary A vars
    ...}).  ``\texttt{call A(enc,dec);}'' invokes the adversary \texttt{A}
  that can call programs \texttt{enc} and \texttt{dec}
  (assuming \texttt{A} was declared using \texttt{adversary A vars
    ... calls ?,?}).
  \\
  \hline
\end{longtable}

\subsection{Expressions and predicates}
\label{sec:tool.pred}

\newcommand\tooltype[1]{\index{#1@\textttOLD{#1} (Isabelle/HOL type)}}

\paragraph{Expressions.}
Expressions within programs, and predicates in qRHL judgments are
interpreted by Isabelle/HOL (currently the Isabelle/HOL 2021-1 version), in the
context of a builtin theory QRHL. We assume some familiarity with
Isabelle/HOL. Readers unfamiliar with Isabelle/HOL may study the
tutorial \cite{isabelle-tutorial}.

For experiments, it can be useful to directly invoke Isabelle/HOL
(using the \texttt{./run-isabelle.sh} script) and edit a theory that
imports \texttt{QRHL.QRHL}.

Expressions used in assign-statements will probably only rarely use
any of the custom types and constants from \texttt{QRHL.thy}.
However, in sampling-statements we need to construct
expressions of type $\alpha$
\texttt{distr} (distributions), and the various quantum operations
need expressions of types $(\alpha,\alpha)$
\texttt{l2bounded}, $\alpha$
\texttt{ell2}, and $(\alpha,\beta)$
\texttt{measurement}. Various predefined constants for constructing
expressions of those types are described in the table below.


\paragraph{Predicates.} Predicates (the post- and preconditions in
qRHL judgments) are also interpreted by Isabelle/HOL. They have to be
expressions of the type \texttt{mem2 ccsubspace} (abbreviated \texttt{predicate}),
with free classical
program variables (indexed with \texttt{1} or \texttt{2}, i.e., if the
program variable is \texttt{x}, then the expression may contain
\texttt{x1} and \texttt{x2}). Here \texttt{mem2} is the type of pairs
of memories, and thus \texttt{mem2 ccsubspace} is the type of closed subspaces of
$\elltwov{V_1V_2}$
where $V_1,V_2$ represent the indexed program variables.

Predicates can additionally contain quantum variables as arguments to
specific constructions, e.g., \texttt{pauliX\guillemotright$\llbracket\qq\rrbracket$}
would refer to a Pauli-$X$ operator on quantum variable $\qq$.

Predicates can be constructed using the constants described in the
tables below.



\paragraph{Types.} The theory \texttt{QRHL} provides the following
types. Some of those types are defined in Isabelle/HOL using
\texttt{typedef}, others are only axiomatized.
See \texttt{QRHL.thy} and the theories imported therein.
Others are imported from other Isabelle libraries, most importantly \texttt{Complex\_Bounded\_Operators} \cite{bounded-operators}.

In some cases, there
are several possible syntaxes for entering the same type. We list
all of them, the first being the one Isabelle/HOL will use for
printing the constant. In many cases, the syntax contains special
characters. These can be entered with an adapted TeX input method in Emacs
(which is automatically active in our ProofGeneral customization). In
those cases we additionally mention the character sequences to be entered in ProofGeneral
for getting the special characters (marked ``How to input:'' in the table below).

When defining your own types in an accompanying theory, please consult \autoref{sec:deftypes}.

\begin{longtable}{|p{.19\hsize}|>{\parskip=\medskipamount}p{.75\hsize}|}
  \hline
  \textbf{Type} & \textbf{Meaning} \\
  \hline \hline \texttt{bit}\tooltype{bit} & The type of bits.

  This type is isomorphic to \texttt{bool}, but using the type
  \texttt{bit} can lead to more familiar notation in some cases
  because the constants $0$
  and $1$
  can be used. On bits, the operations $+$,
  $*$,
  $-$,
  $/$
  are defined modulo $2$
  (that is, \texttt{bit} is the finite field of size $2$).
  In particular, the negation of $x$
  is written $x+1$ (not $-x$ which is equal to $x$).

  An implicit coercion is declared so that \texttt{bit} can be used
  where \textbf{nat} or \texttt{int} are expected.  
  \\
  \hline
  $\alpha$ \texttt{distr}\tooltype{distr} & The set of distributions over $\alpha$.

  In our context, distributions are
  functions $\mu:\alpha\to\setRpos$
  with $\sum_x\mu(x)\leq1$.

  Expressions of this type occur on the right hand side of sample
  statements (e.g., \texttt{e} in \texttt{x <\$ e;}).
  \\
  \hline
  $\alpha$ \texttt{ell2}\tooltype{ell2} & Vectors in $\elltwo \alpha$.
  
  The type is endowed with the type class
  \texttt{complex\_normed\_vector}, so operations such as $+$
  or \texttt{norm} work as expected.

  Expressions of this type occur on the rhs of quantum initialization
  statements (e.g., \texttt{e} in \texttt{q <q e;}).

  \\
  \hline
  $\alpha$ \texttt{ccsubspace}\tooltype{ccsubspace} &
  Closed subspaces of the Hilbert space $\alpha$.

  This type is used mostly for constructing quantum predicates, see also the type \hyperref[type:predicate] {\texttt{predicate}}.
  
  It is endowed with the type class \texttt{complete\_lattice}, thus
  it has operations such as \symbolindexmark\SQCAP$\sqcap$
  (\texttt{inf}) for the intersection of two spaces, \symbolindexmark\SQCUP$\sqcup$
  (\texttt{sup}) or $+$
  for the sum of two spaces, \symbolindexmark\TOOLINF\texttt{INF x:Z. f x} for the
  intersection of all spaces $f(x)$
  for $x\in Z$, and $\leq$ for inclusion of subspaces.
  And \symbolindexmark\TOOLtop\texttt{top} is the whole space $\alpha$,
  and \texttt{0} and \symbolindexmark\TOOLbot\texttt{bot} both refer to the zero-space~$0$.


  In most cases, one will use the type $\beta\ \mathtt{ell2}\ \mathtt{ccsubspace}$, i.e., subspaces of the Hilbert space $\elltwo\beta$.
  For finite dimensional $\beta$, this is the same as the space $\setC^\beta$, i.e., complex vectors of size $\abs\beta$.

  \\
  %
  \hline \texttt{mem2}\tooltype{mem2} & The quantum part of pairs of memories.  That
  is, if $V_1,V_2$
  denote the set of all variables with indices $1$
  and $2$,
  respectively, \texttt{mem2} represents $\types{\qu{V_1}\qu{V_2}}$.

  This type is mainly used for defining the type \texttt{predicate}.
  \\
  \hline \texttt{predicate}\tooltype{predicate}\phantomlabel{type:predicate}
  & An abbreviation for \texttt{mem2 ell2 ccsubspace}, that is, subspaces of
  $ \elltwo{\types{\qu{V_1}\qu{V_2}}}= \elltwov{\qu{V_1}\qu{V_2}}$.

  This is the type of quantum predicates.

  Expressions of this type occur in the pre- and postcondition of qRHL
  judgments, as well as in many subgoals generated by tactics.
  \\
  \hline
  $\alpha \Rightarrow_\mathsf{CL} \beta$ \par
  $(\alpha,\beta)$ \texttt{cblinfun}\tooltype{cblinfun} &
  Bounded operators $\bounded{\alpha,\beta}$.

  Expressions of this type occur in quantum operation statements,
  e.g., \texttt{U} in ``\texttt{on q apply U}''. In that case, \texttt{U}
  should always describe an isometry. (See the description of quantum
  operation statements in \autoref{sec:tool.programs}.)

  Expressions of this type also occur in predicates, e.g., as an
  argument to \texttt{quantum\_equality\_full} or due to application
  of the \texttt{wp} tactic (implementing \ruleref{QApply1}).

  This type will almost always be used as
  $\alpha'\ \mathtt{ell2} \Rightarrow_\mathsf{CL} \beta'\ \mathtt{ell2}$. (I.e., elements of $\boundedv{\alpha,\beta}$.)
  This can be abbreviated as $(\alpha',\beta')\ \mathtt{l2bounded}$.

  \texinput{\\fun\_CL}
  \\
  \hline $(\alpha,\beta)$ \texttt{l2bounded}\tooltype{l2bounded} &
  Abbreviation for
  $(\alpha\ \mathtt{ell2}, \beta\ \mathtt{ell2})\ \mathtt{cblinfun})$.
  
  \\
  \hline
  $(\alpha,\beta)$ \texttt{measurement}\tooltype{measurement} & Measurements $\Meas\alpha\beta$.

  Expressions of this type occur in measurements statements,
  e.g., \texttt{M} in ``\texttt{x <- measure q with M}''.
  \\
  \hline
  $\alpha$ \texttt{variable}\tooltype{variable} &
  Represents a program variable $\qq$ with $\typev\qq=\alpha$.

  One can think of a variable of type \texttt{$\alpha$
    variable} as a variable name, associated with type~$\alpha$.
  There are no constants for creating values of type
  \texttt{$\alpha$
    variable}. Instead, by declaring a quantum variable using
  \texttt{quantum var q : T;} in the tool, \texttt{q1} and \texttt{q2}
  will automatically be declared to have type \texttt{T
    variable}.\footnote{\texttt{classical var x : T;} also declares
    values of type \texttt{T variable} in Isabelle, but those are not
    needed on the user level, they are used internally.}
  Quantum variables are needed to specify registers when constructing
  predicates. (See, e.g., the description of the \texttt{lift} constant
  below.)
  \\
  \hline
  $\alpha$ \texttt{variables}\tooltype{variables} & Tuples of program variables.

  When $\mathtt{q}_1,\dots,\mathtt{q}_n$
  are variables of types \texttt{$\alpha_1$
    variable},\dots,\texttt{$\alpha_n$
    variable}, then their tuple (constructed with the syntax
  $\llbracket\texttt{q}_1,\dots,\texttt{q}_n\rrbracket$) has type
  $(\alpha_1\times\dots\times\alpha_n)\ \mathtt{variables}$.

  Having such a type is necessary for specifying certain constants
  that operate on lists of quantum variables (e.g., \texttt{lift}) in a type-safe way.
  \\
  \hline
  \texttt{program}\tooltype{program}  &
  A program.

  When a program \texttt{P} is declared with \texttt{program P :=
    ...;} or \texttt{adversary P ...;}, then \texttt{P} will have type
  \texttt{program} in Isabelle/HOL expressions. \texttt{P} can then be
  used as an argument to the \texttt{Pr[...]} constant (see the table below). There are
  no other uses of this type in our development.
  \\
  \hline \texttt{program\_state}\tooltype{program\_state} &
  A program state. That is, an
  element of $\traceposcq{V_1V_2}$
  of trace $1$,
  where $V_1,V_2$
  denote the set of all variables with indices $1$
  and $2$, respectively.

  This type is not interpreted in any way, there are no constants
  for constructing program states. The only use is as an argument to
  the \texttt{Pr[...]} constant (see the table below), to refer to
  an unspecified but fixed quantum state (typically declared by \texttt{\frenchspacing ambient
    var rho :
    program\_state}). \\
  \hline
\end{longtable}

\paragraph{Constants.} The theory \texttt{QRHL} defines the following
constants for use in expressions and predicates.
Some of those constants are defined in Isabelle/HOL, others are only axiomatized.
See \texttt{QRHL.thy} and the theories imported therein.
Others are imported from other Isabelle libraries, most importantly \texttt{Complex\_Bounded\_Operators} \cite{bounded-operators}.

In many cases, there
are several possible syntaxes for entering the same constant. We list
all of them, the first being the one Isabelle/HOL will use for
printing the constant. In many cases, the syntax contains special
characters. These can be entered with an adapted TeX input method in Emacs
(which is automatically active in our ProofGeneral customization). In
those cases we additionally mention the character sequences to be entered in ProofGeneral
for getting the special characters (marked ``How to input:'' in the table below).

For inputting other non-ASCII symbols that are defined in Isabelle, try common LaTeX macro names (e.g., \verb|\psi| for $\psi$).
Use \verb|\sub|, \verb|\sup| for sub-/superscript letters.

\newcommand\constdef[3]{#1\par
  \hskip1em\begin{minipage}{\hsize-1em}\raggedright $::#2$\end{minipage}%
  \ifx!#3!\hskip-1em\noindent\else\par\medskip\small(for #3)\fi}

\newcommand\subhead[1]{\multicolumn{2}{r@{}}{\footnotesize\bfseries #1}\\}

\newcommand\toolconst[1]{\index{#1@\textttOLD{#1} (Isabelle/HOL constant)}}

\begin{longtable}{|>{\raggedright}p{.33\hsize}|>{\parskip=\medskipamount}p{.61\hsize}|}
  \hline
  \textbf{Name / syntax / type}
  & \textbf{Meaning} \\
  \hline
  \subhead{Distributions}
  \hline
  \constdef{$\mathtt{supp}\ \mu$}{\alpha\ \mathtt{set}}{$\mathtt{\mu :: \alpha\ distr}$}
  \toolconst{supp}
  &
  %
  The support $\suppd\mu$ of the distribution $\mu$.
  %
  \\
  \hline
  \constdef{$\mathtt{weight}\ \mu$}{real}{$\mathtt{\mu :: \alpha\ \mathtt{distr}}$}
  \toolconst{weight}
  &
  %
  The weight of the distribution, that is $\sum_x\mu(x)$.
  In particular, $\mu$ is total iff $\mathtt{weight}\ \mu = 1$.
  %
  \\
  \hline
  \constdef{$\mathtt{prob}\ \mu\ x$}{\mathtt{real}}
  {$\mathtt{\mu :: \alpha\ distr}$ and $x::\alpha$}
  \toolconst{prob} &
  %
  %
  The probability $\mu(x)$ of $x$ according to distribution $\mu$.
  \\
  \hline \constdef{$\mathtt{point\_distr}\ x$}{\alpha\
    \mathtt{distr}}{ $x :: \alpha$} \toolconst{point\_distr} &
  %
  Probability distribution that samples $x$ with proability $1$. That is,
  $\mu(y)=1$ if $y=x$ and $\mu(y)=0$ otherwise for $\mu:=\mathtt{point\_distr}\ x$.
  \\
  \hline
  \constdef{$\mathtt{map\_distr}\ f\ \mu$}{\beta\ \mathtt{distr}}{
    $f :: \alpha \Rightarrow \beta$
    and
    $\mathtt{\mu :: \alpha\ distr}$}
  \toolconst{map\_distr} &
  %
  The distribution of $f(x)$ when $x$ is $\mu$-distributed. That is,
  $\nu(x)
  =
  \sum_{y\in f^{-1}(\{x\})}\mu(y)
  $
  for $\nu:=\mathtt{map\_distr}\ f\ \mu$.

  In particular, the first and second marginal of a distribution $\mu$
  on pairs are given by $\mathtt{map\_distr}\ \mathtt{fst}\ \mu$
  and $\mathtt{map\_distr}\ \mathtt{snd}\ \mu$, respectively.
  \\
  \hline
  \constdef{$\mathtt{bind\_distr}\ \mu\ f$}{\beta\ \mathtt{distr}}{
    $\mu :: \alpha\ \mathtt{distr}$
    and
    $f :: \alpha \Rightarrow \beta\ \mathtt{distr}$}
  \toolconst{bind\_distr} &
  %
  The distribution of $y$ if $x$ is sampled according to $\mu$ and $y$
  according to $f(x)$. (Monadic bind.) That is, $\nu(y)
  = \sum_x \mu(x) f(x)(y)$
  for $\nu := \mathtt{bind\_distr}\ f\ \mu$.

  In particular, $\mathtt{map\_distr}\ f\ \mu
  = \mathtt{bind\_distr}\ \mu\ (\lambda x.\ \mathtt{point\_distr}\ (f\ x))$.
  \\
  \hline
  \constdef{$\mathtt{uniform}\ M$}{\alpha\ \mathtt{distr}}
  {$M::\alpha\ \mathtt{set}$}
  \toolconst{uniform}
  &
  The uniform distribution on the set $M$ if $M$ is finite and non-empty.

  If $M$ is infinite or empty, then $\mathtt{uniform}\ M:=0$.
  \\
  %
  \hline
  \constdef{$\mathtt{Pr}[e:P(\rho)]$}{\mathtt{real}}{$e::\mathtt{bool}$
    \par and $P::\mathtt{program}$ \par and $\rho::\mathtt{program\_state}$}
  \symbolindexmark\TOOLpr
  &
  %
  The probability $\prafter {e}{P}{\rho}$
  that $e=\true$ after execution of the program $P$ with initial state $\rho$.

  Here $e$
  must be an expression of type \texttt{bool}
  (and $e$ may contain ambient and program variables without indices).

  
  $P$
  can be the name of a program declared using \texttt{program P :=
    ...;} or \texttt{adversary P var ...;}. (But in the case of $P$,
  expressions that evaluate to a program are also admissible.)

  
  The constant \texttt{probability} is internally used for representing 
  $\mathtt{Pr}[e:P(\rho)]$. It should not be used directly.
  %
  \\
  \hline
  \subhead{Operators}
  \hline
  \constdef{$A^*$\par$\mathtt{adj}\ A$}{(\beta,\alpha)\ \mathtt{cblinfun}}
  {$A::(\alpha,\beta)\ \mathtt{cblinfun}$}
  \toolconst{adj}
  &
  %
  The adjoint $A^*$ of $A$.
  \\
  \hline
  \constdef{$A \mathbin{\circ_\textsc{cl}} B$\par$\mathtt{cblinfun\_compose}\ A\ B$}
  {(\alpha,\gamma)\ \mathtt{cblinfun}}
  {$A::(\beta,\gamma)\ \mathtt{cblinfun}$
    \par and
    $B::(\alpha,\beta)\ \mathtt{cblinfun}$}
  \toolconst{cblinfun\_compose}
  \symbolindexmark\TOOLoCL
  &
  The product $AB$ of operators $A$ and $B$.

  \texinput{o\_CL}
  \\
  \hline \constdef{$A \mathbin{*_V} \psi$\par$\mathtt{cblinfun\_apply}\
    A\ \psi$} {\beta}
  {$A::(\alpha,\beta)\ \mathtt{cblinfun}$
    \par and
    $\psi::\alpha$}
  \toolconst{cblinfun\_apply}
  \symbolindexmark\TOOLstarV
  &
  The result $A\psi$ of applying the operator $A$ to the vector $\psi$.

  \texinput{*\_V}
  \\
  \hline
  \constdef{$A \mathbin{*_S} S$\par$\mathtt{cblinfun\_image}\ A\ S$}
  {\beta\ \mathtt{ccsubspace}}
  {$A::(\alpha,\beta)\ \mathtt{cblinfun}$
    \par and
    $S::\alpha\ \mathtt{ccsubspace}$}
  \toolconst{cblinfun\_image}
  \symbolindexmark\TOOLstarS
  &
  The result $AS=\{A\psi:\psi\in S\}$ of applying the operator $A$ to the subspace $\psi$.

  \texinput{*\_S}
  \\
  \hline
  \constdef{$\mathtt{id\_cblinfun}$}
  {(\alpha,\alpha)\ \mathtt{cblinfun}}
  {}
  \toolconst{id\_cblinfun}
  &
  The identity operator $\id$ on $\elltwo\alpha$.
  \\
  \hline
  %
  \constdef{$\mathtt{addState}\ \psi$}
  {(\beta,\beta\times\alpha)\ \mathtt{l2bounded}}
  {$\psi::\alpha\ \mathtt{ell2}$}
  \toolconst{addState}
  &
  %
  The operator mapping $\phi$
  to $\phi\otimes\psi$.
  (Where $\otimes$
  denotes a positional tensor product, not the labeled tensor product
  defined in \qrhlautoref{sec:prelim}.)
  \\
  \hline
  %
  \constdef{$\mathtt{unitary}\ A$}
  {\mathtt{bool}}
  {$A :: (\alpha,\beta)\ \mathtt{cblinfun}$}
  \toolconst{unitary}
  & True iff $A$ is unitary.
  \\
  \hline
  \constdef{$\mathtt{isometry}\ A$}
  {\mathtt{bool}}
  {$A :: (\alpha,\beta)\ \mathtt{cblinfun}$}
  \toolconst{isometry}
  & True iff $A$ is an isometry.
  \\
  \hline
  \constdef{$\mathtt{is\_Proj}\ A$}
  {\mathtt{bool}}
  {$A :: (\alpha,\alpha)\ \mathtt{cblinfun}$}
  \toolconst{is\_Proj}
  & True iff $A$ is a projector.
  \\
  \hline
  \constdef{$\mathtt{Proj}\ S$}
  {(\alpha,\alpha)\ \mathtt{cblinfun}}
  {$S :: \alpha\ \mathtt{ccsubspace}$}
  \toolconst{Proj}
  &
  The projector onto subspace $S$.
  \\
  \hline
  \constdef{$\mathtt{proj\_classical\_set}\ S$}
  {(\alpha,\alpha)\ \mathtt{l2bounded}}
  {$S :: \alpha\ \mathtt{set}$}
  \toolconst{proj\_classical\_set}
  & The projector onto the span
  of $\basis{} s$ with $s\in S$.
  (Equivalently $\sum_{s\in S}\basis{}s\langle s\rvert$.)
  \\
  \hline  
  \constdef{\texttt{hadamard,pauliX,pauliY,pauliZ}}
  {(\mathtt{bit},\mathtt{bit})\ \mathtt{l2bounded}}
  {}
%  \symbolindexmark\TOOLH\symbolindexmark\TOOLX\symbolindexmark\TOOLY\symbolindexmark\TOOLZ
  \toolconst{hadamard}\toolconst{pauliX}\toolconst{pauliY}\toolconst{pauliZ}
  & Hadamard, or Pauli $X$, $Y$, $Z$ operators, respectively.
  \\
  \hline
  \constdef{\texttt{CNOT}}
  {(\mathtt{bit}\times\mathtt{bit},\mathtt{bit}\times\mathtt{bit})\ \mathtt{l2bounded}}
  {}
  \toolconst{CNOT}
  & Controlled-not on two qubits (first qubit is the control)
  \\
  \hline
  \constdef{$A\tensor_o B$\par
    $\mathtt{tensor\_op}\ A\ B$}
  {(\alpha\times\beta)\ \mathtt{l2bounded}}
  {$A::\alpha\ \mathtt{l2bounded}$ \par and $B::\beta\ \mathtt{l2bounded}$}
  \toolconst{tensor\_op}
  \symbolindexmark\TOOLtensoro
  &
  The (positional) tensor product $A\otimes B$ of operators.

  (Not the labeled one between $\bounded V$
  and $\boundedv W$
  described in the preliminaries of
  \cite{qrhl-paper-from-manual}. That is,
  $A\otimes_o B\neq B\otimes_o A$.)

  \texinput{\\ox\_o, \\otimes\\subo}
  \\
  \hline
  \constdef{$\mathtt{comm\_op}$}
  {(\alpha\times\beta, \beta\times\alpha)\ \mathtt{l2bounded}}
  {}
  \toolconst{comm\_op}
  &
  The canonical isomorphism between $\elltwo{X\times Y}$ and $\elltwo{Y\times X}$.

  That is, the operator mapping $\basis{}{x,y}$ to $\basis{}{y,x}$.
  \\
  \hline
  \constdef{$\mathtt{assoc\_op}$}
  {(\alpha\mathord\times(\beta\mathord\times\gamma),\! (\alpha\mathord\times\beta)\mathord\times\gamma)\mathtt{l2bounded}}
  {}
  \toolconst{assoc\_op}
  &
  The canonical isomorphism between $\elltwo{X\times (Y\times Z)}$ and $\elltwo{(X\times Y)\times Z}$.

  That is, the operator mapping $\basis{}{x,(y,z)}$ to $\basis{}{(x,y),z}$.

  Note that in Isabelle/HOL, $\alpha\times(\beta\times\gamma)$
  is the same type as $\alpha\times\beta\times\gamma$
  but not the same as $(\alpha\times\beta)\times\gamma$.
  If we identify all those types, then $\mathtt{assoc\_op}$
  is the identity operator.
  \\
  \hline
  \constdef{$\mathtt{Uoracle}\ f$}
  {(\alpha\times\beta,\alpha\times\beta)\ \mathtt{l2bounded}}
  {$f::\alpha\Rightarrow\beta$}
  \toolconst{Uoracle}
  &
  Classical function $f$ represented as a unitary.
  More precisely, 
  $\mathtt{Uoracle}\ f : \basis{}{(x,y)}\mapsto \basis{}{(x,y+f(x))}$.

  (This is a useful construct when modeling, e.g., function that can be queried in superposition
  by a quantum algorithm.)

  The type $\beta$ must have sort $\texttt{group\_add}$. This
  guarantees that $y+f(x)$ is well-defined and has suitable properties
  (in particular, this makes $\mathtt{Uoracle}\ f$ unitary). If
  $\beta$ has even sort $\mathtt{xor\_group}$ (Abelian group with
  $x+x=0$), then additional laws for $\mathtt{Uoracle}$ will be
  available.

  Examples of types that have these sorts are \texttt{bit},
  \texttt{int}, $\mathtt{nlist}$.
  (The latter is defined in CryptHOL \cite{crypthol}, but you
  additionally need to import the theory
  \texttt{QRHL.CryptHOL\_Missing}.)

  When axiomatizing a type \texttt{T}, use the
  \texttt{declare\_variable\_type} command in Isabelle to ensure that
  it has the relevant sorts.  (See \autoref{sec:deftypes}.)
  \\
  \hline
  \subhead{States}
  %
  \hline \constdef{$\basis{}x$\par
    $\mathtt{ket}\ x$}
  {\alpha\ \mathtt{ell2}} {$x :: \alpha$}
  \toolconst{ket} & The basis state $\basis{}{x}$ of $\elltwo\alpha$.
  
  That is, the states $\basis{}{x}$ form an orthonormal basis of the Hilbert space $\elltwo\alpha$ when $x$ ranges over all values of type $\alpha$.
  
  \texinput{\\ket}
  \\
  \hline
  \constdef{$\mathtt{EPR}$}
  {(\mathtt{bit}\times\mathtt{bit})\ \mathtt{ell2}}
  {}
  \toolconst{EPR}
  &
  The state $\frac1{\sqrt2}\basis{}{00}+\frac1{\sqrt2}\basis{}{11}$.
  \\
  \hline
  \constdef{$\psi\tensor_l\phi$\par
    $\mathtt{tensor\_ell2}\ \psi\ \phi$}
  {(\alpha\times\beta)\ \mathtt{ell2}}
  {$\psi::\alpha\ \mathtt{ell2}$ and $\phi::\beta\ \mathtt{ell2}$}
  \toolconst{tensor\_ell2}
  \symbolindexmark\TOOLtensorl
  &
  The (positional) tensor product $\psi\otimes\phi$ of vectors.

  (Not the labeled one between $\elltwov V$
  and $\elltwov W$
  described in the preliminaries of
  \cite{qrhl-paper-from-manual}. That is,
  $\psi\otimes_l\phi\neq\phi\otimes_l\psi$.)

  \texinput{\\ox\_l, \\otimes\\subl}
  \\
  \hline
  \subhead{Quantum variables}
  \hline
  \constdef{$\llbracket \qq_1,\dots,\qq_n\rrbracket$\par
    $[|\qq_1,\dots,\qq_n|]$}
  {(\alpha_1\times\dots\times\alpha_n)\penalty0\ \mathtt{variables}}
  {$\qq_i::\alpha_i\ \mathtt{variable}$}
  \symbolindexmark\TOOLqvars
  &
  A typed tuple of quantum variables.

  Constants that can be applied to several quantum variables expect a
  typed tuple of quantum variables because their result type depends
  on the types of all involved quantum variables.

  For example the Isabelle/HOL expression
  $\llbracket\qq_1,\qq_2\rrbracket\quanteq\llbracket\qq_1'\rrbracket$
  expresses the quantum equality $\qq_1\qq_2\quanteq\qq_1'$
  and it is well-typed iff
  $\typev{\qq_1}\times\typev{\qq_2}=\typev{\qq_1'}$.
  Typed quantum variables allow Isabelle/HOL to check those type
  conditions.

  \texinput{\\llbracket, \\rrbracket, [|, |]}
  \\
  \hline
  \constdef{$A\text\guillemotright Q$\par
    $A>>Q$\par
    $\mathtt{lift}\ A\ Q$\par
    $\mathtt{liftOp}\ A\ Q$}
  {(\mathtt{mem2},\mathtt{mem2})\ \mathtt{l2bounded}}
  {$A::(\alpha,\alpha)\ \mathtt{l2bounded}$
    \par and
    $Q::\alpha\ \mathtt{variables}$}
  \symbolindexmark\TOOLfrqq
  \toolconst{liftOp}
  &
  The operator $\lift A Q:=\Uvarnames{Q}A\adj{\Uvarnames Q}\otimes\idv{\qu{V_1}\qu{V_2}\setminus Q}$.
  (See \qrhlautoref{def:lift}.)
  
  Intuitively, $\text\guillemotright$ takes an operator $A$
  on $\elltwo\alpha$,
  and returns the operator $A\text\guillemotright Q$
  on $\elltwov{V_1V_2}$
  that corresponds to applying $A$
  on the quantum variables $Q\subseteq V_1V_2$.

  \texinput{\\frqq, >{}>}
  %
  \\
  \hline
  \constdef{$Q \in_\mathfrak q S$\par
    $\mathtt{liftSpace}\ S\ Q$}
  {\mathtt{predicate}}
  {$A::\alpha\ \mathtt{ccsubspace}$
    \par and
  $Q::\alpha\ \mathtt{variables}$}
  \symbolindexmark\TOOLinq
  \toolconst{liftSpace}
  &
  The subspace $\Uvarnames{Q}S\otimes\elltwov{V_1V_2\setminus Q}$.
  (See \qrhlautoref{def:lift}, denoted $\lift SQ$ there.)

  Intuitively, $\text\guillemotright$
  takes a subspace $S$
  of $\elltwo\alpha$,
  and returns the subspace $S\text\guillemotright Q$
  of $\elltwov{V_1V_2}$
  that corresponds
  to the state of variables $Q$ being in subspace $S$.

  The syntax $Q \in_\mathfrak q S$ is inspired by the fact that intuitively, this means the state of $Q$ is in the space $S$.
  
  \texinput{\\in\_q}
  %
  \\
  \hline
  \constdef{$Q =_\mathfrak q \psi$}
  {\mathtt{predicate}}
  {$A::\alpha$
    \par and
  $Q::\alpha\ \mathtt{variables}$}
  \symbolindexmark\TOOLeqq
  &
  Abbreviation for $Q \in_\mathfrak q \mathtt{ccspan} \braces\psi$.

  Intuitively, this means that the state of $Q$ is in the subspace spanned by the single quantum state $\psi$. Or, in other words, the state of $Q$ is $\psi$, hence the notation.
    
  \texinput{=\_q}
  \\
  %
  \hline
  \constdef{$\mathtt{distinct\_qvars}\ Q$}
  {\mathtt{bool}}
  {$Q::\alpha\ \mathtt{variables}$}
  \toolconst{distinct\_qvars}
  &
  True if the variables in the quantum variable tuple $Q$ are all distinct.


  To automatically simplify statements of this form in an accompanying
  Isabelle theory, it is recommended to add a fact of the form
  $\mathtt{declared\_qvars}\ \llbracket\dots\rrbracket$
  to the Isabelle simplifier, see the explanations for
  $\mathtt{declared\_qvars}$.
  \\
  %
  \hline
  \constdef{$\mathtt{distinct\_qvars\_pred\_var}\ P\ Q$}
  {\mathtt{bool}}
  {$P::\mathtt{predicate}$
    \par and
    $Q::\alpha\ \mathtt{variables}$}
  \toolconst{distinct\_qvars\_pred\_var}
  &
  True iff the predicate $P$ does not contain any of the (quantum) variables in $Q$ and all variables in $Q$ are distinct.

  (Formally, ``$P$ does not contain any of the variables in $Q$'' means that $P$ is $X$-local \cite{qrhl-paper-from-manual} for some set of variables with $X\cap Q=\varnothing$.)
  
  To automatically simplify statements of this form in an accompanying
  Isabelle theory, it is recommended to add a fact of the form
  $\mathtt{declared\_qvars}\ \llbracket\dots\rrbracket$
  to the Isabelle simplifier, see the explanations for
  $\mathtt{declared\_qvars}$.
  \\
  %
  \hline
  \constdef{$\mathtt{distinct\_qvars\_op\_vars}\ A\ Q$}
  {\mathtt{bool}}
  {$A::(\mathtt{mem2},\mathtt{mem2})\ \mathtt{l2bounded}$
    \par and
    $Q::\alpha\ \mathtt{variables}$}
  \toolconst{distinct\_qvars\_op\_vars}
  &
  True iff the operator $A$ does not operate on any of the (quantum) variables in $Q$ and all variables in $Q$ are distinct.

  (Formally, ``$A$ does not operate on any of the variables in $Q$'' means that $A$ is $X$-local \cite{qrhl-paper-from-manual} for some set of variables with $X\cap Q=\varnothing$.)
  
  To automatically simplify statements of this form in an accompanying
  Isabelle theory, it is recommended to add a fact of the form
  $\mathtt{declared\_qvars}\ \llbracket\dots\rrbracket$
  to the Isabelle simplifier, see the explanations for
  $\mathtt{declared\_qvars}$.
  \\
  % 
  \hline
  \constdef{$\mathtt{distinct\_qvars\_op\_pred}\ A\ P$}
  {\mathtt{bool}}
  {$A::(\mathtt{mem2},\mathtt{mem2})\ \mathtt{l2bounded}$
    \par and
    $P::\mathtt{predicate}$}
  \toolconst{distinct\_qvars\_op\_pred}
  &
  True if the operator $A$ does not operate on any of the quantum variables occurring in the predicate $P$.

  (Formally, this mean that if the operator $A$ is $X$-local \cite{qrhl-paper-from-manual}
  and the predicate $P$ is $Y$-local \cite{qrhl-paper-from-manual}
  for some sets $X,Y$ of quantum variables with $X\cap Y=\varnothing$.)

  To automatically simplify statements of this form in an accompanying
  Isabelle theory, it is recommended to add a fact of the form
  $\mathtt{declared\_qvars}\ \llbracket\dots\rrbracket$
  to the Isabelle simplifier, see the explanations for
  $\mathtt{declared\_qvars}$.
  \\
  %
  \hline
  \constdef{$\mathtt{declared\_qvars}\ \llbracket\qq_1,\dots,\qq_n\rrbracket$\par
    $\mathtt{declared\_qvars}\ [|\qq_1,\dots,\qq_n|]$}
  {\mathtt{bool}}
  {$\qq_i::\alpha_i\ \mathtt{variable}$}
  \toolconst{declared\_qvars}
  &
  Informally, indicates that all $\qq_i$ are quantum variables declared in the tool.

  All $\qq_i$
  must be free Isabelle variables referring directly to quantum
  variables (i.e., not bound variables, nor is it permitted to, e.g., define
  $x$ as an alias for $\qq$ and then use $x$ here).
  
  Formally, this is an abbreviation for
  $\mathtt{variable\_name}\ \qq_1=s_1\land\dots\land
  \mathtt{variable\_name}\ \qq_n=s_n$, where $s_i$
  is a string literal containing the name of the variable $\qq_i$.
  The simplifier can use these statements to automatically prove
  $\mathtt{distinct\_qvars}\ \llbracket\qq_1,\dots,\qq_n\rrbracket$
  and various statements of the form $\mathtt{distinct\_qvars\_}\dots$.

  
  When reasoning in Isabelle directly (in an accompanying theory), it
  is advisable to add the assumption
  $\mathtt{declared\_qvars}\ \llbracket\qq_1,\dots,\qq_n\rrbracket$
  (where $\qq_i$
  are quantum variables declared using \texttt{quantum var ...} in our tool)
  as an assumption to lemmas that are proven in Isabelle, and to add this
  assumption to the Isabelle simplifier. See
  \texttt{Teleport\_Terse.thy} and \texttt{Teleport.thy} for
  examples.

  When invoking the simplifier from the tool via the \texttt{simp}
  tactic, it is not necessary to add those assumptions because the
  \texttt{simp} tactic already adds it automatically.
  In particular, ambient subgoals of the form
  $\mathtt{declared\_qvars}\ \llbracket\dots\rrbracket$
  are solved automatically by the \texttt{simp} tactic.
  \\
  %
  \hline
  \subhead{Subspaces \& predicates}
  % \hline
  % \constdef{$\mathtt{span}\ M$\par
  %   $\mathtt{spanState}\ M$}
  % {\alpha\ \mathtt{ccsubspace}}
  % {$M::\alpha\ \mathtt{state}\ \mathtt{set}$}
  % \toolconst{span}
  % \toolconst{spanState}
  % &
  % The span $\SPAN M$ of the states in $M$.
%
  % Equivalent to $\mathtt{span}\ (\mathtt{image}\ \mathtt{state\_to\_vector}\ M)$.
%
  % The syntax $\mathtt{span}\ M$
  % is overloaded. If Isabelle/HOL has trouble recognizing which meaning
  % of \texttt{span}
  % is intended, use \texttt{spanState}, or provide additional type
  % information for the argument $M$.
  % \\
  % 
  \hline
  \constdef{$\mathtt{ccspan}\ M$}
  {\alpha\ \mathtt{ccsubspace}}
  {$M::\alpha\ \mathtt{set}$}
  \toolconst{ccspan}
  &
  The topologically-closed span of the states (vectors) in $M$.
  \\
  %
  \hline
  \constdef{$\mathfrak{Cla}[b]$\par
    $\mathtt{Cla}[b]$\par
    $\mathtt{classical\_subspace}\ b$}
  {\mathtt{predicate}}
  {$b::\mathtt{bool}$}
  \toolconst{classical\_subspace}
  &
  The predicate $\CL b\subseteq\elltwov{V_1V_2}$.

  This allows to encode predicates about classical variables within
  quantum predicates.

  \texinput{\\Cla}
  \\
  \hline
  \constdef{{\small $\mathtt{quantum\_equality\_full}\, A_1\, Q_1\, A_2\, Q_2$}}
  {\mathtt{predicate}}
  {$A_1::(\alpha,\gamma)\ \mathtt{l2bounded}$
    \par and
    $Q_1::\alpha\ \mathtt{variables}$
    \par and
    $A_2::(\beta,\gamma)\ \mathtt{l2bounded}$
    \par and
    $Q_2::\beta\ \mathtt{variables}$}
  \toolconst{classical\_equality\_full}
  &
  The quantum equality predicate $A_1Q_1\quanteq A_2Q_2$. (\qrhlautoref{def:quanteq})
    \\
  \hline
  \constdef{$Q_1\mathrel{\mathord\equiv\mathfrak q} Q_2$ \par 
    $Q_1\ \texttt{==q}\ Q_2$ \par 
    $\mathtt{quantum\_equality}\ Q_1\ Q_2$ \par
    $\mathtt{Qeq}[\qq_1,\dots,\qq_n = \qq_1',\dots,\qq_m']$
  }
  {\mathtt{predicate}}
  {$Q_1 :: \alpha\ \mathtt{variables}$
    \par and
    $Q_2 :: \alpha\ \mathtt{variables}$}
  \toolconst{classical\_equality}
  \toolconst{Qeq[\,]}
  \symbolindexmark\TOOLqeq
  \symbolindexmark\TOOLQeq
  &
  Quantum equality $Q_1\quanteq Q_2$. (\qrhlautoref{def:quanteq.simple})

  This is an abbreviation for
  \[
    \mathtt{quantum\_equality\_full}\ \mathtt{id\_cblinfun}\ Q_1\
    \mathtt{id\_cblinfun}\ Q_2.
  \]
  (That is, Isabelle/HOL internally expands this
  abbreviation whenever it encounters it.)

  The syntax $\mathtt{Qeq}[\qq_1,\dots,\qq_n = \qq_1',\dots,\qq_m']$
  is a convenience input syntax for inputting
  $\llbracket \qq_1,\dots,\qq_n\rrbracket
  \mathrel{\mathord\equiv\mathfrak q} \llbracket
  \qq_1',\dots,\qq_m'\rrbracket$.  The variables
  $\qq_i,\qq'_i$
  must have types $\alpha_i,\alpha_i'$
  such that
  $\alpha_1\times\dots\times\alpha_n=\alpha_1'\times\dots\times\alpha_m'$.
  
  \texinput{\\qeq}
  \\
  %
  \hline
  \constdef{$P \div \psi\text\guillemotright Q$\par
    $\mathtt{space\_div}\ P\ \psi\ Q$}
  {\mathtt{predicate}}
  {$P::\mathtt{predicate}$
    \par and
    $\psi::\alpha\ \mathtt{ell2}$
    \par and
    $Q::\alpha\ \mathtt{variables}$
  }
  \toolconst{space\_div}
  \symbolindexmark\TOOLspacediv
  &
  %
  The quantum predicate
  $(\spaceat{P}{\Uvarnames Q\psi})\otimes\elltwov Q$.

  Note that the only place where $\spaceat{}{}$
  appear in our qRHL rules is in \ruleref{QInit1}, where it appears in an
  expression of the form
  $(\spaceat{P}{\Uvarnames Q\psi})\otimes\elltwov Q$.
  Because of this it is more convenient in the tool to directly define
  this combination as a single constant instead of breaking it down
  into several (more difficult to type) building blocks.

  \texinput{\\div, \\frqq, >{}>}
  \\
  %
  \hline
  \constdef{$\mathtt{ortho}\ S$}
  {\alpha\ \mathtt{ccsubspace}}
  {$S::\alpha\ \mathtt{ccsubspace}$}
  \toolconst{ortho}
  &
  Orthogonal complement $\orth S$ of $S$.
  \\
  \hline
  \constdef{$S\tensor_S T$\par
    $\mathtt{tensorSpace}\ S\  T$}
  {(\alpha\times\beta)\ \mathtt{ell2}\ \mathtt{ccsubspace}}
  {$S::\alpha\ \mathtt{ell2}\ \mathtt{ccsubspace}$ and $ T::\beta\ \mathtt{ell2}\ \mathtt{ccsubspace}$}
  \toolconst{tensorSpace}
  \symbolindexmark\TOOLtensorS
  &
  The (positional) tensor product $S\otimes T$ of subspaces.

  (Not the labeled one between $\elltwov V$
  and $\elltwov W$
  described in the preliminaries of
  \cite{qrhl-paper-from-manual}. That is,
  $S\otimes T\neq T\otimes S$.)
  
  \texinput{\\ox\_S, \\otimes\\subS}
  \\
  \hline
  \subhead{Measurements}
  \hline
  \constdef{$\mathtt{binary\_measurement}\ P$}
  {(\mathtt{bit},\alpha)\ \mathtt{measurement}}
  {$P :: (\alpha,\alpha)\ \mathtt{l2bounded}$}
  \toolconst{binary\_measurement}
  &
  Constructs a binary measurement from the project $P$. (I.e., outcome $1$ corresponds to $P$
  and outcome $0$ to $1-P$.)  
  \\
  \hline
  \constdef{$\mathtt{computational\_basis}$}
  {(\alpha,\alpha)\ \mathtt{measurement}}
  {}
  \toolconst{computational\_basis}
  &
  A projective measurement on $\elltwo\alpha$ in the computational basis.
  \\
  %
  \hline
  \constdef{$\mathtt{mtotal}\ M$}
  {\mathtt{bool}}
  {$M::(\alpha,\beta)\ \mathtt{measurement}$}
  \toolconst{mtotal}
  &
  True iff the measurement $M$ is total.
  \\
  %
  \hline
  \constdef{$\mathtt{mproj}\ M\ x$}
  {(\beta,\beta)\ \mathtt{l2bounded}}
  {$M::(\alpha,\beta)\ \mathtt{measurement}$
   \par and
    $x::\alpha$}
  \toolconst{mproj}
  &
  The projector $M(x)$ corresponding to outcome $x$ of the projective measurement $M$.
  \\
  \hline
\end{longtable}



\subsection{Tactics}
\label{sec:tactics}


In this section, we document all tactics supported by our 
tool. The tactics are not in one-to-one correspondence with the rules
from \qrhlautoref{sec:qrhl} (for example, many tactics implement a
combination of some rule with the \rulerefx{Seq} or \rulerefx{Conseq}
rule). Yet, most rules can be recovered as special cases of the
tactics. (E.g., the \ruleref{Sample1} can be implemented as the tactic
sequence \texttt{wp left. skip. simp.}) Some rules may not be
implemented in their full generality.
%(e.g., \rulerefx{Frame} is
%implemented by \texttt{equal} which does not take into account readonly
%variables\TODOQ{better example becase \texttt{frame} implements Frame}).
Rules that are not yet implemented in the tool are:
\rulerefx{Sym}, \rulerefx{QrhlElim} (but we have
\rulerefx{QrhlElimEq}), 
\rulerefx{While1}, \rulerefx{JointWhile}, \rulerefx{JointMeasure},
\rulerefx{JointMeasureSimple}.

In the description of the rules, we use Isabelle/HOL syntax for
expressions (in particular, for pre- and postconditions) because that
is the syntax used in our tool. The reader should keep this in mind
when comparing the rules described in this section with those from
\qrhlautoref{sec:qrhl}. See \autoref{sec:isabelle} for a description
of the constants used in Isabelle/HOL syntax.

Whenever we state a rule describing the operation of a tactic, the
preconditions of the rule are the subgoals created by the tactic. Any
other preconditions the rule may have (i.e., conditions that the tactic
checks immediately instead of creating a subgoal) are mentioned in the
text accompanying the rule.

\newcommand\tactic[1]{\subsubsection*{Tactic #1}\label{tactic:#1}\index{#1@\textttOLD{#1} (tactic)}}

\tactic{admit}

Solves the current subgoal without checking. This
tactic is \emph{not sound}, it can be used to prove any theorem.  It
is intended for experimentation and proof development (to get a
subgoal out of the way temporarily and focus on other subgoals first).

\tactic{byqrhl}


When invoked as ``\texttt{byqrhl qvars $\qq^{(1)},\dots,\qq^{(m)}$.}'', transforms a goal of the form
$\mathtt{Pr}[e:P(\rho)] =\mathtt{Pr}[e':P'(\rho)]$
into a qRHL subgoal. (Also works for $\leq$ or $\geq$ instead of $=$.)

Here $e,e'$
must be expressions of type \texttt{bool} (that may contain classical and ambient variables),
and $P,P'$ must be the names of programs that have been declared using the
\texttt{program} or the \texttt{adversary} command.


The tactic implements the following rule:
\begin{multline*}
\inferrule{
  \pb\rhl{\CL{\yy^{(1)}_1=\yy^{(1)}_2\land\dots\land\yy^{(n)}_1=\yy^{(n)}_2}\sqcap
    \llbracket \qq_1^{(1)},\dots,\qq_1^{(m)} \rrbracket
    \mathrel{\mathord\equiv\mathfrak q}
    \llbracket \qq_2^{(1)},\dots,\qq_2^{(m)} \rrbracket}
  {\mathtt{call}\ P}{\mathtt{call}\ P'}
  {\CL{e_1\leftrightarrow e'_2}}
}
{
  \mathtt{Pr}[e:P(\rho)] =\mathtt{Pr}[e':P'(\rho)]
}
\\
\text{with}\quad e_1 := \idx1e,\ e'_2 := \idx2e'.
\end{multline*}
Here $\yy^{(1)},\dots,\yy^{(n)}$
are the free classical variables of $P,P',e,e'$.
And $\qq^{(1)},\dots,\qq^{(m)}$
are required to be a superset of the quantum variables in
$\pb\paren{\fv(P)\setminus\overwr(P)} \cup
\pb\paren{\fv\paren{P'}\setminus\overwr\paren{P'}}$.
($\fv\paren{P}$ are the free variables, and $\overwr\paren P$ the overwritten
variables of $P$.)\footnote{Those sets are defined in \cite{local-variables}.
  The command ``\texttt{print $P$}'' shows those variables.}

If the tactic is invoked simply as \texttt{byqrhl}, then
$\qq^{(1)},\dots,\qq^{(m)}$ will simply be the quantum variables in
$\pb\paren{\fv\paren P\setminus\overwr\paren P} \cup \pb\paren{\fv\paren{P'}\setminus\overwr\paren{P'}}$, i.e., the minimum allowed set of quantum variables.

If the conclusion contains $\leq$
or $\geq$
instead of $=$,
then $\leftrightarrow$
is replaced by $\rightarrow$
or $\leftarrow$,
respectively.  If $m=0$,
then
$\llbracket \qq_1^{(1)},\dots,\qq_1^{(m)} \rrbracket
\mathrel{\mathord\equiv\mathfrak q} \llbracket
\qq_n^{(1)},\dots,\qq_n^{(m)} \rrbracket$ is replaced by \texttt{top}.

The rule is a special case of \ruleref{QrhlElimEqNew} in
\cite{local-variables}.


\bigskip

As a special case, the lhs or rhs can also be ``$1$'' instead of an
expression $\mathtt{Pr}[e:P(\rho)]$. This is then interpreted as if
the lhs/rhs was $\mathtt{Pr}[\mathtt{True}:\mathtt{skip}(\rho)]$.


\TODOQ{document byqrhl applied to a denotational equivalence}

\tactic{case}

When invoked as ``$\mathtt{case}\ z := e\mathtt{.}$'',
it replaces the subgoal $\rhl A\bc\bd B$
by $\rhl{\mathfrak{Cla}[z=e]\sqcap A}\bc\bd B$.
The variable $z$
must be a declared as an ambient variable that is not contained in
$\bc,\bd,e$
or in the code of any program declared with the \texttt{program} command.

\[
\inferrule
{\rhl{\mathfrak{Cla}[z=e]\sqcap A}\bc\bd B}
{\rhl A\bc\bd B}
\]

The tactic is justified by \ruleref{Case}. Note that \ruleref{Case}
would add an additional all-quantifier $\forall z$
to the subgoal. However, since all ambient variables are implicitly
all-quantified, the all-quantifier can be omitted.


\tactic{casesplit} 

When invoked as ``$\mathtt{casesplit}\ e\mathtt{.}$''
with a Boolean expression $e$,
the current subgoal $G$
is replaced by two subgoals $e\rightarrow G$
and $\lnot e\rightarrow G$.
This works for qRHL subgoals and ambient logic subgoals.

\[
  \inferrule
  {e\rightarrow G
    \\
    \lnot e\rightarrow G}
  {G}
\]

\tactic{clear}

When invoked as ``\texttt{clear} $n$''
for some integer $n\geq 1$,
it removes the $n$-th
assumption from the current subgoal. For qRHL subgoals, assumptions
are explicitly listed and numbered in the tool. For ambient subgoals of the form
$A_1\to \dots \to A_m\to B$,
$A_n$ is considered to be the $n$-th assumption.

\[
  \inferrule
  {A_1\to \dots A_{n-1}\to A_{n+1}\to\dots \to A_m\to B}
  {A_1\to \dots \to A_m\to B}
\]



\tactic{conseq}

When invoked as ``\texttt{conseq pre: $C$.}'',
it rewrites the precondition of the current qRHL subgoal to become~$C$.
When invoked as ``\texttt{conseq post: $C$.}'',
it rewrites the postcondition of the current qRHL subgoal to become~$C$.
$C$ must be an Isabelle/HOL expression of type \texttt{predicate}.

That is, one of the following two rules is applied (left for
\texttt{pre}, right for \texttt{post}):
\[
  \inferrule{A\leq C\\\rhl{C}\bc\bd B}{\rhl A\bc\bd B}
  \qquad
  \inferrule{C\leq B\\\rhl{A}\bc\bd C}{\rhl A\bc\bd B}
\]
%
Both rules are special cases of \ruleref{Conseq}.

\bigskip

An alternative invocation is ``\texttt{conseq qrhl:\
  \textit{lemma}}''. In this case, \textit{lemma} has must be the name
of an already proven theorem (using the \texttt{qrhl} command) stating
$\rhl{A'}\bc\bd{B'}$. Then \texttt{conseq qrhl:\ \textit{lemma}} applies the rule:
\[
  \inferrule{
    A \leq A' \\
    B' \leq B
  }{
    \rhl A\bc\bd B
  }
\]
That is, this form can be used when the current qRHL judgment has
already been proven, except with slightly different
pre-/postconditions. (But the programs need to be
identical.)

This is still a special case of \ruleref{Conseq}.


\bigskip

In many cases, already proven qRHL judgments \textit{lemma} are of the
form $\rhl{A \sqcap L\quanteq R}\bc\bd {B \sqcap L'\quanteq R'}$ where
the variables in the quantum equality are not exactly the ones needed
in the present subgoal. In this case, we can use the tactic
``\texttt{conseq qrhl ($L_\mathit{old}$->$L_\mathit{new}$;
  $R_\mathit{old}$->$R_\mathit{new}$): \textit{lemma}}''.  In this
form, the tactic will first attempt to rewrite the quantum equality
\textit{lemma}: In both $L,L'$, $L_\mathit{old}$ is replaced by
$L_\mathit{new}$, and in $R,R'$, $R_\mathit{old}$ is replaced by
$R_\mathit{new}$.  Then the tactic behaves like ``\texttt{conseq qrhl:
  \textit{lemma}}'' above except that the rewritten lemma is used.

For the rewriting to be possible, the following conditions need to be
satisfied:
\begin{compactitem}
\item $L_\mathit{old}$ is a suffix of both $L,L'$. $R_\mathit{old}$ is a suffix of both $R,R'$.
   (Checked by the tactic.)
\item $(L_\mathit{old}\cup L_\mathit{new}) \cap \fv(\bc) = \varnothing$. (Checked by the tactic.)
\item $(R_\mathit{old}\cup R_\mathit{new}) \cap \fv(\bd) = \varnothing$. (Checked by the tactic.)
\item
  \begin{compactitem}
    \item $\abs{\types{L_{\mathit{new}}}} = \infty \vee \abs{\types{L_\mathit{new}}} \geq \abs{\types{L_\mathit{old}}}$.
    \item $\abs{\types{R_{\mathit{new}}}} = \infty \vee \abs{\types{R_\mathit{new}}} \geq \abs{\types{R_\mathit{old}}}$.
    \item $L_{\mathit{old}}, L_{\mathit{new}}$ (indexed with 1) and
       $R_{\mathit{old}}, R_{\mathit{new}}$ (indexed with 1) are disjoint from the free variables of $A,B$.
  \end{compactitem}
  (These three conditions are returned as a single subgoal, usually easy to solve using \texttt{simp}.)
\end{compactitem}
The rewriting is justified by \ruleref{EqVarChange} in \cite{local-variables}.

If any of
$L_\mathit{old},L_\mathit{new},R_\mathit{old},R_\mathit{new}$ should
be the empty list, then the notation ``\texttt{.}'' can be
used. (E.g., \texttt{x,y->.} means variables $x,y$ are simply
removed.)

When invoking ``\texttt{conseq qrhl
  ($V_\mathit{old}$->$V_\mathit{new}$): \textit{lemma}}'', this is
short for ``\texttt{conseq qrhl ($V_\mathit{old}$->$V_\mathit{new}$;
  $V_\mathit{old}$->$V_\mathit{new}$): \textit{lemma}}''. (Same
replacement on left/right side.)

To be able to use this tactic, it is a good idea to set aside a
variable \texttt{aux} of some infinite type\footnote{Such a variable
  \texttt{aux} is predeclared by the tool.} that never occurs in any
programs, and then to always prove qRHL judgments of the form
$\rhl{A \sqcap L\quanteq R}\bc\bd {B \sqcap L'\quanteq R'}$ where
$L,R,L',R'$ all end in \texttt{aux}. (Intuitively, this means the
judgment in question also preserves equality of an uninvolved variable
\texttt{aux}.) Then \texttt{aux} can be replaced by other quantum
variables as needed when the qRHL judgement is used in a subproof.


\tactic{equal}

Converts a subgoal of the form
$\rhl{A}{\bc_0;\bc}{\bd_0;\bd}{B}$
where $\bc,\bd$ satisfy $\bc=\bd$ (up to few differences)
into a subgoal $\rhl{A}{\bc_0}{\bd_0}{D}$
with suitably updated postcondition $D$.
In addition, a subgoal about free variables,
as well as subgoals corresponding to the differences between $s,s'$ (if any) are produced.

The simplest form is to invoke the tactic as \texttt{equal}, this
removes the last statement on both sides, assuming it is the same
statement.

In general, the tactic is invoked as: ``\texttt{equal $n$ exclude $P$
  in $V_\mathit{in}$ mid $V_\mathit{mid}$ out $V_\mathit{out}$.}''

Here $n$ denotes how many statements should be included in the suffix
$\bc$/$bd$. $n$ can be a natural number (meaning the last $n$ lines
should be removed), the keyword \texttt{all} (meaning the whole
left/right program should be removed), or omitted (meaning one line
should be removed).

$P$ is a comma-separated list of program names. When the tactic
identifies where $\bc,\bd$ differ (see below), all invocations of the
programs $P$ are included in the list of differences (even if they are
the same invocation on both sides). This can be useful if the programs
in $P$ contain variables that would get included in the invariants
generated by \texttt{equal} in an undesired way. (Instead, we get
extra subgoals for those programs that we need to prove manually.)
``\texttt{exclude $P$}'' can be omitted.

The equal tactic works by maintaining an invariant throughout
$\bc,\bd$ that all relevant variables are equal on the left/right
side. Which variables are included in those invariants can be
finetuned using the comma-separated variable lists
$V_\mathit{in},V_\mathit{mid},V_\mathit{out}$. $V_\mathit{in}$
specifies which variables should be equal before $\bc,\bd$. (I.e.,
$V_\mathit{in}$ occurs in the updated postcondition $D$.)
$V_\mathit{mid}$ specifies which variables should be equal during the
execution of $\bc,\bd$ (this will affect the invariants in subgoals
corresponding to the differences between $\bc,\bd$).  $V_\mathit{out}$
specifies which variables should be equal after execution of $\bc,\bd$
(this affects how the original postcondition $B$ is treated, in
particular, if $B$ contains a quantum equality, then $V_\mathit{out}$
should contain exactly the quantum variables in that quantum
equality).

The sets $V_\mathit{in},V_\mathit{mid},V_\mathit{out}$ must satisfy a
number of conditions. If those conditions are not satisfied, the
tactic tries to add as few variables as possible to these sets so that
all conditions are met. (The tactic also outputs a log explaining
which variables are added to make which condition true.) Each of the
specifications \texttt{in $V_\mathit{in}$}, \texttt{mid
  $V_\mathit{mid}$}, and \texttt{out $V_\mathit{out}$} can be
omitted. This means the tactic includes as few variables as possible
in the corresponding variable list.


\textbf{In detail:}

The tactic works by instantiating and applying the following rule from \cite{local-variables}:
\[
  \inferrule[Adversary]{
    V_\mathit{in}, V_\mathit{mid}, V_\mathit{out}
    \text{ satisfy numerous conditions (see \cite{local-variables})}
  \\
  %
  %
  %
  \forall i. \pb\rhl{R \cap {\equiv}V_\mathit{mid}}
  {s_i}{s'_i}
  {R \cap {\equiv} V_\mathit{mid}}
}{
  \pb\rhl{R \cap  {\equiv}V_\mathit{in}}
  {C[s_1,\dots,s_n]}
  {C[s'_1,\dots,s'_n]}
  {R \cap {\equiv} V_\mathit{out}}
}
\]
(Here ${\equiv}V$ denotes $\CL{\xx^{(1)}_1=\xx^{(1)}_2
  \land\dots\land\xx^{(n)}_1=\xx^{(n)}_2} \cap Q_1\quanteq Q_2$
where $\xx^{(i)}$ are the classical variables in $V$ and $Q$ are the quantum variables in $V$,
and $Q_1,Q_2$ are $Q$ indexed with 1/2, respectively.)

By comparing $\bc,\bd$, a context $C$ with multiple holes is obtained
such that $\bc=C[s_1,\dots,s_n]$ and $\bd=C[s'_1,\dots,s'_n]$.\footnote{%
  The definition of multi-hole contexts is given in \qrhlautoref{footnote:context}.
  
  Note that in statements of the form \texttt{call A(p1,\dots,pn)},
  \texttt{A} is a context itself with \texttt{p1,\dots,pn} in its holes.
  So the holes of $C$ can also be arguments of adversaries in \texttt{call}-statements.
  (E.g., when $\bc=\texttt{call A(enc1)}$ and $\bd=\texttt{call A(enc2)}$,
  then $s_1=\mathtt{enc1}$ and $s'_1=\mathtt{enc2}$.)
} It is furthermore guaranteed that no program in $P$ occurs in $C$.
(In particular, if $\bc=\bd$ and $P=\varnothing$, then simply $C=\bc=\bd$.)
We call the $s_i,s_i'$ pairs ``mismatches''.

Next, the tactic instantiates
$V_\mathit{in}, V_\mathit{mid}, V_\mathit{out}$. The tactic includes
all variables given by the user (see above) and tries to add as few
variables as possible to those sets in order to satisfy the ``numerous
conditions'' from the \rulerefx{Adversary} rule.

Next, the tactic constructs a predicate $R$ such that
$\paren{R \cap {\equiv} V_\mathit{out}} \subseteq
B$. (Below we explain how $R$ is constructed.)  The updated
postcondition is then defined to be
$D:=\paren{R \cap {\equiv}V_\mathit{in}}$.

Then, by \ruleref{Adversary}, together with \ruleref{Seq} and
\ruleref{Conseq}, we can replace the subgoal
$\rhl{A}{\bc_0;\bc}{\bd_0;\bd}{B}$ by the following subgoals:
\begin{compactitem}
\item One subgoal ensuring some of the ``numerous conditions''. (Those
  that cannot be checked by the tactic internally.)
\item One subgoal $\pb\rhl{R \cap {\equiv}V_\mathit{mid}}{s_i}{s_i'}{R \cap {\equiv}V_\mathit{mid}}$
  for each mismatch $s_i,s_i'$.
\item One subgoal $\rhl{A}{\bc_0}{\bd_0}{D}$.
\end{compactitem}


Finally, we describe how $R$ is computed:
\begin{compactitem}
\item During the computation of $V_\mathit{in},\dots$, a number of
  variables are identified that must not occur in $R$ if the
  ``numerous conditions'' are to be satisfied. We write
  $Q_\mathit{forbidden}$ and $X_\mathit{forbidden}$ for those
  variables (the classical/quantum ones, respectively).
\item Let $\qu{V_\mathit{out}}$ denote the quantum variables in
  $V_\mathit{out}$. Then we remove the quantum equality
  $\qu{V_\mathit{out,1}}\quanteq\qu{V_\mathit{out,2}}$ from $B$. That
  is, if
  $B=B'\cap
  \pb\paren{\qu{V_\mathit{out,1}}\quanteq\qu{V_\mathit{out,2}}}$ (up
  to associativity and commutativity of $\cap$), we set $R_1:=B'$. If
  $B$ cannot be parsed in this way, we set $R_1:=B$.

  Obviously, $R_1\cap{\equiv} \qu{V_\mathit{out}} \subseteq B$, so
  $R_1$ is a candidate for the invariant $R$. Yet $R_1$ may still
  contain variables in
  $Q_\mathit{forbidden}$ and $X_\mathit{forbidden}$.
\item If $Q_\mathit{forbidden}\cap\fv(R)\neq\varnothing$, the tactic
  fails. (The variable sets $V_\mathit{in},\dots$ are chosen above in
  a way that attempts that this does not happen, but it cannot be
  fully excluded.)
\item Next, we remove all variables in $X_\mathit{forbidden}$ from
  $R_1$.

  The simplest approach would be to set
  $R := \bigcap_{\xx^{(1)}_1\xx^{(1)}_2\dots\xx^{(n)}_1\xx^{(n)}_2} R_1$
  where $\{\xx^{(1)}\dots\xx^{(n)}\}:=
  X_\mathit{forbidden}$. (Essentially requiring that $R_1$ holds for
  any value of those variables.) Then we would have that
  $\fv(R)\cap X_\mathit{forbidden}=\varnothing$. However, this
  approach is problematic because the resulting $R$ may be too strong
  of an invariant. E.g., if $B=\CL{\xx^{(1)}_1=\xx^{(1)}_2}$, then
  $R$ would be $R=\bigcap_{\xx^{(1)}_1\xx^{(1)}_2}\CL{\xx^{(1)}_1=\xx^{(1)}_2}
  =\pb\CL{\forall_{\xx^{(1)}_1\xx^{(1)}_2}{\xx^{(1)}_1=\xx^{(1)}_2}}
  =\CL{\false}$.

  Instead, let $\tilde\xx^{(1)}\dots\tilde\xx^{(m)}$ be all the
  classical variables in $V_\mathit{out}$ such that for each $i$, both
  $\tilde\xx^{(i)}_1$ and $\tilde\xx^{(i)}_2$ occur in $R$.  Let
  $R_2 := \pb\CL{ \lnot \paren{ \tilde\xx^{(1)} = \tilde\xx^{(1)}
      \land\dots\land \tilde\xx^{(m)} = \tilde\xx^{(m)} } } + R_1$.
  It is easy to verify that
  $R_2\cap{\equiv} \qu{V_\mathit{out}} \subseteq R_1$, and thus
  $R_2\cap{\equiv} \qu{V_\mathit{out}} \subseteq B$.

  Finally, let
  $R := \bigcap_{\xx^{(1)}_1\xx^{(1)}_2\dots\xx^{(n)}_1\xx^{(n)}_2}
  R_2$.  Then $R\cap{\equiv} \qu{V_\mathit{out}} \subseteq B$ and
  $\fv(R) \cap X_\mathit{forbidden}=\varnothing$.

  And note that if, e.g., $B=\CL{\xx^{(1)}_1=\xx^{(1)}_2}$, then
  $R= \bigcap_{\xx^{(1)}_1\xx^{(1)}_2}\pb\paren{\CL{\lnot
      \paren{\xx^{(1)}_1=\xx^{(1)}_2}} + \CL{\xx^{(1)}_1=\xx^{(1)}_2}}
  = \bigcap_{\xx^{(1)}_1\xx^{(1)}_2}\CL{
    \paren{\xx^{(1)}_1=\xx^{(1)}_2} \implies \xx^{(1)}_1=\xx^{(1)}_2}
  = \bigcap_{\xx^{(1)}_1\xx^{(1)}_2}\CL{ \true} = \CL\true$, avoiding
  the problem that the invariant becomes too strict.    
\end{compactitem}
  



\tactic{fix}

When invoked as ``\texttt{fix $z$.}'',
replaces a goal of the form $\forall x.\, e$
by $e\{z/x\}$,
i.e., $e$
with occurrences of $x$
replaced by $z$.
The variable $z$
must be a declared as an ambient variable, and it must not occur free in
$e$
or in the code of any program declared with the \texttt{program}
command.

\[
  \inferrule
  {e\{z/x\}}
  {\forall x.\, e}
\]
%
This rule is justified by the fact that free ambient variables are
implicitly all-quantified.

\tactic{frame}

When invoked as ``\texttt{frame}.'', the tactic applies the following rule:
\[
  \inferrule{
    \fv(R) \cap \qu{V_{\bc\bd}} = \varnothing
    \\
    \rhl{A\cap R}\bc\bd{B\cap R}
  }{
    \rhl{A}\bc\bd B
  }
\]
where $\qu{V_{\bc\bd}}$ are the quantum variables occurring in $\bc,\bd$ (indexed with $1$ or $2$, respectively).

The tactic requires (and checks) that the written classical variables of $\bc,\bd$ (indexed with $1$ or $2$, respectively) are disjoint from $\fv(R)$.

This tactic is a direct implementation of the rule \rulerefx{Frame}.


\tactic{if}

The \texttt{if} tactic allows to replace an if-statement at the
beginning of the left and/or right program by its then- or
else-branch.

When invoked as ``\texttt{if left}'', it applies the following rule:
\[
  \inferrule
  {
    \rhl{A \sqcap \CL{e_1}}{\bc_{\true}}\bd{B} \\
    \rhl{A \sqcap \CL{\lnot e_1}}{\bc_{\false}}\bd{B}
  }
  {
    \rhl{A}{\langif{e}{\bc_{\true}}{\bc_{\false}}}\bd{B}
  }
\]
That is, it splits the if-statement into two subgoals for each of the
branches. Here $e_1$ is $e$ with all variables $\xx$ replaced by $\xx_1$.

If we know that only the then-branch will be executed anyway, we can
use ``\texttt{if left true}'' which applies the rule:
\[
  \inferrule
  {
    A \subseteq \CL{e_1} \\
    \rhl{A \sqcap \CL{e_1}}{\bc_{\true}}\bd{B}
  }
  {
    \rhl{A}{\langif{e}{\bc_{\true}}{\bc_{\false}}}\bd{B}
  }
\]
Or if only the else-branch will be executed, we can use
``\texttt{if left false}'' which applies the rule:
\[
  \inferrule
  {
    A \subseteq \CL{\lnot e_1} \\
    \rhl{A \sqcap \CL{\lnot e_1}}{\bc_{\false}}\bd{B}
  }
  {
    \rhl{A}{\langif{e}{\bc_{\true}}{\bc_{\false}}}\bd{B}
  }
\]

Furthermore, we can invoke the tactic as ``\texttt{if right}'',
``\texttt{if right true}'', or ``\texttt{if right false}'', with
analogous behavior on the right program.

\bigskip

If both programs start with an if-statement, we can split both
if-statements simultaneously using the \texttt{if joint} tactic. If is
invoked as \texttt{if joint $l_1$-$r_1$ \dots $l_n$-$r_n$} where each
$l_i,r_i$ is a boolean (\texttt{true} or \texttt{false}). Each pair
$l_i$-$r_i$ stands for one of the possible combinations of value the
left and right conditional can take. For example \texttt{if joint
  true-true false-false} means we claim that the left and right
conditional will be equal. Then for each of these combinations, a
subgoal is added containing the corresponding then- or else-branch in
the left and right program. More precisely, the following rule is
applied:
\[
  \inferrule{
    A \subseteq \CL{\exists i.\ e_1=l_i \land f_2=r_i}
    \\
    \text{for each $i$: }
    \rhl{A \sqcap \CL{e_1=l_i \land f_2=r_i}}
    {\bc_{l_i};\bc_\mathit{rest}}
    {\bd_{r_i};\bd_\mathit{rest}}{B}
  }{
    \rhl{A}
    {\langif e{\bc_{\true}}{\bc_{\false}}; \bc_\mathit{rest}}
    {\langif f{\bd_{\true}}{\bd_{\false}}; \bd_\mathit{rest}}
    {B}
  }
\]
Here $e_1$ is $e$ with all variables $\xx$ replaced by $\xx_1$ and
$f_2$ analogously.

Note that the expression $\exists i.\ e_1=l_i \land f_2=r_i$ in first
subgoal will not be stated in this precise form but in a logically
equivalent one. (E.g., in case of the arguments \texttt{true-true
  false-false}, the expression is written $e_1=f_2$.)

The common case \texttt{if joint true-true false-false} is the default
when the tactic is invoked as \texttt{if joint}.


\tactic{inline}

When invoked as ``\texttt{inline $P$.}''
it replaces all occurrences of \texttt{call $P$;}
in the current subgoal by the code of $P$.
Here $P$
must be a program defined by \texttt{program $P$ := \{...\}.}
The current goal must be a qRHL subgoal.

Logically, this does not change the subgoal since \texttt{call $P$;}
is just an abbreviation for the code of $P$.

\tactic{isa}

When invoked as ``\texttt{isa $M$}'', it applies the Isabelle-method
$M$ to the first subgoal. For example, \texttt{isa simp} would be very
similar to the builtin \texttt{simp} tactic. This is particularly
useful to apply Isabelle methods that have no counterpart in the
\texttt{qrhl-tool}.

For example, a particularly useful tactic for understanding why a
certain ambient subgoal cannot be solved is to invoke \texttt{isa
  auto}. Since the \texttt{auto} method in Isabelle performs case
distinctions, the resulting subgoals will often make it clearer what
the remaining problem is than \texttt{simp} does.

When invoked as ``\texttt{isa ! $M$}'', the tactic does the same thing
but fails only the Isabelle method $M$ completely solves the first
subgoal.


\tactic{local}

The \texttt{local} tactic modifies the local variable declarations in
a qRHL subgoal. It comes in several forms described below:

When invoked as \texttt{local remove left: $X$} (for some variables $X$) on a
qRHL subgoal of the form $\rhl A{\texttt{\{~local $Y$;
    $P_1$~\}}}{P_2} B$, it replaces the left program by
$\rhl A{\texttt{\{~local $(Y\setminus X)$; $P_1$~\}}}{P_2} B$.
Each variable $v\in X$ must satisfy one of:
\begin{compactitem}
  \item $v$ is not a free variable of $P_1$, or
  \item $v_1$ is not a free variable of $A,B$.
\end{compactitem}
For classical variables, this requirement is checked by the tactic,
and for quantum variables, a new subgoal is generated for this
requirement (which can almost always be solved with \texttt{simp!}).

Analogously with \texttt{right} instead of \texttt{left}.

When invoked as \texttt{local remove left} or \texttt{local remove
  right} (i.e., without explicitly specified variables) it removes as
many variables as possible.

This use of the tactic is justified by the RemoveLocal1/2 rules in
\cite{local-variables}.

\bigskip

When invoked as \texttt{local up} or \texttt{local up left} or
\texttt{local up right}, it moves all local variable declarations in
both, the left, or the right program upwards as far as possible. No
additional subgoals are created.

\bigskip

When invoked as \texttt{local up $v_1,\dots,v_n$} or \texttt{local up
  left $v_1,\dots,v_n$} or \texttt{local up right $v_1,\dots,v_n$}, it
moves the local variable declarations specified by $v_1,\dots,v_n$
upwards as far as possible. No additional subgoals are created. Each
$v_i$ is either a variable name (in which case all occurrences of
\texttt{local\ $v_i$} are moved upwards), or $v_i$ is of the form
$v:i$, in which case the $i$-th occurrence of \texttt{local\ $v$} is
moved upwards.

\tactic{measure}

When invoked as  ``\texttt{measure.}'',
converts a subgoal of the form
$\rhl{A}{\,\bc; \xx\ \mathtt{<-\ measure}\ Q\ \mathtt{in}\ e \,}
{\,\bc';\xx'\ \mathtt{<-\ measure}\ Q'\ \mathtt{in}\ e' \,}{B}$
(i.e., ending in a measurement-statement on both sides) into a subgoal
$\rhl{A}{\bc}{\bc'}{C}$ with suitably updated postcondition $C$.

Here $e,e'$ must have the same type.

The tactic implements the following rule:
\[
  \inferrule{
      \rhl{A}{\bc}{\bc'}{B'}
  }{
    \rhl{A}{\,\bc; \xx\ \texttt{<-\ measure}\ Q\ \mathtt{in}\ e \,}
           {\,\bc';\xx'\ \texttt{<-\ measure}\ Q'\ \mathtt{in}\ e' \,}{B}
  }
\]
where
\begin{multline*}
  B' 
  :=
  \CL{e_1=e'_2} \sqcap
  \paren{Q_1\quanteq Q_2'} \sqcap {}
  \\
  \mathtt{INF}\ z.\
  \mathtt{let}\ \bar e = (\lift{(\mathtt{mproj}\ e_1\ z)}{Q_1}) \cdot \mathtt{top};\ 
                \bar e' = (\lift{(\mathtt{mproj}\ e'_2\ z)}{Q'_2}) \cdot \mathtt{top}\ \mathtt{in}
  \\
  {\pb\paren{B\{z/\xx_1,z/\xx'_2\} ⊓ \bar e ⊓ \bar f} + \mathtt{ortho}\ \bar e + \mathtt{ortho}\ \bar e'}
\end{multline*}
with
\begin{equation*}
  e_1 := \idx1e,
  \quad
  e'_2 := \idx2e',
  \quad
  Q_1 := \idx1Q,
  \quad
  Q'_2 := \idx2Q'.
\end{equation*}

This rule is a consequence of \ruleref{JointMeasureSimple} and \ruleref{Seq}: 
From \ruleref{JointMeasureSimple}, we obtain 
$\rhl{B'}{\,\xx\ \texttt{<-\ measure}\ Q\ \mathtt{in}\ e \,}
{\,\xx'\ \texttt{<-\ measure}\ Q'\ \mathtt{in}\ e' \,}{B}$
(The only differences between $B'$ and the precondition from
\ruleref{JointMeasureSimple} is the use of Isabelle-syntax here
and the fact that $\im e$ replaced by the equivalent $e\cdot\mathtt{top}$.)
Then with $\rhl{A}{\bc}{\bc'}{B'}$
and \ruleref{Seq}, we get the conclusion of the rule.

\tactic{o2h}

This tactic allows to apply the Semiclassical O2H Theorem from
\cite{ambainis19semiclassical} (Theorem 1, variant (1)).  We refer to
\cite{ambainis19semiclassical} for details about the O2H Theorem.  To
apply the O2H Theorem in \texttt{qrhl-tool}, we have the tactic
\texttt{o2h}. As a precondition for applying this tactic, the games
listed in \autoref{fig:games.o2h.tactic} must be defined. The games
must be defined exactly as written there, except that the names of the
games, as well as the names of the variables (IN, OUT, G, S, H, z,
in\_S, found, count) may be chosen arbitrarily. And \texttt{distr} can
be an arbitrary constant expression (meaning, the expression must not
contain any program variables but may contain ambient variables).
Furthermore, we require that the type of the oracle outputs (i.e.,
$\beta$ if $G$ has type $\alpha\Rightarrow\beta$) is of type class
\texttt{xor\_group},\footnote{This specifies
  an Abelian group with $x+x=0$.} otherwise \texttt{Uoracle} does not have the required behavior.
%
\begin{figure}[t]
  {\smaller\smaller  \lstset{language=qrhl}
\begin{lstlisting}
program queryG := {
  on IN, OUT apply (Uoracle G);
}.

program queryGS := {
  in_S <- measure IN with binary_measurement (proj_classical_set S);
  if (in_S=1) then found <- True; else skip;
  call queryG;
}.

program queryH := {
  on IN, OUT apply (Uoracle H);
}.

program Count(O) := {
  call O;
  count <- count + 1;
}.

program left := {
  count <- 0;
  (S,G,H,z) <$ distr;
  { local vars; call A(Count(queryG)); }
}.

program right := {
  count <- 0;
  (S,G,H,z) <$ distr;
  { local vars; call A(Count(queryH)); }
}.

program find := {
  count <- 0;
  (S,G,H,z) <$ distr;
  found <- False;
  { local vars; call A(Count(queryGS)); }
}.
\end{lstlisting}
  }
  \caption[Games required by o2h tactic.]{\label{fig:games.o2h.tactic}Games required by \texttt{o2h} tactic.
    The local variable declaration \texttt{local vars} can be omitted (but then must be omitted in all games).}
\end{figure}
%

That is, \texttt{queryG} and \texttt{queryH} are implementations of
the oracles that perform superposition queries to the functions
$G$ and
$H$ (using input/output registers IN, OUT).  \texttt{Count} is a
wrapper oracle that counts oracle queries (to express the bound on the
number of queries performed by
$A$).  Let the programs \texttt{left}, \texttt{right} are just the
programs defined in $P_\mathit{left},
P_\mathit{right}$ in the O2H Theorem (see
\cite{ambainis19semiclassical}). (Except that we additionally added a
counter \texttt{count} that explicitly counts the oracle queries.)
Finally, \texttt{queryGS} implements the ``punctured oracle'' $G\setminus
S$ and stores in the variable \texttt{found} whether a value in
$S$ was queried. (A punctured oracle is one that
allows superposition queries but measures whether the input register contains
a value in $S$. In the definition of that program,
``\verb|binary_measurement (proj_classical_set S)|'' constructs the
binary measurement that checks this.) Thus the game \texttt{find} corresponds to
$P_\mathit{find}$ in the O2H Theorem.

Since the games have to be in this precise form, the first step before
applying the tactic \texttt{o2h} will typically be to rewrite the
games of interest in this specific form (for a suitably defined
distribution \texttt{distr}) and show that the original and rewritten
game have the same probability of $b=1$.

The tactic \texttt{o2h} can then be applied to proof goals of the exact form:
\begin{lstlisting}
abs ( Pr[b=1 : left(rho)] - Pr[b=1 : right(rho)] )
         <= 2 * sqrt( (1+real q) * Pr[found : find(rho)] )
\end{lstlisting}
where \texttt{left} and \texttt{right} are the games from \autoref{fig:games.o2h.tactic}
and \texttt{q} is an expression (of type \texttt{nat}).  

When applying the tactic \texttt{o2h} (without any additional
arguments), it checks whether all involved games have the right form
and that none of the variables \verb|count,found,G,H,S,in_S| are in
the free variables of $A$ (but $A$ is allowed to access
\texttt{IN,OUT,b,z}). If these checks succeeds, the tactic produces
four subgoals:
{\lstset{language=qrhl}%
\begin{lstlisting}
Pr[count ≤ q : left(rho)] = 1
Pr[count ≤ q : right(rho)] = 1
Pr[count ≤ q : find(rho)] = 1
∀S G H z x. (S,G,H,z) ∈ supp distr ⟶ x ∉ S ⟶ G x = H x
\end{lstlisting}}
The first three of them express the requirement that $A$ makes at most
$q$ oracle queries (recall that \texttt{count} counts the oracle
queries because of the wrapper oracle \texttt{Count}).  And the fourth
one expresses the fact that $\forall x\notin S, G(x)=H(x)$ when $S,G,H$ are chosen
according to \texttt{distr}. (This is one of the premises of the O2H
Theorem.)

Note that the program \texttt{find} contains a punctured oracle
\texttt{queryGS}. To transform \texttt{find} into a game with normal
oracles (such as \texttt{queryG}), see the tactic
\texttt{semiclassical}.


\tactic{rename}

When invoked as \texttt{rename left: $\sigma$} or \texttt{rename
  right: $\sigma$} or \texttt{rename both: $\sigma$}, renames free variables in the left/right/both programs
according to the substitution $\sigma$.  $\sigma$ must be specified as
a sequence of mappings of the form \texttt{a->b, c->d, e->f, ...}.

Assume the current subgoal is $\rhl A\bc\bd B$.

\medskip
\noindent
%
For the tactic to be applicable, the following conditions must be satisfied:
\begin{compactitem}
\item The variables in the domain $D$ of the substitution (i.e.,
  \texttt{a,c,e,...}) have to be distinct.
\item The variables in the range $R$ of the substitution (i.e.,
  \texttt{a,c,e,...}) have to be distinct.
\item For each mapping \texttt{a->b} in the substitution, the
  variables must have the same type, and must be both classical or
  both quantum.
\item Applying $\sigma$ to the left/right/both programs must no lead
  to a collision between local and renamed free variables.  (Formally,
  $\mathit{noconflict}(\sigma,\bc)$ and/or
  $\mathit{noconflict}(\sigma,\bd)$ must hold where
  $\mathit{noconflict}$ is defined in \cite{local-variables}.)
\item
  $R\setminus D \cap (\fv(\bc) \cup V_{A1} \cup V_{B1})=\varnothing$
  where $V_{A1} := \{\xx: \xx_1\in \fv(A)\}$ and
  $V_{B1} := \{\xx: \xx_1\in \fv(B)\}$ (free variables of $A,B$ with
  index $1$ removed).  (Only in cases \texttt{left} and
  \texttt{both}.)
\item
  $R\setminus D \cap (\fv(\bd) \cup V_{A2} \cup V_{B2})=\varnothing$
  where $V_{A2} := \{\xx: \xx_2\in \fv(A)\}$ and
  $V_{B2} := \{\xx: \xx_2\in \fv(B)\}$ (free variables of $A,B$ with
  index $2$ removed).  (Only in cases \texttt{right} and
  \texttt{both}.)
\item $\qu R \cap (V_{A1} \cup V_{B1}) = \varnothing$ in cases
  \texttt{left} and \texttt{both}, and
  $\qu R \cap (V_{A2} \cup V_{B2}) = \varnothing$ in cases
  \texttt{right} and \texttt{both}.  (Here $\qu R$ are the quantum
  variables in $R$.)\footnote{This condition is not required by
    \ruleref{RenameQrhl1/2}. However, the tactic requires it because
    of the way how the renaming of quantum variables is computed
    internally.}
\item Renaming $\bc\sigma$ and/or $\bd\sigma$ (depending on
  \texttt{left/right/both}) must be possible without renaming a
  variable inside a declared program (included via a
  \texttt{call}-statement).\footnote{This condition is not required by
    \ruleref{RenameQrhl1/2}. However, if it is not satisfied, the
    result of renaming cannot be expressed without renaming the
    declared programs.}
\end{compactitem}

\medskip
\noindent
%
The tactic creates one or two subgoals:
\begin{compactitem}
\item A subgoal that checks some of the above variable
  conditions. (This subgoal may be missing if the tactic can check
  everything internally.)
\item $\rhl{A\sigma_1}{\bc\sigma}\bd{B\sigma_1}$
  or
  $\rhl{A\sigma_2}{\bc}{\bd\sigma}{B\sigma_2}$
  or
  $\rhl{A\sigma_1\sigma_2}{\bc\sigma}{\bd\sigma}{B\sigma_1\sigma_2}$
  (in cases \texttt{left}, \texttt{right}, \texttt{both}).
  
  Here $\sigma_1,\sigma_2$ are the substitutions that rename the
  1-indexed/2-indexed variables according to sigma. (I.e., $\sigma_1$
  renames \texttt{a1->b1, c1->d1, e1->f1, ...} and $\sigma_2$ renames
  \texttt{a2->b2, c2->d2, e2->f2, ...})
\end{compactitem}

\medskip
\noindent
The tactic is justified by \ruleref{RenameQrhl1/2} in
\cite{local-variables}.




\tactic{rnd}

Converts a subgoal of the form
$\rhl{A}{\,\bc;\xx\ \texttt{<\$}\ e\,}{\,\bc';\xx'\ \texttt{<\$}\
  e'\,}{B}$ (i.e., ending in a sampling on both sides) into a subgoal
$\rhl{A}{\bc}{\bc'}{C}$ with suitably updated postcondition $C$.

\medskip

Specifically, if invoked as ``\texttt{rnd.}'', the new postcondition
will be
$C:= \mathfrak{Cla}[e_1=e_2'] \sqcap (\mathtt{INF}\ z\in\mathtt{supp}\ e_1.\
B')$ where $e_1:=\idx1 e$
(all free classical variables in $e$
indexed with $1$),
and $e_2':=\idx2e$ (all free classical variables in $e'$ indexed with $2$),
and $B':=B\{z/\xx_1,z/\xx'_2\}$ (i.e., all occurrences of $\xx_1$ and $\xx_2$ replaced by a fresh variable $z$).

Informally, $C$
requires that $e$
and $e'$
are the same distribution, and $B$
holds for any $\xx_1=\xx'_2$ in the support of $e$.
That is, the syntax ``\texttt{rnd.}'' is to be used in the common case
when both programs end with the same sampling, and we want the two
samplings to be ``in sync'', i.e., to return the same value.

The variables $\xx$ and $\xx'$ must have the same type in this case.

That is, ``\texttt{rnd}.'' implements the following rule:
\[
  \inferrule
  {\pb\rhl{A}\bc{\bc'}{
      \mathfrak{Cla}[e_1=e_2'] \sqcap \pb\paren{\mathtt{INF}\ z\in\mathtt{supp}\ e_1.\ B\{z/\xx_1,z/\xx'_2\}}
    }
  }
  {\rhl{A}{\,\bc;\xx\ \texttt{<\$}\ e\,}{\,\bc';\xx'\ \texttt{<\$}\ e'\,}{B}}
  \qquad\text{where}\
  e_1:=\idx1 e,
  \
  e_2':=\idx2e'
\]
This rule is a consequence of \ruleref{JointSample}
and \ruleref{Seq}: From \ruleref{JointSample} (with
$f:=\mathtt{map\_distr}\ (\lambda z.\, (z,z))\ e_1$
and some simplifying), we get
\[
  \rhl
{
      \mathfrak{Cla}[e_1=e_2'] \sqcap \pb\paren{\mathtt{INF}\ z\in\mathtt{supp}\ e_1.\ B\{z/\xx_1,z/\xx'_2\}}
    } {\xx\
      \texttt{<\$}\ e}{\xx'\ \texttt{<\$}\ e'} {B}.
    \]
With \ruleref{Seq}, the conclusion of the rule follows.

\medskip

The second way of invoking the tactic is ``\texttt{rnd $\xx,\xx'$
  <- $f$.}''
Here $\xx,\xx'$
must be the same variables as in the sampling statements in the
subgoal.

In this case, the new subgoal will be
$\rhl{A}{\bc}{\bc'}{C}$ with
\[
  C:=
\mathfrak{Cla}[\mathtt{map\_distr}\ \mathtt{fst}\ f = e_1 \land
\mathtt{map\_distr}\ \mathtt{snd}\ f = e_2']
\sqcap
\pb\paren{\mathtt{INF}\ (\xx_1,\xx_2')\in \mathtt{supp}\ f.\ B}
\]
where $e_1:=\idx1 e$
(all variables in $e$
indexed with~$1$),
and $e_2':=\idx2e'$ (all variables in $e'$ indexed with~$2$).

Informally, $C$
says $f$
has marginals $e$
and $e'$,
and the postcondition $B$
holds for any possible $\xx_1,\xx_2'$
in the support of $f$.
This variant is used if the variables $\xx,\xx'$
in the two programs are sampled according to potentially different
distributions, and we want to establish a specific relationship
between those variables after sampling (the relationship is encoded in
the choice of $f$).

That is, the tactic ``\texttt{rnd $\xx,\xx'$ <- $f$.}'' implements the following rule:
\begin{gather*}
  \inferrule
  {\pb\rhl{A}\bc{\bc'}{
\mathfrak{Cla}[\mathtt{map\_distr}\ \mathtt{fst}\ f = e_1 \land
\mathtt{map\_distr}\ \mathtt{snd}\ f = e_2']
\sqcap
\pb\paren{\mathtt{INF}\ (\xx_1,\xx_2')\in \mathtt{supp}\ f.\ B}
    }
  }
  {\rhl{A}{\,\bc;\xx\ \texttt{<\$}\ e\,}{\,\bc';\xx'\ \texttt{<\$}\ e'\,}{B}}
  \\
  \hskip4in
  \text{where}\
  e_1:=\idx1 e,\
  e_2':=\idx2e'
\end{gather*}
The rule is an immediate consequence of \ruleref{JointSample} and \ruleref{Seq}.


\medskip

Readers familiar with EasyCrypt may notice that their
\texttt{rnd}-tactic takes very different arguments. Namely, in
EasyCrypt, one can invoke the tactic as \texttt{rnd $F$
  $G$}
where $F$
and $G$
are isomorphisms between the distributions $e_1,e'_2$.
The EasyCrypt behavior can be recovered in our tool by invoking
\texttt{rnd $\xx,\xx'$
  <- $\mathtt{map\_distr}\ (\lambda z.\, (z, F\, z))\ e_1$}.
(Instead of the condition that $F$
is an isomorphism between the distributions, our tactic will have the
equation $\mathtt{map\_distr}\ \mathtt{snd}\ \mathtt{map\_distr}\ (\lambda z.\, (z, F\, z))\ e_1 = e_2'$
in the resulting precondition, which follows from the fact that $F$
is an isomorphism.)  Our tactic is more general though, since we can
also handle the case where the distributions are not isomorphic.  For
example, we can show the judgment
$\rhl{\mathtt{top}}{\xx\texttt{ <\$ }d;}{\xx\texttt{ <\$
  }\mathtt{map\_distr}\ (\lambda z.\ z*z)\ d;}{
  \mathfrak{Cla}[\xx_1*\xx_1 = \xx_2] }$ (see the contributed file
\texttt{rnd.qrhl}\footnote{\giturl{rnd.qrhl}, and bundled with the tool.}) which does not seem easily possible in EasyCrypt.

\tactic{rule}

When invoked as ``\texttt{\frenchspacing rule $l$}''
on an ambient subgoal, it applies the rule $l$
to the current subgoal. That is, $l$
is assumed to be the name of an Isabelle lemma of the form
$A_1\Longrightarrow\dots\Longrightarrow A_n\Longrightarrow B$,
where $B$
matches the current goal (i.e., $B\sigma$
is the current goal for some substitution $\sigma$). The current goal is then replaced by goals
$A_1\sigma$, \dots, $A_n\sigma$.

This tactic is particularly useful for delegating subproofs to
Isabelle/HOL. For example, if the current subgoal is an inequality of
predicates that the \texttt{simp}-tactic cannot solve, then the
subgoal can be copied to the accompanying Isabelle/HOL theory and
proven there as a lemma $l$
(possibly with some preconditions of the form
$\mathtt{distinct\_qvars}\ \llbracket \qq_1,\dots,\qq_n\rrbracket$
that will then become new subgoals in the tool and can be resolved
using the \texttt{simp}-tactic).

$l$ can be any specification of a lemma that Isabelle
understands. That is, we can also write, e.g., $f(3)$ for the third
part of the fact $f$, or $f[\mathtt{where}\ x=1]$ to instantiate $x$
with $1$ in $f$, etc.

\tactic{semiclassical}

The tactic \texttt{o2h} above introduces games that contain
``punctured oracles'', i.e., oracles that allow superposition queries
to a function but measure whether the input is in a given set $S$. At
some point, it is usually necessary to get rid of the punctured
oracle. Theorem 2 in \cite{ambainis19semiclassical} gives a method to do so. The
tactic \texttt{semiclassical} (invoked without any arguments) implements that theorem.
This tactic requires that games of the exact
form as in \autoref{fig:games.semiclassical.tactic} are
defined.
%
\begin{figure}[t]
  {\smaller\smaller  \lstset{language=qrhl}
\begin{lstlisting}
program queryG := {
  on IN, OUT apply (Uoracle G);
}.

program queryGS := {
  in_S <- measure IN with binary_measurement (proj_classical_set S);
  if (in_S=1) then found <- True; else skip;
  call queryG;
}.

program queryGM := {
  if (count=stop_at) then
    guess <- measure IN with computational_basis;
  else
    skip;

  call queryG;
}.

program Count(O) := {
  call O;
  count <- count + 1;
}.

program left := {
  count <- 0;
  (S,G,z) <$ distr;
  found <- False;
  { local vars; call A(Count(queryGS)); }
}.


program right := {
  count <- 0;
  stop_at <$ uniform {..<q};
  (S,G,z) <$ distr;
  { local vars; call A(Count(queryGM)); }
}.
\end{lstlisting}
  }
  \caption[Games required by semiclassical tactic.]{\label{fig:games.semiclassical.tactic}Games required by \texttt{semiclassical} tactic.
      The local variable declaration \texttt{local vars} can be omitted (but then must be omitted in all games).}
\end{figure}
%
(The names of the games, as well as the variables (IN,
OUT, G, S, H, z, in\_S, found, count, stop\_at, guess) can be
arbitrary, and the output type of $G$ must be of type class
\texttt{xor\_group}. \texttt{distr} and \texttt{q} are arbitrary
constant expressions.)  See the description of the tactic \texttt{o2h}
for programs \texttt{queryG}, \texttt{queryGS}, \texttt{Count}.  The
program \textrm{queryGM} is an oracle that first checks
whether the number of the current oracle query is \texttt{stop\_at}
before querying $G$.  If so, the input to $G$ is measured in the
computational basis and stored in \texttt{guess}.  This corresponds to
the query performed by the adversary $B$ in
Theorem 2in \cite{ambainis19semiclassical}. (Where \texttt{stop\_at} is $i$ in
$B$.)  And finally, the game \texttt{left} is like the \texttt{find}
game in tactic \texttt{o2h}.

Then the tactic \texttt{semiclassical}, invoked without any arguments,
expects a subgoal of the form:
{\lstset{language=isabelle}
\begin{lstlisting}
Pr[found : left(rho)]
        <= 4 * real q * Pr[guess∈S : right(rho)]
\end{lstlisting}}
It 
checks whether all games are as
in \autoref{fig:games.semiclassical.tactic} and whether the free
variables of $A$ contain none of \verb|G, S, H, in\_S, found, count, stop\_at, guess| (but $A$ may access \verb|IN, OUT, z, b|).
If so, the tactic produces the following new subgoals:
{\lstset{language=qrhl}%
\begin{lstlisting}
Pr[count ≤ q : left(rho)] = 1
Pr[count ≤ q : right(rho)] = 1
\end{lstlisting}}
%
Here \texttt{q} is the same expression as in the definition of
program \texttt{queryGM} and \texttt{right}.  These subgoals express
the fact that the adversary makes at most $q$ oracle queries.


\tactic{seq}

When invoked as ``\texttt{\frenchspacing seq $i$ $j$: $C$}'', the tactic applies the rule
\[
  \inferrule
  {
    \rhl{A}{s_1;\dots;s_{i}}{s'_1;\dots;s_{j}}{C}
    \\
    \rhl{C}{s_{i+1};\dots;s_n}{s'_{j+1};\dots;s_m}{B}
  }
  {\rhl{A}{s_1;\dots;s_n}{s'_1;\dots;s'_m}{B}}
\]
That is, it splits off the first $i$
statements on the left and the first $j$
statements on the right of the current qRHL subgoal, and uses the
argument $C$ as the invariant to use in the middle.

If-statements count as single statements, even if their bodies contain
multiple statements.

The rule is an immediate consequence of \ruleref{Seq}.

\tactic{simp}

When invoked as ``\texttt{simp $l_1$
  \dots{} $l_n$.}'',
it runs the Isabelle/HOL simplifier on the current goal, resulting in
one or zero subgoals.

More precisely, if the current goal is an ambient logic statement, the
simplifier is applied directly. If the current goal is a qRHL
judgment, the simplifier is applied to the precondition, the
postcondition, and all assumptions (i.e., to all $P_i$
if the current goal is $P_1\implies\dots\implies P_n\implies \rhl{A}\bc\bd B$).

If the result is a trivial statement, the subgoal is removed. (Trivial
statements are: \texttt{True}, qRHL judgments where one assumption is
\texttt{False}, and qRHL judgments where the precondition is
\texttt{bot}.)

The arguments $l_1,\dots,l_n$
refer to names of Isabelle/HOL theorems. These are passed to the
simplifier as additional simplification rules. They can either refer
to theorems shown in Isabelle/HOL (e.g., in the theories included in
Isabelle/HOL, in \texttt{QRHL.thy}, or in the accompanying theory
loaded using the \texttt{isabelle TheoryName.} command), or to lemmas
proven within the current proof script (when the goal was stated using
\texttt{\frenchspacing lemma $l_i$:
  ...}).  These arguments are optional, the most common form of
invoking the tactic is simply \texttt{simp.}


When invoked as ``\texttt{simp ! $l_1$
  \dots{} $l_n$.}'',
the tactic behaves the same but fails unless the subgoal is solved and
removed.


\tactic{skip}

Converts a qRHL subgoal $\rhl A\Skip\Skip B$
into an ambient logic subgoal.
\[
\inferrule{
  A \leq B
}{
  \rhl A \Skip \Skip B
}
\]
This rule is an immediate consequence of rules \rulerefx{Skip} and \rulerefx{Conseq}.

\tactic{squash}

When invoked as \texttt{squash left} (or \texttt{squash right}) on a
qRHL subgoal, it replaces the last two assign/sample statements $\bc_1;\bc_2$ in the
left (or right) subgoal by a single assign/sample statement $\bc'$ with the same effect.
If the last two statements are not assign/sample statements, the tactic fails.

This tactic is useful, e.g., when we want to use the \texttt{rnd}
tactic but in one program variables $\xx$ and $\yy$ are sampled in two
separate statements while on the other side they are sampled
simultaneously using a joint distribution. Then we can join the two
statements in the first program using \texttt{squash} before using
\texttt{rnd}.

We distinguish four cases.
In the following $X,Y$ are tuples of variables, $d,e$ are expressions.
And $e'\ z:=e\{z/X\}$.
\begin{compactitem}
\item $\bc_1=\sample X d$ and $\bc_2=\sample Y e$:\\
  Then $\bc'=\sample{(X,Y)}{\mathtt{bind\_distr}\ d\ (\lambda z.\ \mathtt{map\_distr}\ (\lambda y.\ (z,y))\ (e'\ z))}$.
\item $\bc_1=\assign X d$ and $\bc_2=\sample Y e$:\\
  Then $\bc'=\sample{(X,Y)}{\mathtt{bind\_distr}\ (\mathtt{point\_distr}\ d)\ (\lambda z.\ \mathtt{map\_distr}\ (\lambda y.\ (z,y))\ (e'\ z))}$.
\item $\bc_1=\sample X d$ and $\bc_2=\assign Y e$:
  Then $\bc'=\sample{(X,Y)}{\mathtt{map\_distr}\ (\lambda y.\ (y, e\ y))\ (e'\ z)}$.
\item $\bc_1=\assign X d$ and $\bc_2=\assign Y e$:
  Then $\bc'=\assign{(X,Y)}{(d, e' d)}$.
\end{compactitem}
Note that this is allowed even if $X$ and $Y$ share
variables.\footnote{This works because if $X$ and $Y$ share a variable $\xx$,
  then in $(X,Y)$, the rightmost occurrence of $\xx$ determines what is assigned to $\xx$,
  which is the intended behavior in this case.}


\tactic{swap}

When invoked as \texttt{swap left $\mathit{range}$ $n$} (or \texttt{swap
  right $\mathit{range}$ $n$}) on a qRHL subgoal, it moves the block of
lines identified by the range $r$ in the left (or right) program
towards the beginning of the program by $n$ lines. Here $r$ is either for the form ``$a$--$b$''
(meaning lines $a$ till $b$) or ``$a$'' (meaning the last $a$ lines).

The tactic can only be applied if the following condition is
satisfied: Let $\bd$ denote the program fragment to be moved (the ``second block''), and
$\bc$ the $n$ lines before $\bd$ (the ``first block'').
\begin{itemize}
\item The (free) quantum variables of $\bc$ and $\bd$ must be disjoint.
\item The written classical variables\footnote{Written classical variables
    are those on the lhs of an assign/sample/measurement statement
    that are not hidden under a \texttt{local} statement.}
  of $\bc$ must be disjoint from the classical variables of $\bd$.
\item The written classical variables of $\bd$ must be disjoint from the classical variables of $\bc$.
\end{itemize}
These conditions are checked automatically and produce no further subgoals.

\bigskip

When invoked as \texttt{swap left/right $\mathit{range}$ $n$ subprograms first: $\be_1$ -> $\be'_1$, ..., $\be_m$, ..., $\be'_m$}, an extended swapping tactic will be activated.
(Here $\be_i,\be_i'$ are programs in the syntax from \autoref{sec:tool.programs}.
In particular, to refer to an invoked program or a argument to an oracle program, write \texttt{call P;} instead of \texttt{P}. The programs can be placed in \texttt{\{...\}} if needed for syntactic clarity.)

While the basic form of the swap tactic requires variables of $\bc$ and $\bd$ to be disjoint (see the previous paragraph for the precise conditions), this requirement is relaxed here.
The subprograms $\be_i$ (that are supposed to occur inside $\bc$) are excluded from this requirement.
Furthermore, the subprograms $\be_i$ can change to become different programs $\be_i'$ during swapping.
(The latter is optional: If \texttt{-> $\be_i'$} is ommitted, $\be_i':=\be_i$ is used.)

More precisely, the tactic parses $\bc$ as $\bc=:C[\be_1,\dots,\be_m]$ where $C$ is a multi-hole context. Then the requirements are:
\begin{itemize}
\item The free quantum variables of $C$ and $\bd$ must be disjoint.
\item The written classical variables of $C$ must be disjoint from the classical variables of $\bd$.
\item The written classical variables of $\bd$ must be disjoint from the classical variables of $C$.
\item The inner variables of $C$ must be disjoint from the free variables of $\bd$.
\end{itemize}

The resulting subgoals are then:
\begin{itemize}
\item For $i=1,\dots,m$, one denotational-equivalence subgoal stating that
  $\denotc{\bd;\be_i} = \denotc{\be'_i;\bd}$.
\item The original subgoal with $\bc;\bd$ replaced by $\bd;C[\be_1',\dots,\be_m]$.
\end{itemize}

Note that the \tacticref{byqrhl} tactic can be used to prove denotational-equivalence subgoals.

\bigskip

When invoked as \texttt{swap left/right $\mathit{range}$ $n$ subprograms second: $\be_1$ -> $\be'_1$, ..., $\be_m$, ..., $\be'_m$} (i.e., with \texttt{second} instead of \texttt{first}), then the tactic behaves analogously, except that the subprograms $\be_1,\dots,\be_m$ are to be found in the second block $\bd$, not the first block $\bc$. That is, $\bd$ is parsed as $\bc=:C[\be_1,\dots,\be_m]$ and the roles of $\bc$ and $\bd$ are exchanged.

\bigskip

An example of this tactic in use is given in the example file \texttt{examples/focus.qrhl}.

\TODOQ{Reference literature with proof of extended swap tactic}

\tactic{wp} 

Removes the last statement(s) from the left or right program of a qRHL
subgoal and adapts the postcondition accordingly.

\newcommand\WP{\operatorname{wp}}%

More precisely, when invoked as ``\texttt{wp left.}'' or ``\texttt{wp right.}'', it applies the rule
\begin{equation}
  \inferrule
  {\rhl{A}{s_1;\dots;s_{n-1}}\bc{\WP_1(B,s_n)}}
  {\rhl{A}{s_1;\dots;s_{n-1};s_n}\bc{B}}
  \qquad\text{or}\qquad
  \inferrule
  {\rhl{A}\bc{s_1;\dots;s_{n-1}}{\WP_2(B,s_n)}}
  {\rhl{A}\bc{s_1;\dots;s_{n-1};s_n}{B}}
  \label{eq:wp}
\end{equation}
respectively. (If-statements count as single statements, even if their bodies contain
multiple statements.) Here the $\WP_1$ is the following recursively defined partial function:
%
%
\begin{align*}
  \WP_1(B,\ \texttt{$\xx$ <- $e$}) & := B\{e_1/\xx_1\} \\
  \WP_1(B,\ \texttt{$\xx$ <\$ $e$}) & := \mathfrak{Cla}[\mathtt{weight}\ e_1 = 1]
                                    \sqcap (\mathtt{INF}\ \xx_1\in\mathtt{supp}\ e_1.\ B) \\
  \WP_1(B,\  \texttt{on $\qq^{(1)},\dots,\qq^{(n)}$ apply $e$})
                                 & :=
                                   \mathfrak{Cla}[\mathtt{isometry}\ e_1] \sqcap \pb\paren{\bar e\,^* \cdot (B\sqcap \bar e\cdot\mathtt{top})}\\
                                 &\qquad\qquad\text{where }\bar e := e_1\text\guillemotright \llbracket\qq^{(1)}_1,\dots,\qq^{(n)}_1\rrbracket \\
  \WP_1(B,\  \texttt{$\xx$ <- measure  $\qq^{(1)},\dots,\qq^{(n)}$ with $e$})
                                 & := \mathfrak{Cla}[\mathtt{mtotal}\ e_1] \sqcap \pb\paren{\mathtt{INF}\ z.\ \pb\paren{(B\{z/\xx_1\}\sqcap \bar e)+\mathtt{ortho}\ \bar e}} \\
                                 &\qquad\qquad\text{where }\bar e := \pb\paren{(\mathtt{mproj}\ e_1\ z)\text\guillemotright \llbracket\qq^{(1)}_1,\dots,\qq^{(n)}_1\rrbracket}\cdot \mathtt{top} \\
  \WP_1(B,\  \texttt{$\qq^{(1)},\dots,\qq^{(n)}$ <q $e$})
                                 & := \mathfrak{Cla}[\mathtt{norm}\ e_1=1] \sqcap B\div e_1 \text\guillemotright \llbracket\qq^{(1)}_1,\dots,\qq^{(n)}_1\rrbracket \\
  \WP_1(B,\  \texttt{if ($e$) then $\bc$ else $\bd$})
                                 & := \pb\paren{\mathfrak{Cla}[\lnot e_1] + \WP_1(B,\bc)} \sqcap \pb\paren{\mathfrak{Cla}[e_1] + \WP_1(B,\bd)} \\
  \WP_1(B,\  s_1;\dots;s_n) & := \WP_1(\WP_1(\dots \WP_1(\WP_1(B, s_n), s_{n-1}) \dots, s_2), s_1)
\end{align*}
Here we write $e_1$
for $\idx1e$
everywhere.  Note that the function $\WP_1$
is undefined if the argument contains a \texttt{call}-statement. In
those cases, the tactic will fail.

The function $\WP_2$
is defined analogously, except that all variables and expressions get
index $2$ instead of index $1$.

\medskip

The functions $\WP_1$
and $\WP_2$
satisfy $\rhl{\WP_1(B,\bc)}\bc\Skip B$
and $\rhl{\WP_2(B,\bc)}\Skip\bc B$,
respectively. This can be seen by induction over the structure of
$\bc$,
and using the rules \rulerefx{Assign1}, \rulerefx{Sample1},
\rulerefx{QApply1},\footnote{\label{footnote:wp.qapply}%
  Note that \ruleref{QApply1} does not
  contain the term $\mathfrak{Cla}[\mathtt{isometry}\ e_1]$
  that $\WP_1(B,\texttt{on $\qq^{(1)},\dots,\qq^{(n)}$
    apply $e$})$
  contains.  The reason why $\WP_1(\dots)$
  includes this additional term is that \texttt{on
    $\qq^{(1)},\dots,\qq^{(n)}$
    apply $e$}
  actually translates to $\Qapply{\mathit{mkIso}(e)}{q_1,\dots,q_n}$
  (see \autoref{footnote:mkIso}). Applying \ruleref{QApply1} to this
  program
  gives the precondition
  \[
    \hat e\,^* \cdot (B\sqcap \hat e\cdot\mathtt{top})
    \quad\text{where}\quad
    \hat e := \mathit{mkIso}(\idx1e)\text\guillemotright \llbracket\qq^{(1)}_1,\dots,\qq^{(n)}_1\rrbracket
  \]
  which is a superset of
  \[
    \mathfrak{Cla}[\mathtt{isometry}\ e_1] \sqcap \bar e\,^* \cdot (B\sqcap \bar e\cdot\mathtt{top})
    \quad\text{where}\quad
    \bar e := e_1\text\guillemotright \llbracket\qq^{(1)}_1,\dots,\qq^{(n)}_1\rrbracket
    \text{ and }e_1:=\idx1 e.
    \]
  } \rulerefx{Measure1}, \rulerefx{QInit1},\footnote{\label{footnote:wp.qinit}%
    Note that \ruleref{QInit1} does not contain the term $\mathfrak{Cla}[\mathtt{norm}\ e_1=1]$
    that $\WP_1(B,\  \texttt{$\qq^{(1)},\dots,\qq^{(n)}$ <q $e$})$ contains.
    The reason why $\WP_1(\dots)$ includes this additional term is that
    \texttt{$\qq^{(1)},\dots,\qq^{(n)}$ <q $e$} actually translates to $\Qinit{\qq_1,\dots,\qq_n}{\mathit{mkUnit(e)}}$
    (see \autoref{footnote:mkUnit}). Applying \ruleref{QInit1} to this program gives the precondition
    \[
      B\div \hat e \text\guillemotright \llbracket\qq^{(1)}_1,\dots,\qq^{(n)}_1\rrbracket
      \quad\text{where}\quad
      \hat e := \mathit{mkUnit}(\idx1e)
    \]
    which is a superset of
    \[
      \mathfrak{Cla}[\mathtt{norm}\ e_1=1] \sqcap B\div e_1 \text\guillemotright \llbracket\qq^{(1)}_1,\dots,\qq^{(n)}_1\rrbracket
      \quad\text{where}\quad
      e_1 := \idx1e.
    \]
    }
  \rulerefx{If1},
\rulerefx{Conseq}, and \rulerefx{Seq}. From this, the rules 
in \eqref{eq:wp} follow with \ruleref{Seq}.

Note that we call this tactic \texttt{wp} like ``weakest
precondition''. However, we stress that we have not actually proven that
the precondition returned by $\WP_1$
or $\WP_2$ is indeed the \emph{weakest} precondition.
(We have merely tried to make them as weak as possible.)

\medskip

\texttt{wp left} and \texttt{wp right} apply only to the very last statement.
The following variants can be used to handle several statements in one go:
\texttt{wp left $n$} with $n\geq0$ is equivalent to $n$
invocations of \texttt{wp left}.
Analogously \texttt{wp right $n$}.
And \texttt{wp $n$ $m$} is equivalent to \texttt{wp left $n$. wp right $n$.}

\subsection{Accompanying Isabelle theories}
\label{sec:isabelle}

A proof script for our tool can load an accompanying Isabelle/HOL
theory (using the \hyperref[command:isabelle]{\texttt{isabelle} command}). In this theory,
arbitrary Isabelle/HOL developments are possible.  In particular, one
can define new types and constants for use in programs (e.g., the
encryption scheme in \autoref{sec:ex.ror}), and one can prove
arbitrary helper lemmas as long as they do not involve qRHL
judgments.
(Typically, one will prove lemmas about predicates. See also the \texttt{print goal} command, \autopageref{command:print-goal} for a simple way to generate the statements of lemmas for solving subgoals.)

It is
beyond the scope of this paper to introduce proofs in Isabelle/HOL,
see the tutorial \cite{isabelle-tutorial} and the
reference manual \cite{isar-ref} for more information. The theory
\texttt{QRHL} (imported using \texttt{imports QRHL.QRHL} in Isabelle) provides numerous definitions (most of them listed in
\autoref{sec:tool.pred}) and axioms/lemmas. Many of the lemmas are
declared as simplification rules, but some of them are for direct use
only. We do not provide a comprehensive list here. To find useful
facts, use the \texttt{find\_theorems} command \cite{isar-ref} / query panel \cite{isabelle-jedit} in Isabelle. Or try the \texttt{sledgehammer} command
\cite{isar-ref} / sledgehammer panel \cite{isabelle-jedit} for proving simple lemmas.  The following
axioms/lemmas correspond to facts proven in \cite{qrhl-paper-from-manual} (all other axioms/lemmas are
well-known or obvious facts):
\begin{center}
\begin{tabular}{|ll|}
  \hline
  \bfseries Isabelle lemma
  &
    \bfseries Lemma in \cite{qrhl-paper-from-manual}
  \\
  \hline
  \hline
  \texttt{leq\_space\_div}\,\textsuperscript{simp} & \qrhlautorefx{lemma:spacediv.leq} \\
  \hline
  \texttt{classical\_inf}\,\textsuperscript{simp} & \qrhlautorefx{lemma:cl.simps} \\
  \texttt{classical\_sup}\,\textsuperscript{simp} &\\
  \texttt{Cla\_plus}\,\textsuperscript{simp} &\\
  \texttt{BINF\_Cla}\,\textsuperscript{simp} &\\
  \texttt{classical\_ortho}\,\textsuperscript{simp} &\\
  \hline
  \texttt{qeq\_collect} & \qrhlautorefx{lemma:qeq.move} \\
  \texttt{qeq\_collect\_guarded}\,\textsuperscript{simp} & \\
  \hline
  \texttt{Qeq\_mult1} & \qrhlautorefx{lemma:qeq.inside} \\
  \texttt{Qeq\_mult2} & \\
  \hline
  \texttt{quantum\_eq\_unique}\,\textsuperscript{simp} & \qrhlautorefx{lemma:qeq.span} \\
  \hline
  \texttt{quantum\_eq\_add\_state} & \qrhlautorefx{lemma:quanteqaddstate} \\
  \hline
  \hline
  \multicolumn{2}{|c|}{\textsuperscript{simp} means: the lemma is added to the simplifier} \\
  \hline
\end{tabular}
\end{center}

The accompanying theory can also be used to set Isabelle configuration
options that then affect our tool's behavior. For example, use
\begin{lstlisting}
  declare [[show_types,show_sorts]]
\end{lstlisting}
in the accompanying theory to
add type information to the output of our tool (this affects all
Isabelle/HOL formulas printed as part of the subgoals).
Alternatively, this can be done using the \hyperref[command:isabelle_cmd]{\texttt{isabelle\_cmd}} command directly in the \texttt{.qrhl} file.

\subsubsection{Declaring types}
\label{sec:deftypes}

In an accompanying Isabelle file, it is possible to define types as
usual using Isabelle commands such as \texttt{typedef},
\texttt{datatype}, and \texttt{typedecl}. However, there is one important
caveat: To use a type as the type of a program variable, that type
needs to instantiate the type class \texttt{universe} (representing
types of sufficiently small cardinality).\footnote{For reasons described in
  \autoref{footnote:universe}.} For most builtin types, this is
already the case. However, there are two cases where one needs to be
aware of this restriction.

First, when defining one's own types (using \texttt{typedef} or
\texttt{datatype}). In that case, Isabelle will not know that the
resulting type is small. Fortunately, in most cases
(assuming the types from which the new type is built are small) this
can be done automatically with a single command:
\begin{lstlisting}
  derive universe typename
\end{lstlisting}
For example:
\begin{lstlisting}
  datatype 'a mytree = Node "'a mytree * 'a mytree" | Leaf 'a .
  derive universe mytree
\end{lstlisting}
The \texttt{derive universe} command is also useful for types imported
from other Isabelle theories if they were not yet shown to instantiate
\texttt{universe}.


The second use case is the declaration of types using
\texttt{typedecl}. Such declarations are useful to specify in a
development that \texttt{T} is just an arbitrary type, and that the
whole proof holds for any type~\texttt{T}. (E.g., one might declare a
type \texttt{key} of keys without further specifying its nature.)
However, in this case, Isabelle will not know that \texttt{T} is
small (and thus instantiates \texttt{universe}) since
nothing was specified about \texttt{T}. One solution would be to add
instantiation proofs with \texttt{sorry}. However, we have included a
custom command for declaring types that covers this situation:
\texttt{declare\_variable\_type}. In its basic form, it declares a new
type that is of class \texttt{universe}:
\begin{lstlisting}
  declare_variable_type key
\end{lstlisting}
The new type can also have type parameters:
\begin{lstlisting}
  declare_variable_type 'a t1
  declare_variable_type ('a,'b) t2
  declare_variable_type ('a::finite,'b) t3
\end{lstlisting}
where the last case constrains 'a to have the type class
\texttt{finite}.  Finally, the command also has a convenient method
for declaring that a given type has further type classes (besides \texttt{universe}) such as in:
\begin{lstlisting}
  declare_variable_type key :: finite
  declare_variable_type msg :: "{finite,xor_group}"
  declare_variable_type ('a::finite) list :: finite
\end{lstlisting}
(\texttt{universe} is always implicitly added.\footnote{More precisely,
  \texttt{declare\_variable\_type\ ('a$_1$::s$_1$,\dots,'a$_n$::s$_n$) t :: s}
  declares two facts: If \texttt{'a$_1$,\dots,'a$_n$} have sorts (type classes)
  \texttt{s$_1$,\dots,s$_n$}, then the type \texttt{('a$_1$,\dots,'a$_n$) t}
  has sort \texttt{s}. (Where \texttt{s$_i$} and \texttt{s} are empty when omitted from the command.)
  And
  if \texttt{'a$_1$,\dots,'a$_n$} have sorts
  \texttt{s$_1'$,\dots,s$_n'$}, then the type \texttt{('a$_1$,\dots,'a$_n$) t}
  has sort \texttt{s$'$}, where \texttt{s$_i'$} and \texttt{s$'$} are
  \texttt{s$_i$} and \texttt{s} with the type class \texttt{universe} added.})

The command will check whether the existence of a type of the given
sorts can be consistently assumed.  If this is not the case, a warning
is issued.\footnote{If the warning is not justified, it is possible to
  remove it by manually defining a new type (e.g., via
  \texttt{typedef} or \texttt{datatype}) and showing that that type
  has the required sort (it is a \emph{sort witness}). After that,
  \texttt{declare\_variable\_type} will not issue a warning any more
  since the existence of a type of the right sort is ensured.}  For
example,
\begin{lstlisting}
  declare_variable_type wrong :: "{finite,no_top}"
\end{lstlisting}
produces a warning since it would declare a type that is both finite
and has no upper bound, and thus lead to a contradiction.



\subsubsection{Code generation}\label{sec:codegen}
If all quantum variables involved in a
claim about predicates have finite types, the claim will often
essentially be a claim about concrete operators and subspaces of fixed
dimension. This means that by explicit computation of those operators and
subspaces, the claim can be decided. To support this, we use the
Isabelle code generation mechanism 
\cite{isabelle-codegen}. This mechanism allows us to provide explicit
algorithms for the various operations that occur in formulas. (For
example, we might provide a matrix addition algorithm for $A+B$
where $A,B::(\alpha,\beta)\ \mathtt{cblinfun}$.)
In our case, we give algorithms for most operations on bounded
operators and subspaces. (We rely heavily on \cite{Jordan_Normal_Form-AFP} which
implements various algorithms on matrices in Isabelle/HOL.) This
allows us to directly evaluate most expressions involving bounded
operators and subspaces, as long as the involved types are
finite.\footnote{Strictly speaking, besides being finite, the types need to implement the
  type class \texttt{Enum.enum} which means an explicit list of all
  elements of the type must be provided.}

Unfortunately, most expressions involving predicates that occur as
subgoals in our tool cannot be directly evaluated using this
mechanism.
This is due to operations that map operators/subspaces on individual variables to the whole (infinite-dimensional) space (i.e., \guillemotright, $\TOOLinq$, $\TOOLeqq$).
For example, we might have the claim
\begin{equation}
  \label{eq:code1}
  \pB\paren{\llbracket{\qq_1,\qq_2}\rrbracket \TOOLinq \mathtt{ccspan}\ \{\mathtt{EPR}\}}
  \leq
  \pB\paren{\llbracket{\qq_1,\qq_2}\rrbracket \TOOLinq \mathtt{ccspan}\ \{\basis{}{00},\basis{}{11}\}}
\end{equation}
Recall that $Q \TOOLinq A$ is an operation that maps a subspace $A$ of the Hilbert space corresponding to the type of variable $Q$ to the corresponding subspace on the Hilbert space of all memories states.
Thus the lhs and rhs are infinite dimensional subspaces.
Therefore, the lhs and rhs cannot be explicitly computed (at least not
using a straighforward representation). Thus, we first need to convert
the above expression into the following equivalent finite dimensional
one:
$ \mathtt{span}\ \{\mathtt{EPR}\} \leq \mathtt{span}\
\{\basis{}{00},\basis{}{11}\}.  $

In this specific case, this is a special case of the simple rule
$A\leq B\implies (Q \TOOLinq A) \leq (Q\TOOLinq B)$.
In general, however, removing the lifting operations (\guillemotright, $\TOOLinq$, $\TOOLeqq$) can be
nontrivial. These lifting operations can be interspersed with different
operations, and they may use different sets of quantum variables,
or differently ordered ones. For example, consider
\begin{equation}
  \label{eq:code2}
  \pB\paren{\llbracket{\qq_1,\qq_2}\rrbracket \TOOLinq \mathtt{ccspan}\ \{\mathtt{EPR}\}}
  \leq
  \pB\paren{\llbracket{\qq_2,\qq_1}\rrbracket \TOOLinq \mathtt{ccspan}\ \{\basis{}{00},\basis{}{11}\}}
\end{equation}
(Note the different order $\qq_2,\qq_1$ on the rhs.)
To make this into a finite dimensional expression, we
first have to rewrite
${\llbracket{\qq_2,\qq_1}\rrbracket \TOOLinq \mathtt{ccspan}\ \{\basis{}{00},\basis{}{11}\}}$ into
${\llbracket{\qq_1,\qq_2}\rrbracket \TOOLinq \pb\paren{
    \mathtt{comm\_op} \cdot\mathtt{ccspan}\ \{\basis{}{00},\basis{}{11}\}}
}$ (where $\mathtt{comm\_op}$
is an operator mapping $\basis{}{x,y}$ to $\basis{}{y,x}$), and only then
can we apply the rule
$A\leq B\implies (Q \TOOLinq A) \leq (Q\TOOLinq B)$ and get
\begin{equation}
  \label{eq:code2-rewrite}
  \mathtt{ccspan}\ \{\mathtt{EPR}\}
  \leq
  \mathtt{comm\_op} \cdot \mathtt{ccspan}\ \{\basis{}{00},\basis{}{11}\}.
\end{equation}

We have automated this process (using a number of simplification rules
and custom ML simplification procedures). To perform this conversion,
we use the following method in Isabelle:
\begin{lstlisting}
  apply (simp add: prepare_for_code)
\end{lstlisting}

By default, the Isabelle/HOL code generation implements real numbers as fractions.
Then the code generation would fail (abort) when the expression involves, e.g., square roots.
Since operators and states such as \texttt{hadamard} and \texttt{EPR} involve $\sqrt2$, we have activated instead code generation setup from \cite{Real_Impl-AFP}.
This setup allows us to compute with real numbers of the form $a+b\sqrt c$ for rational $a,b,c$.
If even larger sets of real numbers are involved in the computations, it is necessary to include a different code generation setup, e.g., algebraic numbers \cite{Algebraic_Numbers-AFP}.

To give a complete example, \eqref{eq:code2} can be shown as follows:
\begin{lstlisting}
  lemma
    assumes[simp]: "declared_qvars \ensuremath{\llbracket}q1,q2\ensuremath{\rrbracket}"
    shows "\ensuremath{\llbracket}q1,q2\ensuremath{\rrbracket} \ensuremath\TOOLeqq EPR \ensuremath{\leq} \ensuremath{\llbracket}q2,q1\ensuremath{\rrbracket} \ensuremath\TOOLinq ccspan {\ensuremath{\basis{}{(0,0)}}, \ensuremath{\basis{}{(1,1)}}}
  apply (simp add: prepare_for_code)
  by eval (* Invokes proof by code evaluation *)
\end{lstlisting}
(Here we have additionally used the shorthand notation $\TOOLeqq$ so write the lhs of \eqref{eq:code2} more compactly.)
This example, the proof of \eqref{eq:code1}, and a few other examples
can be found in \texttt{Code\_Example.thy}.\footnote{Bundled with the
  tool, and also directly available at \giturl{Code\_Example.thy}.}  (A
remark: the subgoal produced after \texttt{apply (simp ...)} in this
example is not the same as in \eqref{eq:code2-rewrite} but a somewhat
more complex one. This is because the simplification procedures do
not necessarily find the simplest way of removing the lifting operations.)

\subsection{Examples}

\newcommand\filelist[2]{\noindent\framebox{\textbf{#1 -- \texttt{#2}}}\par\lstinputlisting{#2.lst}}

\newcommand\qrhlfile[1]{\filelist{qRHL proof script}{#1.qrhl}}
\newcommand\isafile[1]{\filelist{Isabelle/HOL theory}{#1.thy}}

\subsubsection{ROR-OT-CPA encryption from PRGs}
\label{sec:ex.ror}

Our first example proof is the ROR-OT-CPA security of a simple
one-time encryption scheme.


\paragraph{The setting.} The encryption scheme is defined by
\begin{align*}
  &\mathrm{enc}:K\times M\to M,\qquad
  \mathrm{enc}(k,m) := G(k)\oplus m \\
  &\mathrm{dec}:K\times M\to M,\qquad
  \mathrm{dec}(k,c) := G(k)\oplus c
\end{align*}
where $G:K\to M$
is a pseudorandom generator, $k$
is the key, and $m$
is the message (plaintext). 

The \index{ROR-OT-CPA}ROR-OT-CPA security notion says,
informally: The adversary cannot distinguish between an encryption
of~$m$
and an encryption of a random message, even if the adversary
itself chooses~$m$. More formally:
\begin{definition}[ROR-OT-CPA advantage]\label{def:roradv}
  For a stateful adversary $A_1,A_2$, let \symbolindexmark\AdvROR
  \begin{align*}
    \AdvROR^{A_1A_2}(\eta) :=
    \Bigl\lvert
    &\Pr\bigl[b=1:
        k\sampleset K,\, m\leftarrow A_1(),\, c:=\mathrm{enc}(k,m),\, b\leftarrow A_2(c)\bigr]
    \\    -
     &\Pr\bigl[b=1:
       k\sampleset K,\, m\leftarrow A_1(),\, r\sampleset M,\, c:=\mathrm{enc}(k,r),\, b\leftarrow A_2(c)\bigr]
       \Bigr\rvert      
  \end{align*}
  where \symbolindexmark\sampleset$\sampleset$
  means uniformly random choice, and the notation
  $\Pr[e:G]$
  denotes the probability that $e$
  holds after executing the instructions in $G$,
  and $\eta$
  is a security parameter (on which $A_1,A_2,G,K,M$
  implicitly depend).

  We call $\AdvROR^{A_1A_2}$ the \emph{ROR-OT-CPA advantage}%
  \index{advantage!ROR-OT-CPA}%
  \index{ROR-OT-CPA!advantage}
  of $A_1,A_2$.
\end{definition}
With this definition, we can then, for example, define ROR-OT-CPA
security of $\mathrm{enc}$
as ``for any quantum-polynomial-time $A_1,A_2$,
$\AdvROR^{A_1A_2}$
is negligible.'' This is what is called asymptotic security. We will
instead follow the concrete security approach where we explicitly
derive bounds for $\AdvROR^{A_1A_2}$.

Analogously, we define pseudorandomness of $G:K\to M$ by defining the \emph{PRG advantage}%
\index{PRG advantage}%
\index{advantage!PRG} of $G$:
\begin{definition}[PRG advantage]\label{def:prg.adv}
  For an adversary $A$, let \symbolindexmark\AdvPRG
  \begin{equation*}
    \AdvPRG^{A}(\eta) :=
    \Bigl\lvert
    \Pr\bigl[b=1:
        s\sampleset K,\, r := G(s),\, b\leftarrow A(r)\bigr]
        -
    \Pr\bigl[b=1:
       r\sampleset M,\, b\leftarrow A(r)\bigr]
       \Bigr\rvert      .
  \end{equation*}
\end{definition}
Again, we can define pseudorandomness of $G$
by requiring that $\AdvPRG^A$
is negligible for all quantum-polynomial-time $A$,
or reason about concrete advantages.

What we want to show is the following well-known fact: ``If $G$
is pseudorandom, then $\mathrm{enc}$
is ROR-OT-CPA.'' In the concrete security setting, we can state this
more precisely:
\begin{lemma}[Concrete ROR-OT-CPA security of $\mathbf{enc}$]\label{lemma:rorcpa}
  For any $A_1,A_2$, there exists a $B$ such that:
  \begin{compactenum}[(i)]
  \item\label{item:time} $\Time(B) \leq \Time(A_1) + \Time(A_2) + O(\log \eta)$. 
  \item\label{item:adv} $\AdvROR^{A_1,A_2}(\eta) \leq \AdvPRG^B(\eta)$.
  \end{compactenum}
  Here \symbolindexmark\Time$\Time(A)$
  refers to the worst-case runtime of $A$,
  and we assume that elementary operations (e.g.,~$\oplus$)
  on $K$ and $M$ take time $O(\log\eta)$.
\end{lemma}
It is immediate that this also implies asymptotic ROR-OT-CPA security.

In our tool, we will almost show \autoref{lemma:rorcpa}. Specifically,
we will show property \eqref{item:adv}, but we will not show
\eqref{item:time} (because our tool does not have the concept of the
runtime of an algorithm). Instead, we explicitly specify $B$
and leave it to the user to check that $B$
indeed satisfies \eqref{item:time}. This is the state of the art and
is done in the same way, in, e.g., EasyCrypt and CryptHOL. Explicit reasoning about
runtime is left as future work.

In addition, we will leave the security parameter $\eta$
implicit. This means that our proof is for fixed $\eta$,
but since it holds for any $\eta$,
the case of variable $\eta$ is implied.


\paragraph{Specification in Isabelle.} The first step is to encode the
encryption scheme itself. Since this involves the definition of types
(for keys and messages) and logical constants ($\mathrm{enc}$
and~$G$),
it needs to be done in an accompanying Isabelle theory
\texttt{PrgEnc.thy}.\footnote{The full theory file is bunded with the tool,
  and also directly available at \giturl{PrgEnc.thy}.}

In this theory, we first declare the types \texttt{key} and
\texttt{msg} as abstract (i.e., unspecified) types. We want both types
to be finite, i.e., of type class \texttt{finite} (otherwise uniform
sampling of keys/messages is not well-defined), and we want that on
type \texttt{msg}, $+$
represents the XOR operation (type class \texttt{xor\_group}\footnote{This type class
  declares \texttt{msg} as an abelian additive group with the extra law $a+a=0$.}).
\begin{lstlisting}
  declare_variable_type key :: finite
  declare_variable_type msg :: "{finite,xor_group}"
\end{lstlisting}

Now we can declare the PRG $G$
and the encryption function $\mathrm{enc}$.
Since $G$
is just an unspecified function, all we need to do is to declare an
uninterpreted constant with the right type. And $\mathrm{enc}$
can be explicitly defined:
\begin{lstlisting}
  axiomatization G :: "key \ensuremath{\Rightarrow} msg"
  definition enc :: "key * msg \ensuremath{\Rightarrow} msg"
    where [simp]: "enc = (\ensuremath{\lambda}(k,x). G(k)+x)"
\end{lstlisting}

In addition, we declare an prove some simple simplification rules for XOR
that will be used in the proof (\texttt{my\_simp}, \texttt{mysimp2}, \texttt{aux\_bij}).

\paragraph{Specification in our tool.} We now proceed to the
specifications that are done in our tool directly. We show only
excerpts, the full file is
\texttt{prg-enc-rorcpa.qrhl}.\footnote{Bundled with the tool, and also
  directly available at \giturl{prg-enc-rorcpa.qrhl}.}  We first specify the games
from \autoref{def:roradv} and \autoref{def:prg.adv}. Consider the lhs
game from \autoref{def:roradv}. At first, it seems like we have a
problem here. The description of the game requires $A_1,A_2$
to be algorithms that take arguments and return values, i.e.,
procedures. But our language for programs does not support
procedures. Fortunately, there is a simple workaround. We set aside a
few global variables (\texttt{m,c,r,b}) explicitly for storing inputs
and outputs of the adversary. So, for example, $b\leftarrow A_2(c)$
can be performed by declaring $b,c$
as variables accessible to $A_2$,
and then simply calling $A_2$
without arguments in our program. The former is achieved by the
following commands:
\begin{lstlisting}
  adversary A1 vars m,cglobA,qglobA.
  adversary A2 vars c,b,cglobA,qglobA.
\end{lstlisting}
(Here \texttt{cglobA} and \texttt{qglobA} are quantum variables that
model the internal classical and quantum state of $A_1,A_2$.)
And for calling the adversary $A_2$,
we have the syntax \texttt{call A2;}. The resulting program code is
given in \autoref{fig:rorprogs}. Note that \texttt{UNIV} is the set of
all values (of a given type), so \texttt{uniform UNIV} samples
uniformly from all keys or messages, respectively.

\begin{figure}[t]\centering
  \lstset{aboveskip=0pt,belowskip=0pt,frame=single}
  \centering
  \begin{tabular}{p{.45\hsize}p{.45\hsize}}
    \textbf{Games from \autoref{def:roradv}}
    &
    \textbf{Games from \autoref{def:prg.adv}}
    \\[-5pt]
    \begin{lstlisting}
program rorcpa0 := {
  k <$ uniform UNIV;
  call A1;
  c <- enc(k,m);
  call A2;
}.

program rorcpa1 := {
  k <$ uniform UNIV;
  call A1;
  r <$ uniform UNIV;
  c <- enc(k,r);
  call A2;
}.
\end{lstlisting}
    &
      \begin{lstlisting}
program prg0 := {
  s <$ uniform UNIV;
  r <- G(s);
  call B;
}.

program prg1 := {
  r <$ uniform UNIV;
  call B;
}.
\end{lstlisting}
      %$
  \end{tabular}
  \vspace*{-5mm}
  \caption{Specification of games in \textttOLD{prg-enc-rorcpa.qrhl}.}
  \label{fig:rorprogs}
\end{figure}

While $A_1$
and $A_2$
are declared as unspecified adversaries, we need to specify $B$
explicitly. (Recall that we wanted to give an explict $B$
so that the user can verify
\autoref{lemma:rorcpa}\,\eqref{item:time}.) In our case, the adversary
$B$ is quite simple:
\begin{lstlisting}
  program B := { call A1; c <- r+m; call A2; }.
\end{lstlisting}
It is easy to see that (assuming a suitable formalization of runtime)
the overhead of $B$ is only $O(\log\eta)$.

\paragraph{The proof.} The proof proceeds by first proving two facts as lemmas:
\begin{lstlisting}
  lemma rorcpa0_prg0: Pr[b=1:rorcpa0(rho)] = Pr[b=1:prg0(rho)].
  lemma rorcpa1_prg1: Pr[b=1:rorcpa1(rho)] = Pr[b=1:prg1(rho)].
\end{lstlisting}
Here \texttt{rho} is an ambient variable of type
\texttt{program\_state}, so the lemmas hold for any initial state
\texttt{rho}. Recall that \texttt{Pr[b=1:G(rho)]} refers to the
probability that $\mathtt{b}=1$ after \texttt{G}.

The proofs of both lemmas have similar form. In both cases, we first
transform the claim into a qRHL judgment using the tactic
\texttt{byqrhl} We inline the definitions of \texttt{rorcpa0},
\texttt{prg0}, and \texttt{B} using the \texttt{inline}
tactic. Trailing assignments are removed with \texttt{wp left} or
\texttt{wp right} when they occur. Ambient subgoals
are proven using the \texttt{simp} tactic, possibly giving some of the auxiliary lemmas from
\texttt{PrgEnc.thy} as hints.
And for subgoals of the form
$\rhl\dots{\dots;\mathtt{call}\ A}{\dots;\mathtt{call}\ A}\dots$,
we use the \texttt{equal} tactic to remove the last statement. We use the
\texttt{swap} tactic to swap two statements where needed to make matching
\texttt{call}-statements occur together.  Similarly, for subgoals
$\rhl\dots{\dots;\texttt{k <\$ uniform UNIV}}{\dots;\texttt{s <\$
    uniform UNIV}}\dots$, we use the \texttt{rnd} tactic. In the proof
of lemma \texttt{rorcpa0\_prg0}, we will need $k$
and $s$
to be sampled identically, so the basic form \texttt{rnd.} of the
tactic is sufficient. In \texttt{rorcpa1\_prg1} we encounter a more
interesting case: We have the subgoal
\begin{multline*}
  \{\dots\}{\texttt{\dots; r <\$ uniform UNIV;}}
  \pmb\sim
  {\texttt{\dots; r <\$ uniform UNIV;}}
  \{\texttt{
    ℭ𝔩𝔞[G k1 + r1 = r2 + m2}
  \\
  \texttt{$\land$ b1 = b2 $\land$ cglobA1 = cglobA2]
    $\sqcap$ $\llbracket$qglobA1$\rrbracket$ $\equiv\mathfrak q$ $\llbracket$qglobA2$\rrbracket$
  }\}
\end{multline*}
At first glance, it would seem that the right thing to do is to
sample \texttt{r1} and \texttt{r2} identically by applying
\texttt{rnd.} However, if $\mathtt{r1}=\mathtt{r2}$,
then the part \texttt{G k1 + r1 = r2 + m2} of the postcondition will
not be satisfied. Instead, we want to pick \texttt{r1} and \texttt{r2}
such that their XOR is \texttt{r + G k1 + m2}. This can be achieved by the
extended form of the \texttt{rnd} tactic that provides a witness for
the joint distribution of \texttt{r1} and \texttt{r2}:
\begin{lstlisting}
  rnd r,r <- map_distr (\ensuremath{\lambda}r. (r,r + G k1 + m2)) (uniform UNIV).
\end{lstlisting}
This means \texttt{r} is picked uniformly, and \texttt{r1} is
\texttt{r}, and \texttt{r2} is \texttt{r + G k1 + m2} which makes the
postcondition true.

After having shown lemmas \texttt{rorcpa0\_prg0} and
\texttt{rorcpa1\_prg1}, we can show \autoref{lemma:rorcpa} in the
following form:
\begin{lstlisting}
  lemma final: abs (Pr[b=1:rorcpa0(rho)] - Pr[b=1:rorcpa1(rho)])
             = abs (Pr[b=1:prg0(rho)] - Pr[b=1:prg1(rho)]).
\end{lstlisting}
This fact follows immediately (using the Isabelle simplifier) from the
lemmas \texttt{rorcpa0\_prg0} and \texttt{rorcpa1\_prg1}, so we can
show it using \texttt{\frenchspacing simp ! rorcpa0\_prg0 rorcpa1\_prg1.}
 
%\isafile{PrgEnc}
%\qrhlfile{prg-enc-rorcpa}



\subsubsection{IND-OT-CPA encryption from PRGs}
\label{sec:ex.ind}

The second example is the IND-OT-CPA security of the encryption scheme
$\mathrm{enc}$
from \autoref{sec:ex.ror}.  We give this second example to show that
security proofs that contain more than one reduction step do not pose
a problem. (The ROR-OT-CPA proof from \autoref{sec:ex.ror} was a
single reduction step to the PRG security of $G$.)
We only describe the differences to the proof from
\autoref{sec:ex.ror}.

\paragraph{The setting.}
The \index{IND-OT-CPA}IND-OT-CPA security notion says,
informally: The adversary cannot distinguish between an encryption
of~$m_1$ or $m_2$, even if the adversary
chooses~$m_1$ and~$m_2$ itself. More formally:
\begin{definition}[IND-OT-CPA advantage]\label{def:indadv}
  For a stateful adversary $A_1,A_2$, let \symbolindexmark\AdvIND
  \begin{align*}
    \AdvIND^{A_1A_2}(\eta) :=
    \Bigl\lvert
    &\Pr\bigl[b=1:
        k\sampleset K,\, (m_1,m_2)\leftarrow A_1(),\, c:=\mathrm{enc}(k,m_1),\, b\leftarrow A_2(c)\bigr]
    \\    -
     &\Pr\bigl[b=1:
       k\sampleset K,\, (m_1,m_2)\leftarrow A_1(),\, c:=\mathrm{enc}(k,m_2),\, b\leftarrow A_2(c)\bigr]
       \Bigr\rvert      
  \end{align*}
  We call $\AdvIND^{A_1A_2}$ the \emph{IND-OT-CPA advantage}%
  \index{advantage!IND-OT-CPA}%
  \index{IND-OT-CPA!advantage}
  of $A_1,A_2$.
\end{definition}

What we want to show is the following well-known fact: ``If $G$
is pseudorandom, then $\mathrm{enc}$
is IND-OT-CPA.'' In the concrete security setting, we can state this
more precisely:
\begin{lemma}[Concrete IND-OT-CPA security of $\mathbf{enc}$]\label{lemma:indcpa}
  For any $A_1,A_2$, there exist $B_1,B_2$ such that:
  \begin{compactenum}[(i)]
  \item\label{item:time.ind} $\Time(B_i) \leq \Time(A_1) + \Time(A_2) + O(\log \eta)$ for $i=1,2$.
  \item\label{item:adv.ind} $\AdvIND^{A_1,A_2}(\eta) \leq \AdvPRG^{B_1}(\eta) +  \AdvPRG^{B_2}(\eta)$.
  \end{compactenum}
\end{lemma}

As before, we will not show \eqref{item:time.ind} in the tool but
instead define $B_1$
and $B_2$ explicitly, leaving the runtime analysis to the user.

\paragraph{Specification.} The specification of the encryption scheme
$\mathrm{enc}$
and the PRG $G$
is unchanged. That is, we use the same accompanying theory
\texttt{PrgEnc.thy} as in \autoref{sec:ex.ror}.

In our tool,\footnote{File \texttt{prg-enc-indcpa.qrhl}, bundled with
  the tool, and also directly available here: \giturl{prg-enc-indcpa.qrhl}.} we have
to describe the two IND-OT-CPA games from \autoref{def:indadv}
(\texttt{indcpa0} and \texttt{indcpa1} in \autoref{fig:indprogs}), as well as the
two PRG games from \autoref{def:prg.adv}. For the latter, there is a
minor issue: Since we have two reductions to the security of $G$,
we need to invoke the security of $G$
twice, once for the adversary $B_1$,
and once for the adversary $B_2$.
Since our tool does not have a module system that would allow us to
generically instantiate the same game with different adversaries
(e.g., EasyCrypt's module system allows us to specify the games with a
module parameter that is then instantiated with an adversary module),
we need to write down the games from \autoref{def:prg.adv} twice, once
for adversary $B_1$
(\texttt{prg0B1} and \texttt{prg1B1} in \autoref{fig:indprogs}) and once for
adversary $B_2$ (\texttt{prg0B1} and \texttt{prg1B1}).

\begin{figure}[t]\centering
  \lstset{aboveskip=0pt,belowskip=0pt,frame=single}
  \centering
  \begin{tabular}{p{.5\hsize}p{.4\hsize}}
    \textbf{Games from \autoref{def:indadv}}
    &
    \textbf{Games from \autoref{def:prg.adv}}
    \\[-5pt]
    \begin{lstlisting}
adversary A1 vars m1,m2,cglobA,qglobA.
adversary A2 vars c,b,cglobA,qglobA.

program indcpa0 := {
  k <$ uniform UNIV;
  call A1;
  c <- enc(k,m1);
  call A2;
}.

program indcpa1 := {
  k <$ uniform UNIV;
  call A1;
  c <- enc(k,m2);
  call A2;
}.
\end{lstlisting}
    &
      \begin{lstlisting}
program prg0B1 := {
  s <$ uniform UNIV;
  r <- G(s);
  call B1; }.

program prg1B1 := {
  r <$ uniform UNIV;
  call B1; }.

program prg0B2 := {
  s <$ uniform UNIV;
  r <- G(s);
  call B2; }.

program prg1B2 := {
  r <$ uniform UNIV;
  call B2; }.
\end{lstlisting}
      %$
  \end{tabular}
  \vspace*{-5mm}
  \caption{Specification of games in \textttOLD{prg-enc-indcpa.qrhl}.}
  \label{fig:indprogs}
\end{figure}

And, of course, we need to explicitly specify the adversaries $B_1$ and $B_2$:
\begin{lstlisting}
  program B1 := { call A1; c <- r+m1; call A2; }.
  program B2 := { call A1; c <- r+m2; call A2; }.
\end{lstlisting}
It is easy to see that they satisfy the runtime conditions in
\autoref{lemma:indcpa}\,\eqref{item:time.ind}.


\paragraph{The proof.}
We use the following sequence of games:
\begin{equation*}
  \framebox{\texttt{indcpa0}}
  \overset=\longleftrightarrow
  \framebox{\texttt{prg0B1}}
  \xleftrightarrow{\AdvPRG^{B_1}}
  \framebox{\texttt{prg1B1}}
  \overset=\longleftrightarrow
  \framebox{\texttt{prg1B2}}
  \xleftrightarrow{\AdvPRG^{B_2}}
  \framebox{\texttt{prg0B2}}
  \overset=\longleftrightarrow
  \framebox{\texttt{indcpa1}}
\end{equation*}
Here $\overset=\longleftrightarrow$
means that we show that the probability of $b=1$
is the same in the two games. And $\xleftrightarrow{\AdvPRG^{B_i}}$
means that the difference of $\Pr[b=1]$
is $\AdvPRG^{B_i}$
(we do not need to prove those arrows, since that difference between those games is  $\AdvPRG^{B_i}$ by definition).

The three $\overset=\longleftrightarrow$ are shown in the following lemmas:
\begin{lstlisting}
  lemma indcpa0_prg0B1: Pr[b=1:indcpa0(rho)] = Pr[b=1:prg0B1(rho)].
  lemma prg1B1_prg1B21: Pr[b=1:prg1B1(rho)]  = Pr[b=1:prg1B2(rho)].
  lemma indcpa1_prg0B2: Pr[b=1:indcpa1(rho)] = Pr[b=1:prg0B2(rho)].
\end{lstlisting}
The proofs of these lemmas are similar to the ones in \autoref{sec:ex.ror}.

From these three lemmas we immediately get the final result (which
encodes \autoref{lemma:indcpa}\,\eqref{item:adv.ind}):
\begin{lstlisting}
  lemma final: abs( Pr[b=1:indcpa0(rho)] - Pr[b=1:indcpa1(rho)] ) <=
               abs( Pr[b=1:prg0B1(rho)]  - Pr[b=1:prg1B1(rho)] ) +
               abs( Pr[b=1:prg0B2(rho)]  - Pr[b=1:prg1B2(rho)] ).
\end{lstlisting}
This can be proven immediately using the tactic \texttt{\frenchspacing
  simp !  indcpa0\_prg0B1 indcpa1\_prg0B2 prg1B1\_prg1B21.}

%\qrhlfile{prg-enc-indcpa}

\subsubsection{Quantum equality}
\label{sec:qeq.example}

In the file \texttt{equality.qrhl}\footnote{Bundled with the tool, and
  also available directly at \giturl{equality.qrhl}.} we give a simple
example involving reasoning about quantum equality. We show
\begin{equation}\label{eq:equality}
\rhl{\qq_1\quanteq\qq_2}{\mathtt{prog1}}{\mathtt{prog2}}{\qq_1\quanteq\qq_2}
\end{equation}
for the following programs:

{\centering
    \lstset{aboveskip=0pt,belowskip=0pt}
\begin{tabular}{p{.46\hsize}@{\hskip40pt}p{.43\hsize}}
  \begin{lstlisting}
program prog1 := {
  b <$ uniform UNIV;
  if (b=1) then on q apply hadamard;
           else skip;
}.
  \end{lstlisting}%
  &
  \begin{lstlisting}
program prog2 := {
  on q apply hadamard;
  b <$ uniform UNIV;
  on q apply (if b=1
     then hadamard else id\_cblinfun); }.
  \end{lstlisting}%
\end{tabular}
}

The first program \texttt{prog1} picks a random bit $b$
and applies the Hadamard operation $H$
to $\qq$
iff $b=1$.
The second program \texttt{prog2} additionally first applies $H$,
then picks $b$,
and then applies $H$
iff $b=1$.
Since $H^2=\id$,
in both programs $H$
is applied to $\qq$
with probability $\frac12$,
so we expect them to have the same effect on $\qq$.
This is what \eqref{eq:equality} expresses.

There are two important differences between \texttt{prog1} and
\texttt{prog2}. First, \texttt{prog2} performs an additional
application of $H$
which means that the $b=1$
case of \texttt{prog2} corresponds to the $b=0$
case in \texttt{prog1} and vice versa. And secondly, we have written
the conditional application of $H$
differently.  In \texttt{prog1}, if $b=1$,
$H$
is applied, otherwise nothing is done.  In contrast, in
\texttt{prog2}, there is always an application on $\qq$,
but the operator that is applied is computed using the expression
\texttt{if b=1 then hadamard else id\_cblinfun} which evaluates to $H$
or to the identity. In other words, in \texttt{prog1}, we use a
language-level conditional and perform an actual branching. While in
\texttt{prog2}, no branching occurs, and the conditional is encoded in
the computation of the unitary that is applied. Of course, this should
not make a difference, but we formulated the two programs differently
to demonstrate that our logic can handle both approaches gracefully.

We will formalize two proofs. The first is a bit longer, and
explicitly states the invariants and case distinctions that are
made. This makes the proof more instructive. The second proof makes is
as terse as possible, simply applying tactics to remove statements
from the end of the programs, and relying on the simplifier to remove
the final, lengthy, verification condition.

\paragraph{The ``instructive'' proof.} We start with the qRHL subgoal
\[
\rhl{\qq_1\quanteq \qq_2} {\mathtt{call\ prog1;}} {\mathtt{call\ prog2;}} {\qq_1\quanteq \qq_2}
\]
and use the tactic \texttt{inline} to inline the code of both
programs. Then we use \texttt{seq 0 1: $I_1$}
with
$I_1:=\texttt{quantum\_equality\_full id\_cblinfun
  $\llbracket$q1$\rrbracket$
  hadamard $\llbracket$q2$\rrbracket$}$
to split off the first statement of the right program. That is, we
claim that after executing the first statement of the right program
(an application of Hadamard $H$
on $\qq$),
the precondition $\qq_1\quanteq\qq_2$
is transformed into $\id\,\qq_1\quanteq H\qq_2$.
Intuitively, this is what we expect, because if originally
$\qq_1\quanteq \qq_2$,
and the new $\qq_2$
is the result of applying $H$
to $\qq_2$,
then the new $\qq_2$
should equal $\qq_1$
if we apply another $H$
to it. The resulting subgoal can be solved easily using \texttt{\frenchspacing wp
  right. skip. simp.}

We are left with the new goal
\begin{multline*}
  \{I_1\}\
  {\texttt{b <\$ uniform UNIV;
      if (b=1) then on q apply hadamard; else skip;}} \\
  \pmb\sim
  {\texttt{b <\$ uniform UNIV;
      on q apply (if b=1 then hadamard else id\_cblinfun);}}
  \
  \{\qq_1\quanteq\qq_2\}
\end{multline*}
We then claim that the sampling of $b$
on both sides leads to $b_1\neq b_2$.
That is, we use the tactic \texttt{seq 1 1: $I_2$}
with
$I_2:=\texttt{quantum\_equality\_full id\_cblinfun
  $\llbracket$q1$\rrbracket$
  hadamard $\llbracket$q2$\rrbracket$
  $\sqcap$ Cla[b1≠b2].}$ to split off the two samplings into a separate qRHL
judgement. That judgement can be solved using the \texttt{rnd}
tactic. Since we want $b_1\neq b_2$
to hold, we cannot use the simple form of \texttt{rnd}, but instead we
use \texttt{\frenchspacing rnd b,b <- map\_distr ($\lambda$b.
  (b,b+1)) (uniform UNIV)} to tell the tool to sample $b_1$
and $b_2$
so that they will always be inequal. (Note: $b+1$
is the negation of the bit $b$
since $+$
is XOR on bits.)  We use \texttt{\frenchspacing skip. simp!} to discharge the remainder of
this subgoal.

Now, we are left with the subgoal
\begin{multline}
  \{I_2\}\
  {\texttt{if (b=1) then on q apply hadamard; else skip;}} \\
  \pmb\sim
  {\texttt{on q apply (if b=1 then hadamard else id\_cblinfun);}}
  \
  \{\qq_1\quanteq\qq_2\}
  \label{eq:I2.rhl}
\end{multline}
Note that $I_2$
contains the program variables $b_1,b_2$
upon which further branching depends. To be able to make a case
distinction over their values, we need to be able to refer to their
values in the ambient logic. To this end, we apply the tactic
\texttt{case z := b1}. This adds $\CL{\texttt{b1 = z}}$
to the precondition where $z$
is an ambient variable. (That means that we can treat $z$
as a fixed value and make a case distinction over its value.)  The
case distinction itself is done via \texttt{casesplit z=0.} This will
create two new subgoals, one with the additional assumption (in the
ambient logic, not in the precondition) that $z=0$,
and one that $z\neq 0$.
The rest of the subgoal is still as in \eqref{eq:I2.rhl}.

To finish the first subgoal, we apply \texttt{\frenchspacing wp left. wp right.}
which removes the remaining statements and changes the postcondition
accordingly. Then \texttt{\frenchspacing skip. simp.} solves the subgoal. The
$z\neq0$ subgoal is solved analogously.

\paragraph{The ``terse'' proof.} As it turns out, the previous proof
is much more verbose than needed. Instead of explicitly using
\texttt{seq}, \texttt{case}, and \texttt{casesplit} to decompose the
proof into understandable subgoals, we can use the ``straightforward''
approach and simply remove statement by statement from the end of the
programs, and leave it to the simplifier to prove the resulting
statement. That is, we use \texttt{wp left. wp right} to remove
the conditional applications of $H$,
then we use \texttt{\frenchspacing rnd b,b <- map\_distr ($\lambda$b. (b,b+1)) (uniform
  UNIV)} to remove the two samplings (in a way that ensures
$b_1\neq b_2$). We
use \texttt{wp right} to remove the remaining application of $H$
in the first line of the right program, and then apply \texttt{skip.}
We get a lengthy and hardly readable verification condition, but
fortunately, it can be discharged by an application of \texttt{simp.}

Why did we need the more complex approach in the first proof? In this
simple example, we did not. However, in more complex cases, breaking
the proof down in individual cases, and simplifying intermediate
pre- and postconditions may make it easier for the simplifier (if the overall goal
is too complex to be solved in one go), and it may help the user to debug
the proof. (For example, to figure out the right witness to be used in
the \texttt{rnd b,b <- ...} tactic, it helps to have a readable pre- and
postcondition. And case distinctions help us to distinguish in which
case a problem arises and to narrow down what it is.


%\qrhlfile{equality}



\subsubsection{Quantum teleportation}

The final example is the analysis of quantum teleportation
\cite{bennett93teleport}. Quantum teleportation is a quantum protocol that allows
us to move a qubit from a quantum register $C$
to a quantum register $B$
with only classical communication between the system containing $C$
and the system containing $B$
(assuming a shared initial state).  The program \texttt{teleport} that
describes the teleportation process is shown in \autoref{fig:teleport}.
%
\begin{figure}[t]\centering
  \lstset{aboveskip=0pt,belowskip=0pt}
  \centering
  \begin{tabular}{p{.57\hsize}p{.4\hsize}}
  \begin{lstlisting}
program teleport := {
  A,B <q EPR;
  on C,A apply CNOT;
  on C apply hadamard;
  a <- measure A with computational_basis;
  c <- measure C with computational_basis;
  if (a=1) then on B apply pauliX;
           else skip;
  if (c=1) then on B apply pauliZ;
           else skip;  }.
\end{lstlisting}
    &
      \tikzset{>=stealth}
      \def\defaultWireGap{-7mm}
      \raisebox{-\height}{\begin{tikzpicture}
        \initializeCircuit;
        \newWires{C,A,B};
        \node[wireInput=C] (Cin) {$\psi$};
        \draw[decorate,decoration={mirror,brace,amplitude=3pt,raise=3pt}]
             ($(\getWireCoord{A})+(0,.7mm)$) -- node[left,xshift=-2mm] {\small\texttt{EPR}}
             ($(\getWireCoord{B})+(0,-.7mm)$);
        \stepForward{2mm};
        \labelWire[\tiny$C$]{C};
        \labelWire[\tiny$A$]{A};
        \labelWire[\tiny$B$]{B};
        \stepForward{2mm};
        {tikzset{minimum size=1mm} \node[cnot=A,control=C] (cnot) {};}
        \stepForward{4mm};
        \node[gate=C] (H) {$H$};`
        \node[gate=A] (mA) {\rlap{\small\ /}$\frown$};
        \stepForward{3mm};
        {\tikzset{quantumWire/.style={double,->}};
          \drawWire{A}; \node[right=0mm of \getWireCoord{A}] {$a$};}
        \stepForward{1mm};
        \node[gate=C] (mC) {\rlap{\small\ /}$\frown$};
        \node[gate=B] (X) {$X$};
        \node[below=0mm of X] {\tiny if $a{=}1$};
        \stepForward{3mm};
        {\tikzset{quantumWire/.style={double,->}};
          \drawWire{C}; \node[right=0mm of \getWireCoord{C}] {$c$};}
        \stepForward{1mm};
        \node[gate=B] (Z) {$Z$};
        \node[below=0mm of Z] {\tiny if $c{=}1$};
        \stepForward{2mm};
        \drawWire{B};
        \node[right=0mm of \getWireCoord{B}] {$\psi$};
      \end{tikzpicture}}
%      \raisebox{-\height}{\includegraphics[width=\hsize]{teleport.png}}
  \end{tabular}
  \vspace*{-3mm}
  \caption{Quantum teleportation as a program and as a circuit.}
  \label{fig:teleport}
\end{figure}
% 
We will
show the following fact:
\begin{equation}\label{eq:teleport.claim}
  \rhl{C_1\quanteq A_2}{\mathtt{teleport}}{\Skip}{B_1\quanteq A_2}
\end{equation}
That is, we show that if $C_1$
contains a qubit that is equal to $A_2$,
then after teleporting $C_1$
to $B_1$, $B_1$ will be equal to $A_2$ as expected.


As with the example from \autoref{sec:qeq.example}, we formalize two
proofs of \eqref{eq:teleport.claim}, an ``instructive'' one with
explictly stated intermediate invariants and case distinctions, and a
``terse'' one that simply applies \texttt{wp} as often as needed and
relies on Isabelle to decide the final verification condition.

This example serves both as an illustration that we can analyze
protocols that make use of non-trivial quantum effects (as opposed to
the examples in \autoref{sec:ex.ror} and \autoref{sec:ex.ind} which
simply maintained equality between two quantum states without ever
performing any explicit operations on it), and as a further example on
how to use the quantum equality.

\paragraph{The ``instructive'' proof.} This proof is formalized in \texttt{teleport.qrhl}.\footnote{Bundled with the tool, and also directly available at \giturl{teleport.qrhl}.}
The initial subgoal is \eqref{eq:teleport.claim}. We use the tactic
\texttt{inline teleport} to inline the definition of
\texttt{teleport}. First, we reason about the first instruction in
\texttt{teleport}, the initialization of $A,B$
with an EPR state (\texttt{A,B <q EPR}). We claim that after that
step, the invariant
$I_1:={(C_1\quanteq A_2) \sqcap (\mathtt{span}
\{\mathtt{EPR}\}\text\guillemotright\llbracket A_1,B_1\rrbracket)}$
holds. Intuitively, this is what we expect, since after initializing
$A,B$
with \texttt{EPR} on the left side, their state with will be in
$\SPAN\ \{\mathtt{EPR}\}$.
We formalize this with the tactic \texttt{seq 1 0: $I_1$},
and the resulting subgoal can be proven directly using
\texttt{\frenchspacing wp left. skip. simp.}

Then we rewrite the precondition $I_1$
into
\[
  I_2:=(\mathtt{quantum\_equality\_full}\ \mathtt{id\_cblinfun}\ ⟦C_1,A_1,B_1⟧\
  (\texttt{addState EPR})\ ⟦A_2⟧)
\] using tactic \texttt{\frenchspacing conseq pre: $I_2$.}
We get a new subgoal $I_1\leq I_2$
which can be proven using \texttt{simp quantum\_eq\_add\_state.}
(\texttt{quantum\_eq\_add\_state} is the Isabelle formulation of
\qrhlautoref{lemma:quanteqaddstate}). Intuitively, $I_2$
states that after the initialization, $C_1A_1B_1$
are in the same state as $A_2$
would be if we were to add the state $\mathtt{EPR}$ to it.


We now have the subgoal
\[
\rhl{I_2}{\bc_1}\Skip{B_1\quanteq A_2}
\]
where $\bc_1$ is \texttt{teleport} without the first line.

We now show that the next two lines (applying CNOT and Hadamard)
lead to the following invariant:
\begin{multline*}
  I_3 := \Bigl(\texttt{quantum\_equality\_full id\_cblinfun }⟦C_1,A_1,B_1⟧
    \\
  \pb\paren{(\mathtt{hadamard} ⊗ \mathtt{id\_cblinfun}) ⋅ \mathtt{assoc\_op}^* ⋅
    (\mathtt{CNOT} ⊗ \mathtt{id\_cblinfun}) ⋅ \mathtt{assoc\_op} ⋅ \mathtt{addState}\ \mathtt{EPR}}\ ⟦A_2⟧
  \Bigr)
\end{multline*}
(We use the usual mathematical symbols $\otimes$ and $\cdot$ here for readability.
In the tool, we would use $\TOOLtensoro$ and $\TOOLoCL$.)
In other words, we claim that after those two lines, the quantum
registers $C_1A_1B_1$
will contain the state that $A_2$
would contain if we added the state \texttt{EPR} to it, and then
applied CNOT on the first two and Hadamard on the first register.
What are the unexpected additional operations \texttt{assoc\_op} and
$\texttt{assoc\_op}^*$?
These are needed due to the fact that in Isabelle/HOL,
$(\alpha\times\beta)\times\gamma$
and $\alpha\times(\beta\times\gamma)$
are not the same type, although in handwritten mathematics, one
usually identifies those types. For example
$\mathtt{addState}\ \mathtt{EPR}$
is an operator from $\elltwo{\mathtt{bit}}$
to $\elltwo{\mathtt{bit}\times(\mathtt{bit}\times\mathtt{bit})}$.
And $\mathtt{CNOT}\otimes\mathtt{id\_cblinfun}$
is an operator on
$\elltwo{(\mathtt{bit}\times\mathtt{bit})\times\mathtt{bit}}$.
So we cannot multiply those operators (a type error would be raised by
Isabelle and by our tool). Instead, we need to apply
$\mathtt{assoc\_op}$
in between, which is the canonical isomorphism between
$\elltwo{\mathtt{bit}\times(\mathtt{bit}\times\mathtt{bit})}$
to $\elltwo{(\mathtt{bit}\times\mathtt{bit})\times\mathtt{bit}}$.
(If we identify $(\alpha\times\beta)\times\gamma$
and $\alpha\times(\beta\times\gamma)$,
then \texttt{assoc\_op} is the identity.) Similarly,
$\texttt{assoc\_op}^*$
is the canonical isomorphism in the opposite direction.

In the tool, claiming that the new invariant after the CNOT and the
Hadamard is $I_3$
is done via the tactic \texttt{seq 2 0: $I_3$.}
To prove the new subgoal resulting from \texttt{seq}, we apply
\texttt{\frenchspacing wp left. wp left. skip. simp.} This leaves us
with an ambient subgoal relating quantum predicates. Unfortunately,
the \texttt{simp} tactic is not able to solve this subgoal. Therefore
we outsourced this subgoal to Isabelle/HOL. Namely, we copy-and-pasted
the subgoal into the accompanying theory
\texttt{Teleport.thy},\footnote{Bundled with the tool, and also
  directly available at \giturl{Teleport.thy}.}
That is, we proved a lemma of the form
\begin{lstlisting}
  lemma teleport_goal1:
  assumes[simp]: "declared_qvars \ensuremath{\llbracket}A1,B1,C1,A2\ensuremath{\rrbracket}"
  shows "..."
\end{lstlisting}
where \texttt{...} is the copy-and-pasted subgoal. Note the assumption
\texttt{"declared\_qvars $\llbracket$A1,B1,C1,A2$\rrbracket$"}.
This one basically tells Isabelle that \texttt{A1,B1,C2,A2} can be
treated as distinct quantum variables. (Because logically, free
variables in an Isabelle lemma do not have to refer to different
entities.) With this assumption added to the simplifier
(using \texttt{[simp]}), simplification rules that reason about quantum
variables will work correctly. The lemma is proven by stating two
intermediate simple facts and then running the simplifier with a
collection of facts from the theory \texttt{QRHL}. We omit the details.  Once
we have shown \texttt{telepost\_goal1} in Isabelle, we can use it in
our tool. Namely, to prove the subgoal, we use the tactic \texttt{rule
  telepost\_goal1} in our tool. This leaves us with one new subgoal (corresponding to
the \texttt{"declared\_qvars $\llbracket$A1,B1,C1,A2$\rrbracket$"}
assumption of the lemma) which can be discharged by \texttt{simp}.

The goal is now:
\[
  \rhl{I_3}{\bc_3}\Skip{B_1\quanteq A_2}
\]
where $\bc_3$
refers to \texttt{teleport} without the first three lines.

Next we analyze the effect of the first measurement.  If the outcome
of the measurement is $a_1$,
then this means that the state of $A_1$
is projected onto $\basis{A_1}{a_1}$.
So, after the measurement, the predicate $I_4:=\texttt{proj $\basis{}{a_1}$»⟦$A_1$⟧}
  \cdot I_3$
should be satisfied. We express this using the tactic
\texttt{\frenchspacing seq 1 0: $I_4$.}
To prove the resulting subgoal, we apply the tactics \texttt{\frenchspacing
  wp left. simp. skip. simp} as usual. This leaves us with an ambient
subgoal of roughly the following form:
\[
  \forall x.\ I_3 \leq
\pb\paren{\texttt{proj $\basis{} x$»⟦$A_1$⟧}
\cdot I_3}
\sqcap 
\pb\paren{\texttt{⟦$A_1$⟧  $\TOOLeqq$  $\ket x$}}
+
\mathtt{ortho}\ (\texttt{⟦$A_1$⟧} \TOOLeqq \basis{}{x})
\]
We remove the all-quantifier using tactic \texttt{fix a'}.
Then the fact can be shown using tactic \texttt{rule move\_plus\_meas\_rule},\footnote{The lemma \texttt{move\_plus\_meas\_rule} says
  $(\texttt{Proj}\ C)\textrm\guillemotright Q ⋅ A ≤ B \implies
 A ≤ (B⊓C\textrm\guillemotright Q) + (\mathtt{ortho}\ C)\textrm\guillemotright Q$
and is useful for simplifying inequalities between predicates arising from \texttt{wp} applied to a measurement.}
followed by simplification.

We are now left with the goal
\[
  \rhl{I_4}{\bc_4}\Skip{B_1\quanteq A_2}
\]
where $\bc_4$ is \texttt{teleport} without the first four lines.


In order to be able to refer to the value of $a_1$ in the ambient logic, we apply the tactic \texttt{case a'}, this changes the subgoal into 
\[
  \rhl{\CL{a_1=a'}\sqcap I_4}{\bc_4}\Skip{B_1\quanteq A_2}
\]

We now analyze the effect of the second measurement.  If the outcome
of the measurement is $c_1$,
then this means that the state of $C_1$
is projected onto $\basis{C_1}{c_1}$.
So, after the measurement, the predicate
$I_5:=\CL{a_1=a'}\sqcap {}$\texttt{Proj
  (span \{ket $c_1$\})»⟦$C_1$⟧
  $\cdot$
  $I_4$} holds.
This step is similar to the previous one (\texttt{\frenchspacing seq
  1 0: $I_5$}
etc.), we omit the details. We again use tactic \texttt{case c'} to
be able to refer to $c_1$ in the ambient logic.
We have the following goal:
\[
  \rhl{\CL{c_1=c'}\sqcap I_5}{\bc_5}\Skip{B_1\quanteq A_2}
\]
where $\bc_5$ is \texttt{teleport} without the first five lines.

Now we will do a case distinction over the four different
possibilities for $a',c'$.
We get the first case using the tactics \texttt{\frenchspacing
  casesplit a'=0.  casesplit c'=0.}
The current subgoal now has the assumptions $a'=0$ and $c'=0$.
Using these assumptions, we can rewrite the precondition into update from here
\[
  I_6 := \CL{a_1=0 \land c_1=0} \sqcap
  \underbrace{\texttt{proj $\basis{}0$»⟦$C_1$⟧}
  \cdot
  \texttt{proj $\basis{}0$»⟦$A_1$⟧}
  \cdot I_3}_{{}=:I_7}
\]
using \texttt{conseq pre: $I_6$.}
Besides minor reordering of terms, we basically just substituted
$a':=0$
and $c':=0$
(which is justified by the assumptions), so the resulting subgoal can
be solved directly by \texttt{simp!.} The goal is then:
\[
  \rhl{I_6}{\bc_5}\Skip{B_1\quanteq A_2}
\]

Now we analyze the remaining two lines of \texttt{teleport}, namely
the conditionally applied unitaries \texttt{pauliX} and
\texttt{pauliZ}. In the case $a_1=0,c_1=0$,
they will not be applied, so after the last two lines, the predicate
$I_7$
is still satisfied. (In the other three cases, additionally
\texttt{pauliZ»⟦$B_1$⟧}
and/or \texttt{pauliX»⟦$B_1$⟧}
would be multiplied to $I_7$.)
We show this using \texttt{\frenchspacing seq 2 0: $I_7$.
  wp left. wp left. skip. simp!.}

We finally have the subgoal
\[
  \rhl{I_7}\Skip\Skip{B_1\quanteq A_2}
\]
This is transformed into $I_7\leq (B_1\quanteq A_2)$
by tactic \texttt{skip}.  What does this inequality say? It says that
if we have a state on $C_1A_1B_1$
that is equal to $A_2$
after adding \texttt{EPR} and applying CNOT and Hadamard, and then we
apply projections onto $\basis{A_1}0$
and $\basis{C_1}0$ to the state,
then that state satisfies $B_1\quanteq A_2$.
Showing this inequality is the core of the actual proof that teleportation
works. We show this inequality by explicit computation of the involved operators
and subspaces. We use the code generation mechanism of Isabelle for
this explicit computation.  That is, we copy-and-paste
the subgoal into the accompanying theory \texttt{Teleport.thy} as a lemma.
\begin{lstlisting}
  lemma teleport_goal2_a0c0:
    assumes[simp]: "declared_qvars \ensuremath{\llbracket}A1,B1,C1,A2\ensuremath{\rrbracket}"
    shows "$I_7\leq (B_1\quanteq A_2)$"
      apply (simp add: prepare_for_code) by eval
\end{lstlisting}
(See \autoref{sec:isabelle} for an explanation of
\texttt{prepare\_for\_code} and \texttt{eval}.)  With this lemma in
the accompanying theory, we can solve the goal in our tool using
\texttt{\frenchspacing rule teleport\_goal2\_a0c0.  simp!.}

The other three cases for $a',c'$ are solved analogously.



\paragraph{The ``terse'' proof.}
The proof described above shows the predicates that hold after each
step of the teleportation program. However, a much shorter (and less
explicit) proof is possible, too. This proof is given in
\texttt{teleport-terse.qrhl}.\footnote{Bundled with the tool, and also
  directly available at \giturl{teleport-terse.qrhl}.}  The definition of the
program \texttt{teleport} is the same as before (see
\autoref{fig:teleport}). To prove the goal \eqref{eq:teleport.claim},
we unfolding the definition of \texttt{teleport} using \texttt{inline
  teleport}, then apply the tactic \texttt{wp left} seven times to get
a goal of the form $\rhl{\dots}\Skip\Skip\dots$,
and the apply \texttt{skip}. We now get a lengthy inequality between
predicates as the remaining goal. While this inequality is hardly
readable (it is an 734 character string), it is amenable to fully automated computation:
the tactic \texttt{simp prepare\_for\_code} rewrites the goal into a form involving only finite-dimensional operationrs, and \texttt{isa eval} solves it by computation.
(See \autoref{sec:codegen}.)


\printbibliography

\renewcommand\symbolindexentry[4]{\noindent\hbox{\hbox to 2in{$#2$\hfill}\parbox[t]{3.5in}{#3}\hbox to 1cm{\hfill #4}}\\[2pt]}

\printsymbolindex

\printindex  


\end{document}

% Local Variables:
% mode: latex
% TeX-PDF-mode: t
% TeX-master: t
% End:
