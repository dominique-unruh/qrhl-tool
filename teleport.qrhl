isabelle auto, theory Teleport.

classical var a : bit.
classical var c : bit.

quantum var A : bit.
quantum var B : bit.
quantum var C : bit.

ambient var a' : bit.
ambient var c' : bit.

program teleport := {
  A,B <q EPR;
  on C,A apply CNOT;
  on C apply H;
  a <- measure A in computational_basis;
  c <- measure B in computational_basis;
  if (a=1) then on B apply X; else skip;
  if (c=1) then on B apply Z; else skip;
}.


qrhl {Qeq[C1=A2]} call teleport; ~ skip; {Qeq[B1=A2]}.

 inline teleport.

 seq 1 0: Qeq[C1=A2] âŠ“ (lift (span {EPR}) âŸ¦A1,B1âŸ§).
  wp left.
  skip.
  simp.
  true.

 conseq pre: quantum_equality_full idIso âŸ¦C1,A1,B1âŸ§ (addState EPR) âŸ¦A2âŸ§.
  admit.
 
 seq 2 0: quantum_equality_full idIso âŸ¦C1,A1,B1âŸ§ ((H âŠ— idIso) â‹… assoc_op' â‹… (CNOT âŠ— idIso) â‹… assoc_op â‹… addState EPR) âŸ¦A2âŸ§.
  wp left.
  wp left.
  skip.
  simp.
  admit.
# quantum_equality_full idIso âŸ¦C1, A1, B1âŸ§ (addState EPR) âŸ¦A2âŸ§ â‰¤ CNOTâ‡©@âŸ¦C1, A1âŸ§ â‹… (Hâ‡©@âŸ¦C1âŸ§ â‹… quantum_equality_full idIso âŸ¦C1, A1, B1âŸ§ (H âŠ— idIso â‹… assoc_op' â‹… CNOT âŠ— idIso â‹… assoc_op â‹… addState EPR) âŸ¦A2âŸ§)

 seq 1 0: if a1=0 then âŸ¦B1âŸ§ â‰¡ð”® âŸ¦A2âŸ§ else Xâ‡©@âŸ¦B1âŸ§ â‹… âŸ¦B1âŸ§ â‰¡ð”® âŸ¦A2âŸ§.
  wp left.
  skip.
  simp le_INF_iff.
  fix a'.
  casesplit a'=0.
   simp.

quantum_equality_full idIso âŸ¦C1, A1, B1âŸ§ (H âŠ— idIso â‹… assoc_op' â‹… CNOT âŠ— idIso â‹… assoc_op â‹… addState EPR) âŸ¦A2âŸ§
 â‰¤
(INF x. (if x = 0 then âŸ¦B1âŸ§ â‰¡ð”® âŸ¦A2âŸ§ else Xâ‡©@âŸ¦B1âŸ§ â‹… âŸ¦B1âŸ§ â‰¡ð”® âŸ¦A2âŸ§) âŠ“ span {|xâŸ©}â‡©@âŸ¦A1âŸ§ + ortho (span {|xâŸ©}â‡©@âŸ¦A1âŸ§))

 seq 2 0: if a1=0 âˆ§ c1=0 then âŸ¦B1âŸ§ â‰¡ð”® âŸ¦A2âŸ§
          else if a1=0 âˆ§ c1=1 then Zâ‡©@âŸ¦B1âŸ§ â‹… âŸ¦B1âŸ§ â‰¡ð”® âŸ¦A2âŸ§
          else if a1=1 âˆ§ c1=0 then Xâ‡©@âŸ¦B1âŸ§ â‹… âŸ¦B1âŸ§ â‰¡ð”® âŸ¦A2âŸ§
          else Xâ‡©@âŸ¦B1âŸ§ â‹… (Zâ‡©@âŸ¦B1âŸ§ â‹… âŸ¦B1âŸ§ â‰¡ð”® âŸ¦A2âŸ§).
   wp left.
   wp left.
   skip.
   simp.
  admit.
     # TODO

 wp left.
 wp left.
 case a' := a1.
 case c' := c1.
 skip.
 casesplit a'=0.
 casesplit c'=0.
  # case a'=0 c'=0
  simp.
  true.
  # case a'=0 c'=1
  simp.
  true.
 casesplit c'=0.
  # case a'=1 c'=0
  simp.
  true.
  # case a'=1 c'=1
  simp.
  true.

qed.


