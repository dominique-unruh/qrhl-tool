isabelle auto, theory Teleport.

classical var a : bit.
classical var c : bit.

quantum var A : bit.
quantum var B : bit.
quantum var C : bit.

ambient var a' : bit.
ambient var c' : bit.

program teleport := {
  A,B <q EPR;
  on C,A apply CNOT;
  on C apply H;
  a <- measure A in computational_basis;
  c <- measure B in computational_basis;
  if (a=1) then on B apply X; else skip;
  if (c=1) then on B apply Z; else skip;
}.


qrhl {Qeq[C1=A2]} call teleport; ~ skip; {Qeq[B1=A2]}.

 inline teleport.

 seq 1 0: Qeq[C1=A2] ⊓ (lift (span {EPR}) ⟦A1,B1⟧).
  wp left.
  skip.
  simp.
  true.

 conseq pre: quantum_equality_full idIso ⟦C1,A1,B1⟧ (addState EPR) ⟦A2⟧.
  admit.
 
 seq 2 0: quantum_equality_full idIso ⟦C1,A1,B1⟧ ((H ⊗ idIso) ⋅ assoc_op' ⋅ (CNOT ⊗ idIso) ⋅ assoc_op ⋅ addState EPR) ⟦A2⟧.
  wp left.
  wp left.
  skip.
  simp.
  admit.
# quantum_equality_full idIso ⟦C1, A1, B1⟧ (addState EPR) ⟦A2⟧ ≤ CNOT⇩@⟦C1, A1⟧ ⋅ (H⇩@⟦C1⟧ ⋅ quantum_equality_full idIso ⟦C1, A1, B1⟧ (H ⊗ idIso ⋅ assoc_op' ⋅ CNOT ⊗ idIso ⋅ assoc_op ⋅ addState EPR) ⟦A2⟧)

 seq 1 0: if a1=0 then ⟦B1⟧ ≡𝔮 ⟦A2⟧ else X⇩@⟦B1⟧ ⋅ ⟦B1⟧ ≡𝔮 ⟦A2⟧.
  wp left.
  skip.
  simp le_INF_iff.
  fix a'.
  casesplit a'=0.
   simp.

quantum_equality_full idIso ⟦C1, A1, B1⟧ (H ⊗ idIso ⋅ assoc_op' ⋅ CNOT ⊗ idIso ⋅ assoc_op ⋅ addState EPR) ⟦A2⟧
 ≤
(INF x. (if x = 0 then ⟦B1⟧ ≡𝔮 ⟦A2⟧ else X⇩@⟦B1⟧ ⋅ ⟦B1⟧ ≡𝔮 ⟦A2⟧) ⊓ span {|x⟩}⇩@⟦A1⟧ + ortho (span {|x⟩}⇩@⟦A1⟧))

 seq 2 0: if a1=0 ∧ c1=0 then ⟦B1⟧ ≡𝔮 ⟦A2⟧
          else if a1=0 ∧ c1=1 then Z⇩@⟦B1⟧ ⋅ ⟦B1⟧ ≡𝔮 ⟦A2⟧
          else if a1=1 ∧ c1=0 then X⇩@⟦B1⟧ ⋅ ⟦B1⟧ ≡𝔮 ⟦A2⟧
          else X⇩@⟦B1⟧ ⋅ (Z⇩@⟦B1⟧ ⋅ ⟦B1⟧ ≡𝔮 ⟦A2⟧).
   wp left.
   wp left.
   skip.
   simp.
  admit.
     # TODO

 wp left.
 wp left.
 case a' := a1.
 case c' := c1.
 skip.
 casesplit a'=0.
 casesplit c'=0.
  # case a'=0 c'=0
  simp.
  true.
  # case a'=0 c'=1
  simp.
  true.
 casesplit c'=0.
  # case a'=1 c'=0
  simp.
  true.
  # case a'=1 c'=1
  simp.
  true.

qed.


