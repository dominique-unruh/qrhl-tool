# WARNING: Unfinished experiment!

isabelle Teleport.

# TODO: support Â· in symbol conversion table

classical var a : bit.
classical var c : bit.

quantum var A : bit.
quantum var B : bit.
quantum var C : bit.

ambient var a' : bit.
ambient var c' : bit.
ambient var z : bit.
ambient var w : bit.

program teleport := {
  A,B <q EPR;
  on C,A apply CNOT;
  on C apply H;
  a <- measure A with computational_basis;
  c <- measure B with computational_basis;
  if (c=1) then on B apply Z; else skip;
  if (a=1) then on B apply X; else skip;
}.






qrhl {Qeq[C1=A2]} call teleport; ~ skip; {Qeq[B1=A2]}.

 inline teleport.

 seq 1 0: Qeq[C1=A2] âŠ“ (lift (span {EPR}) âŸ¦A1,B1âŸ§).
  wp left.
  skip.
  simp.

 conseq pre: quantum_equality_full idOp âŸ¦C1,A1,B1âŸ§ (addState EPR) âŸ¦A2âŸ§.
  rule quantum_eq_add_state.
   simp.

 seq 2 0: quantum_equality_full idOp âŸ¦C1,A1,B1âŸ§
          ((H âŠ— idOp) â‹… assoc_op* â‹… (CNOT âŠ— idOp) â‹… assoc_op â‹… addState EPR) âŸ¦A2âŸ§.
  wp left.
  wp left.
  skip.
  simp.
  # The whole subgoal proven in Isabelle
  rule teleport_goal1.
  # TODO: document "rule" tactic
   simp.

 seq 1 0: Proj (span {basis_vector a1})Â»âŸ¦A1âŸ§ â‹… 
             quantum_equality_full
                idOp âŸ¦C1,A1,B1âŸ§
                ((H âŠ— idOp) â‹… assoc_op* â‹… (CNOT âŠ— idOp) â‹… assoc_op â‹… addState EPR) âŸ¦A2âŸ§.
  wp left.
  simp.
  skip.
  simp.
  fix a'.
  rule move_plus_meas_rule.
   simp.
  simp.

case a':=a1.

#conseq pre: Cla[a1=a'] âŠ“ Proj (span {basis_vector a1})Â»âŸ¦A1âŸ§ â‹… 
#                quantum_equality_full
#                   idOp âŸ¦C1,A1,B1âŸ§
#                   ((H âŠ— idOp) â‹… assoc_op* â‹… (CNOT âŠ— idOp) â‹… assoc_op â‹… addState EPR) âŸ¦A2âŸ§.
#  simp.


seq 1 0: Cla[a1=a'] âŠ“ (Proj (span {basis_vector c1})Â»âŸ¦B1âŸ§ â‹… (Proj (span {basis_vector a1})Â»âŸ¦A1âŸ§ â‹… 
                quantum_equality_full
                   idOp âŸ¦C1,A1,B1âŸ§
                   ((H âŠ— idOp) â‹… assoc_op* â‹… (CNOT âŠ— idOp) â‹… assoc_op â‹… addState EPR) âŸ¦A2âŸ§)).
  wp left.
  simp.
  skip.
  simp.
   clear 1.
  fix c'.
  rule move_plus_meas_rule.
   simp.
  simp.

case c':=c1.

conseq pre: Cla[a1=a' âˆ§ c1=c'] âŠ“ (Proj (span {basis_vector c1})Â»âŸ¦B1âŸ§ â‹… (Proj (span {basis_vector a1})Â»âŸ¦A1âŸ§ â‹… 
                quantum_equality_full
                   idOp âŸ¦C1,A1,B1âŸ§
                   ((H âŠ— idOp) â‹… assoc_op* â‹… (CNOT âŠ— idOp) â‹… assoc_op â‹… addState EPR) âŸ¦A2âŸ§)).
  simp.

casesplit a'=0.
casesplit c'=0.

# Case a1=0 c1=0
conseq pre: Cla[a1=a' âˆ§ c1=c'] âŠ“ (Proj (span {basis_vector 0})Â»âŸ¦B1âŸ§ â‹… (Proj (span {basis_vector 0})Â»âŸ¦A1âŸ§ â‹… 
                quantum_equality_full
                   idOp âŸ¦C1,A1,B1âŸ§
                   ((H âŠ— idOp) â‹… assoc_op* â‹… (CNOT âŠ— idOp) â‹… assoc_op â‹… addState EPR) âŸ¦A2âŸ§)).
  simp.
clear 2.
clear 1.

# TODO: support Â· in symbol conversion table		
seq 2 0: Cla[a1=a' âˆ§ c1=c'] âŠ“ (Proj (span {basis_vector 0})Â»âŸ¦B1âŸ§ â‹… (Proj (span {basis_vector 0})Â»âŸ¦A1âŸ§ â‹… 
                quantum_equality_full
                   idOp âŸ¦C1,A1,B1âŸ§
                   ((H âŠ— idOp) â‹… assoc_op* â‹… (CNOT âŠ— idOp) â‹… assoc_op â‹… addState EPR) âŸ¦A2âŸ§)).
  wp left.
  wp left.
  skip.
  simp.

  


XXX


		
seq    wp left.
  wp left.
		
conseq pre: 



# TODO: support Â· in symbol conversion table		
seq 2 0: (undefined::(_,_)bounded) â‹… (Proj (span {basis_vector c1})Â»âŸ¦B1âŸ§ â‹… (Proj (span {basis_vector 0})Â»âŸ¦A1âŸ§ â‹… 
                quantum_equality_full
                   idOp âŸ¦C1,A1,B1âŸ§
                   ((H âŠ— idOp) â‹… assoc_op* â‹… (CNOT âŠ— idOp) â‹… assoc_op â‹… addState EPR) âŸ¦A2âŸ§)).
  wp left.
  wp left.
	      

	      # TODO continue
		  
		  
 seq 1 0: if a1=0 then âŸ¦B1âŸ§ â‰¡ð”® âŸ¦A2âŸ§ else XÂ»âŸ¦B1âŸ§ â‹… âŸ¦B1âŸ§ â‰¡ð”® âŸ¦A2âŸ§.
  wp left.
	 simp.
  skip.
  simp.
  fix a'.
  casesplit a'=0.
   simp.
   clear 1.
   rule teleport_goal2.
    simp.	 
   simp.
   clear 1.
   admit.
	 
 case a' := a1.
 casesplit a'=0.
 conseq pre: Cla[a1=0] âŠ“ âŸ¦B1âŸ§ â‰¡ð”® âŸ¦A2âŸ§.
  simp.
 clear 1.
# TODO: document "clear" tactic
	 
 seq 1 0: Cla[a1=0] âŠ“ (if c1=0 then âŸ¦B1âŸ§ â‰¡ð”® âŸ¦A2âŸ§ else ZÂ»âŸ¦B1âŸ§ â‹… âŸ¦B1âŸ§ â‰¡ð”® âŸ¦A2âŸ§).
  wp left.
  skip.
  simp.	 
  clear 1.
  fix c'.
  casesplit c'=0.
   simp.
   clear 1.
   admit.
   simp.
   clear 1.
   admit.

 case c' := c1.
 casesplit c'=0.       
 conseq pre: Cla[a1=0 âˆ§ c1=0] âŠ“ âŸ¦B1âŸ§ â‰¡ð”® âŸ¦A2âŸ§.
  simp.
 clear 1.
	 
 wp left.
 wp left.
 skip.
 simp.
 # a1=0, c1=0 branch finished.       

 # Continuing a1=0, c1=1
 conseq pre: Cla[a1=0 âˆ§ c1=1] âŠ“ (ZÂ»âŸ¦B1âŸ§ â‹… âŸ¦B1âŸ§ â‰¡ð”® âŸ¦A2âŸ§).
  simp.
 clear 1.
	 
 wp left.
 wp left.
 skip.
 simp.
 # a1=0, c1=1 branch finished.       
       
 # Continuing a1=1
 conseq pre: Cla[a1=1] âŠ“ (XÂ»âŸ¦B1âŸ§ â‹… âŸ¦B1âŸ§ â‰¡ð”® âŸ¦A2âŸ§).
  simp.
 clear 1.
	 
 seq 1 0: Cla[a1=1] âŠ“ (if c1=0 then XÂ»âŸ¦B1âŸ§ â‹… âŸ¦B1âŸ§ â‰¡ð”® âŸ¦A2âŸ§ else ZÂ»âŸ¦B1âŸ§ â‹… XÂ»âŸ¦B1âŸ§ â‹… âŸ¦B1âŸ§ â‰¡ð”® âŸ¦A2âŸ§).
  wp left.
  skip.
  simp.	 
  clear 1.
  fix c'.
  casesplit c'=0.
   simp.
   clear 1.
   admit.
   simp.
   clear 1.
   admit.

 case c' := c1.
 casesplit c'=0.       
 conseq pre: Cla[a1=1 âˆ§ c1=0] âŠ“ (XÂ»âŸ¦B1âŸ§ â‹… âŸ¦B1âŸ§ â‰¡ð”® âŸ¦A2âŸ§).
  simp.
 clear 1.
	 
 wp left.
 wp left.
 skip.
 simp.
 # a1=1, c1=0 branch finished.       

 # Continuing a1=1, c1=1
 conseq pre: Cla[a1=1 âˆ§ c1=1] âŠ“ (ZÂ»âŸ¦B1âŸ§ â‹… XÂ»âŸ¦B1âŸ§ â‹… âŸ¦B1âŸ§ â‰¡ð”® âŸ¦A2âŸ§).
  simp.
 clear 1.
	 
 wp left.
 wp left.
 skip.
 simp timesOp_assoc.
 # a1=1, c1=1 branch finished.       

qed.





# Brute force
qrhl {Qeq[C1=A2]} call teleport; ~ skip; {Qeq[B1=A2]}.
  inline teleport.

  seq 1 0: Qeq[C1=A2] âŠ“ (lift (span {EPR}) âŸ¦A1,B1âŸ§).
   wp left.
   skip.
   simp.

  wp left.
  simp.
  wp left.
  simp.
  wp left.
  simp.
  wp left.
  simp.
  wp left.
  simp.
  wp left.
  simp.

  skip.
  simp.
