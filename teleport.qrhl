isabelle auto, theory Teleport.

classical var a : bit.
classical var c : bit.

quantum var A : bit.
quantum var B : bit.
quantum var C : bit.

ambient var a' : bit.
ambient var c' : bit.

program teleport := {
  A,B <q EPR;
  on C,A apply CNOT;
  on C apply H;
  a <- measure A in computational_basis;
  c <- measure B in computational_basis;
  if (a=1) then on B apply X; else skip;
  if (c=1) then on B apply Z; else skip;
}.


qrhl {Qeq[C1=A2]} call teleport; ~ skip; {Qeq[B1=A2]}.

 inline teleport.

 seq 1 0: Qeq[C1=A2] ⊓ (lift (span {EPR}) ⟦A1,B1⟧).
  wp left.
  skip.
  simp.
  true.

 conseq pre: quantum_equality_full idIso ⟦C1,A1,B1⟧ (addState EPR) ⟦A2⟧.
  admit.
 
 seq 2 0: quantum_equality_full idIso ⟦C1,A1,B1⟧ ((H ⊗ idIso) ⋅ assoc_op' ⋅ (CNOT ⊗ idIso) ⋅ assoc_op ⋅ addState EPR) ⟦A2⟧.
  wp left.
  wp left.
  skip.
  simp.
  admit.
# quantum_equality_full idIso ⟦C1, A1, B1⟧ (addState EPR) ⟦A2⟧ ≤ CNOT⇩@⟦C1, A1⟧ ⋅ (H⇩@⟦C1⟧ ⋅ quantum_equality_full idIso ⟦C1, A1, B1⟧ (H ⊗ idIso ⋅ assoc_op' ⋅ CNOT ⊗ idIso ⋅ assoc_op ⋅ addState EPR) ⟦A2⟧)

 seq 2 0: Cla[if a1=0 ∧ c1=0 then True else False].
  admit.
     # TODO

 case a' := a1.
 case c' := c1.
 wp left.
 wp left.
 skip.
 casesplit a'=0.
  casesplit c'=0.
   simp.


admit.

qed.

