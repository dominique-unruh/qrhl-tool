isabelle.

quantum var q : bit.
classical var b : bit.
ambient var z : bit.
ambient var x : bit.

program prog1 := {
  b <$ uniform UNIV;
  if (b=1) then on q apply H; else skip;
}.


program prog2 := {
  on q apply H;
  b <$ uniform UNIV;
  on q apply (powerIso H b);
}.



qrhl {Qeq[q1=q2]} call prog1; ~ call prog2; {Qeq[q1=q2]}.
  inline prog1.
  inline prog2.

  seq 0 1: quantum_equality_full idIso [[q1]] H [[q2]].
    wp right.
    skip.
    simp.
    true.

  seq 1 1: quantum_equality_full idIso [[q1]] H [[q2]] ⊓ Cla[b1≠b2].
    rnd b,b <- map_distr (λb. (b,b+1)) (uniform UNIV). 
    skip.
    simp.
    true.

  case z := b1.
  wp left.
  wp right.
  simp.
  skip.
  casesplit z=0.  
    simp.
    true.
    simp.
    true.

qed.


qrhl {Qeq[q1=q2]} call prog1; ~ call prog2; {Qeq[q1=q2]}.
  inline prog1.
  inline prog2.

  wp left.
  wp right.

  rnd b,b <- map_distr (λb. (b,b+1)) (uniform UNIV).

  wp right.

  skip.
  simp.
  true.
qed.

