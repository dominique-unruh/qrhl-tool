isabelle Sparse_Search.

# We define types for random oracle input/output.
# They are finite (otherwise randomly sampling the oracle is not possible).
# The output has a XOR operation (otherwise oracle will not be well-defined).
isabelle_cmd declare_variable_type x :: "finite".  

# Query registers for querying the random oracle (x=input, y=output)
quantum var x : x.
quantum var y : bit.
# The random function itself (as a classical function h:x⇒y)
classical var h : x ⇒ bit.
# Flag whether the adversary wins
classical var win : bit.

# Initializes the random oracle
program hInit := {
  h <$ sparse_fun_distr;
}.

# hQuery models a query to the random oracle (superposition query)
program hQuery := {
  on x,y apply Uoracle h;
}.

# Defining an adversary with access to x,y.
# (I.e., the adversary may access the query registers of the random oracle.)
# The adversary takes one oracle (name hQuery), represented by "calls ?"
# The adversary's output is x'.
quantum var qglobA : infinite.
classical var cglobA : infinite.
classical var x' : x.
adversary A free cglobA, qglobA, x, y, x' calls ?.

# We want to show that the adversary finds a 0-preimage with small probability.
# The following is the game in which the adversary attempts to do so.
program find1 := {
  call hInit;
  call A(hQuery);  # Test
  win <- of_bool (h(x') = 1);
}.


# For applying the O2H tactic, the game "find_zero" needs to be rewritten into a very specific form (the game "o2h_left") below.
# To bring it into this shape, we define an auxiliary adversary.
classical var y' : bit.
program B(query) := {
  call A(query);
  x <q |x'⟩;
  y <q |0⟩;
  call query;
  y' <- measure y with computational_basis;
  win <- of_bool (y' = 1);
}.

# We also need to define an wrapper around the random oracle queries that counts queries.
# The form needs to be exactly as described here for the o2h tactic to be applicable.
# (Except for the variable names.)
classical var count : nat.
program Count(query) := {
  call query;
  count <- count + 1;
}.

# Finally, we need to define a joint distribution of (S,G,H,z) where
# - g is the random oracle used in the left game
# - h is the random oracle to use after applying the O2H theorem
# - z is any auxiliary information (in our case, we leave it empty, i.e., ())
# - S: the set (or a superset) of positions in which g≠h.

# TODO explain the choices more

# TODO needed already?
# Before we can write down the game o2h_left, we need to declare the variable g
# (a random oracle) and the query oracle for it, analogous to hQuery above.
classical var g : x ⇒ bit.
program gQuery := {
  on x,y apply Uoracle g;
}.

# We can now write down o2h_left:
classical var S : x set.
classical var z : unit.
classical var tmp : unit.
program before_o2h := {
  count <- 0;
  (S,g,h,z) <$ o2h_distr;
  { local tmp; call B(Count(hQuery)); }
}.
# (We make tmp a local variable because syntactically, we have to put a "local" statement in that place to make the o2h-tactic happy.)

# The first claim we make is: o2h_left is indistinguishable from the original game find_zero:
ambient var rho : program_state.
lemma Pr[win=1 : find1(rho)] = Pr[win=1 : before_o2h(rho)].
  byqrhl.
  inline find1.
  inline before_o2h.
  inline B.
  inline hInit.

  # Remove the "local tmp" on the right side.
  local up.

  seq <-> 2 3: ℭ𝔩𝔞[x'1 = x'2 ∧ h1 = h2].
  {
    # On the lhs, the last command sets win to "h x' = 0"
    wp 1 1.
    conseq post: ℭ𝔩𝔞[h1 x'1 = y'2].
      simp!.

    # TODO comments.
    wp right.
    conseq post: ⟦y2⟧ =⇩𝔮 |h1 x'1⟩.
      simp!.

    inline Count.
    inline hQuery.
    wp right.
    wp right.
    #conseq post: ℭ𝔩𝔞[x'1 = x'2 ∧ h1 = h2] ⊓ ⟦x2,y2⟧ =⇩𝔮 |(x'1,0)⟩.
    conseq post: ℭ𝔩𝔞[x'1 = x'2 ∧ h1 = h2] ⊓ ⟦x2⟧ =⇩𝔮 |x'1⟩ ⊓ ⟦y2⟧ =⇩𝔮 |0⟩.
    { isa auto. admit. }
    wp right.
    conseq post: ℭ𝔩𝔞[x'1 = x'2 ∧ h1 = h2] ⊓ ⟦x2⟧ =⇩𝔮 |x'1⟩.
      simp!.
    wp right.
    conseq post: ℭ𝔩𝔞[x'1 = x'2 ∧ h1 = h2].
    { isa auto. admit. }
    skip.
    simp!.
  }

  
  # The adversary call preserves the invariant h1=h2 ∧ x'1=x'2:
  equal.
  { simp!. }
  # As a subgoal we need that the oracle call made by A also preserves the invariant.
  # This is not shown automatically because the oracle is different on the two sides.
  { inline Count.
    inline hQuery.
    inline gQuery.
    wp right.
    simp.
    equal.
      simp!.
    skip.
    simp!. }
  
  # Sampling h uniformly or as the second output of o2h_distr gives the same distribution:
  rnd h, (S,g,h,z) <- map_distr (λ(S,g,h,z). (h, (S,g,h,z))) o2h_distr.
  # Cleaning up the postcondition:
  conseq post: ℭ𝔩𝔞[cglobA1 = cglobA2 ∧ x'1 = x'2] ⊓ ⟦qglobA1, x1, y1⟧ ≡𝔮 ⟦qglobA2, x2, y2⟧.
    simp! o2h_distr_def.

  wp right.
  skip.
  simp!.
qed.








program after_o2h := {
  count <- 0;
  (S,g,h,z) <$ o2h_distr;
  { local tmp; call B(Count(gQuery)); }
}.

classical var in_S : bit.
classical var found : bool.
program gQueryPunctured := {
  in_S <- measure x with binary_measurement (proj_classical_set S);
  if (in_S=1) then found <- True; else skip;
  call gQuery;
}.

program o2h_find := {
  count <- 0;
  (S,g,h,z) <$ o2h_distr;
  found <- False;
  { local tmp; call B(Count(gQueryPunctured)); }
}.

ambient var q : nat.
lemma left_right: abs ( Pr[win=1 : after_o2h(rho)] - Pr[win=1 : before_o2h(rho)] )
             <= 2 * sqrt( (1+real q) * Pr[found : o2h_find(rho)] ).
  o2h.
  admit.
  admit.
  admit.
  isa! auto simp: o2h_distr_def.
qed.


program win_p := {
  win <$ bernoulli p;
}.

lemma after_o2h_bound: Pr[win≠1 : after_o2h(rho)] = 1.
  byqrhl.
  inline after_o2h.
  local up.
  inline B.
  wp left.
  conseq post: ℭ𝔩𝔞[y'1 = 0].
    simp!.
  wp left.
  conseq post: ⟦y1⟧ =⇩𝔮 |0⟩.
    simp.
  inline Count.
  wp left.
  inline gQuery.
  wp left.
  conseq post: ℭ𝔩𝔞[g1=(λ_. 0)] ⊓ ⟦y1⟧ =⇩𝔮 |0⟩.
    { isa auto. admit. }
  wp left.
  conseq post: ℭ𝔩𝔞[g1=(λ_. 0)].
    { isa auto. admit. }
  wp left.
  conseq post: ⊤ ⊓ ℭ𝔩𝔞[g1=(λ_. 0)].
    simp!.
  
  seq <-> 2 0: ⊤ ⊓ ℭ𝔩𝔞[g1=(λ_. 0)].
  { frame.
      simp!.
    admit. # TODO (uses losslessness)
  }

  wp left.
  wp left.
  skip.
  simp! o2h_distr_def.
qed.



