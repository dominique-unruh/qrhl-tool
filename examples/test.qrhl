isabelle.

quantum var a : int.
classical var b : string.
classical var c : nat.
classical var x : bit.

adversary A
  free a, b, c
  calls ?.

### Creating the unrolled adversary for A

transform unrolled A.

# WARNING: Possibly unsound (not proven) command 'derive unrolled' invoked.
# Declared transformed adversary A_unrolled with additional variables store_A, qstore_A.
# Use "print A_unrolled.", "print store_A.", and "print qstore_A." to inspect the details.

print A_unrolled.

# adversary A_unrolled
#
# Variable use of program A_unrolled:
#  Free        âŠ† store_A, qstore_A, a, b, c
#  Ambient     âŠ† âˆ…
#  Programs    = âˆ…
#  Written     âŠ† store_A, qstore_A, a, b, c
#  Overwritten âŠ‡ âˆ…
#  Inner       âŠ† âˆ…
#  Covered     âŠ‡ all variables
#  Oracles     âŠ† âˆ…

print store_A.

# classical var store_A : bool Ã— char list Ã— nat

print qstore_A.

# quantum var qstore_A : int

### Getting the simulation lemma for a specific Q:

program Q := { x <- undefined; }.

schema A_unrolled Q.

# WARNING: Possibly unsound (not proven) command 'derive unrolled' used.
# 
# Instantiating facts about A_unrolled with oracle Q.
# 
# Use "print A_unrolled_Q." to inspect the resulting fact.

print A_unrolled_Q.

# The name A_unrolled_Q refers to 1 lemmas:
# 
# Pre:   â„­ð”©ð”ž[b1 = b2 âˆ§ c1 = c2 âˆ§ x1 = x2] âŠ“ âŸ¦a1âŸ§ â‰¡ð”® âŸ¦a2âŸ§
# 
# Left:  (1) call A(Q);
# 
# Right: (1) store_A <- default;
#        (2) qstore_A <q |defaultâŸ©;
#        (3) call A_unrolled;
#        (4) if (fst store_A â‰  []) call Q; else {};
#        (5) while (fst store_A â‰  []) { call A_unrolled; if (fst store_A â‰  []) call Q; else {}; }
# 
# Post:  â„­ð”©ð”ž[b1 = b2 âˆ§ c1 = c2 âˆ§ x1 = x2 âˆ§ store_A = default] âŠ“ âŸ¦a1âŸ§ â‰¡ð”® âŸ¦a2âŸ§ âŠ“ âŸ¦qstore_AâŸ§ =â‡©ð”® |defaultâŸ©
