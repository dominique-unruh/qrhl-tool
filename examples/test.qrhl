isabelle.


print xxx.  # Where does this come from?

print refl.  # Should be found

print HOL.refl.  # Should be found

print undefined.  # Should be found?

classical var x : int.

print x.

lemma xx: 1=1.
admit.
qed.

print xx.


quantum var Q : bit.
quantum var R : bit.
classical var b : bit.
classical var y : int.

program p1 := {
  b <- measure Q with computational_basis;
  x <- y+1;
}.

print p1.

program p2 := {
  on Q apply hadamard;
  on Q apply hadamard;
  on Q apply hadamard;
  on Q apply hadamard;
  on Q apply hadamard;
  on Q apply hadamard;
  on Q apply hadamard;
  on Q apply hadamard;
  on Q apply hadamard;
  on Q apply hadamard;
  on Q apply hadamard;
  on Q apply hadamard;
  on Q apply hadamard;
  on Q apply hadamard;
  on Q apply hadamard;
  on Q apply hadamard;
  on Q apply hadamard;
  on Q apply hadamard;
}.

qrhl {undefined} call p1; ~  call p2; {undefined}.
  inline p1.
  inline p2.

print goal.

conseq post: undefined.

print goal.

simp!.



  # Imagine "undefined" means "diagonal_basis" below.
  swap left 1 2
    subprograms first: { b <- measure Q with computational_basis; } -> { b <- measure Q with undefined; }.


print goal.

+ 
print goal.


  byqrhl qvars Q,R.

admit.

print goal.
  
