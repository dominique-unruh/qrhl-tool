isabelle.

classical var x : string.
classical var bad : bool.
quantum var q : int.
quantum var r : int.
quantum var s : int.

program p1 := {
x <- x;
bad <- bad;
on q,r,s apply undefined;
}.

lemma p1_qvars2 = undefined.
 simp.


classical var x : string.
classical var bad : bool.
quantum var q : string.

adversary adv vars q, x calls ?.

program p1 := {}.
program p2 := {}.

qrhl {top} call adv(p1); ~ call adv(p2); {Cla[bad1] + (ℭ𝔩𝔞[x1 = x2] ⊓ ⟦q1⟧ ≡𝔮 ⟦q2⟧)}.

equal.
 simp!.

simp.



classical var x : bit.
classical var y : bit.
classical var a : bit.
classical var b : bit.
classical var z : bit*bit.

program p := {
  x <- 1;
  y <$ undefined;
}.

qrhl bla: {top} call p; ~ call p; {top}.
inline p.
wp right.
simp.
wp right.
admit.
qed.

program s1(zz) := {
  (x,y) <$ uniform UNIV;
  call zz;
}.

program s3 := {
  x <$ uniform UNIV;
}.

program s2 := {
  z <$ uniform UNIV;
  call s1(s3);
}.

qrhl {top} call s1(s2); ~ call s2; {Cla[(x2,y2)=(x1,y1)]}.
inline s1.
inline s2.
inline s1.
inline s3.

rnd.
simp.
rnd.
simp.
rnd.
simp.
wp left.
simp.
skip.
simp.

qed.



# Bad error message
program s1(x) := {
  (x,y) <$ uniform UNIV;
  call x;
}.
