isabelle.

quantum var a : int.
classical var b : string.
classical var c : nat.

adversary A
  free a, b, c
  calls ?.

transform unrolled A.

# WARNING: Possibly unsound (not proven) command 'derive unrolled' invoked.
# Declared transformed adversary A_unrolled with additional variables store_A, qstore_A.
# Use "print A_unrolled.", "print store_A.", and "print qstore_A." to inspect the details.

print A_unrolled.

# adversary A_unrolled
#
# Variable use of program A_unrolled:
#  Free        ⊆ store_A, qstore_A, a, b, c
#  Ambient     ⊆ ∅
#  Programs    = ∅
#  Written     ⊆ store_A, qstore_A, a, b, c
#  Overwritten ⊇ ∅
#  Inner       ⊆ ∅
#  Covered     ⊇ all variables
#  Oracles     ⊆ ∅

print store_A.

# classical var store_A : bool × char list × nat

print qstore_A.

# quantum var qstore_A : int


# Getting the simulation lemma for a specific Q:

program Q := { on a apply undefined; }.

schema A_unrolled Q.

print A_unrolled_Q_unrolled.

# The name A_unrolled_Q_unrolled refers to 1 lemmas:
# 
# Pre:   ⊤
# 
# Left:  (1) call A(Q);
# 
# Right: (1) store_A <- default;
#        (2) qstore_A <q |default⟩;
#        (3) call A_unrolled;
#        (4) if (True) call Q; else {};
#        (5) while (True) { call A_unrolled; if (True) call Q; else {}; }
# 
# Post:  ⊤


