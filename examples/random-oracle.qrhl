isabelle RandomOracle.

# A variable that contains the random oracle
classical var h : x => y.

# Query registers for querying the random oracle (x=input, y=output)
quantum var x : x.
quantum var y : y.

# Initializes the random oracle
program hInit := {
  h <$ uniform UNIV;
}.

# hQuery models a query to the random oracle (superposition query)
program hQuery := {
  on x,y apply Uoracle h;
}.

# A classical variable for hInit' below
classical var r : x => r.

# A different way of initializing the random oracle.
# Instead of assigning h(x):=random for every x,
# we assign r(x):=random, h(x):=Ï€(r(x)).
# Here Ï€ is a fixed bijection
program hInit' := {
  r <$ uniform UNIV;
  h <- Ï€ o r;
}.

# Defining an adversary with access to x,y.
# (I.e., the adversary may access the query registers of the random oracle.)
quantum var qglobA : string.
classical var cglobA : string.
adversary A vars cglobA, qglobA, x, y.

# A game where the adversary can perform a single query to the random oracle
program p1 := {
  call hInit;
  call A;
  call hQuery;
  call A;
}.

# A game where the adversary can perform a single query to the random oracle,
# but the random oracle is initialized using hInit' now.
# (As would be the case in a history free reduction.)
program p2 := {
  call hInit';
  call A;
  call hQuery;
  call A;
}.

# p1 and p2 are indistinguishable:

qrhl {Cla[cglobA1=cglobA2] âŠ“ Qeq[qglobA1,x1,y1=qglobA2,x2,y2]} call p1; ~ call p2; {Cla[cglobA1=cglobA2] âŠ“ Qeq[qglobA1,x1,y1=qglobA2,x2,y2]}.

inline p1.
inline p2.
equal.
 simp!.
inline hQuery.
wp left.
 simp.
wp right.
 simp.
conseq post: Cla[cglobA1=cglobA2 âˆ§ h1=h2] âŠ“ Qeq[qglobA1,x1,y1=qglobA2,x2,y2].
 simp ! Uora_twice.
equal.
 simp!.
inline hInit.
inline hInit'.
wp right.
 simp.
# Postcondition is: â„­ð”©ð”ž[h1 = Ï€ âˆ˜ r2] + some equalities
rnd h,r <- map_distr (Î»r. (Ï€ o r, r)) (uniform UNIV).
 simp bij_pi.
skip.
simp!.

qed.
