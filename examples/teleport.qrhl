# Analysis of quantum teleportation.
# See the qrhl-tool manual for an explanation of this example. (Section 7.4 "Quantum teleportation", the "instructive" proof.)

isabelle Teleport.

classical var a : bit.
classical var c : bit.

quantum var A : bit.
quantum var B : bit.
quantum var C : bit.

ambient var a' : bit.
ambient var c' : bit.

# Program to teleport a qubit from C to B
program teleport := {
  A,B <q EPR;
  on C,A apply CNOT;
  on C apply hadamard;
  a <- measure A with computational_basis;
  c <- measure C with computational_basis;
  if (a=1) then on B apply pauliX; else skip;
  if (c=1) then on B apply pauliZ; else skip;
}.






qrhl {Qeq[C1=A2]} call teleport; ~ skip; {Qeq[B1=A2]}.

 inline teleport.

 seq 1 0: Qeq[C1=A2] âŠ“ âŸ¦A1,B1âŸ§ =â‡©ð”® EPR.
 { wp left.
   skip.
   simp!. }

 conseq pre: quantum_equality_full id_cblinfun âŸ¦C1,A1,B1âŸ§ (addState EPR) âŸ¦A2âŸ§.
  simp ! quantum_eq_add_state.

 seq 2 0: quantum_equality_full id_cblinfun âŸ¦C1,A1,B1âŸ§
          ((hadamard âŠ—â‡©o id_cblinfun) oâ‡©Câ‡©L assoc_op* oâ‡©Câ‡©L (CNOT âŠ—â‡©o id_cblinfun) oâ‡©Câ‡©L assoc_op oâ‡©Câ‡©L addState EPR) âŸ¦A2âŸ§.
 { wp left 2.
   skip.
   simp.
   rule teleport_goal1.
     simp!. }

 seq 1 0: proj |a1âŸ©Â»âŸ¦A1âŸ§ *â‡©S 
             quantum_equality_full
                id_cblinfun âŸ¦C1,A1,B1âŸ§
                ((hadamard âŠ—â‡©o id_cblinfun) oâ‡©Câ‡©L assoc_op* oâ‡©Câ‡©L (CNOT âŠ—â‡©o id_cblinfun) oâ‡©Câ‡©L assoc_op oâ‡©Câ‡©L addState EPR) âŸ¦A2âŸ§.
 { wp left.
   simp.
   skip.
   simp.
   fix a'.
   rule move_sup_meas_rule.
    simp!.
   simp!. }

 case a':=a1.

 seq 1 0: Cla[a1=a'] âŠ“ ((proj |c1âŸ©Â»âŸ¦C1âŸ§ oâ‡©Câ‡©L proj |a1âŸ©Â»âŸ¦A1âŸ§) *â‡©S
                 quantum_equality_full
                    id_cblinfun âŸ¦C1,A1,B1âŸ§
                    ((hadamard âŠ—â‡©o id_cblinfun) oâ‡©Câ‡©L assoc_op* oâ‡©Câ‡©L (CNOT âŠ—â‡©o id_cblinfun) oâ‡©Câ‡©L assoc_op oâ‡©Câ‡©L addState EPR) âŸ¦A2âŸ§).
 { wp left.
   simp.
   skip.
   simp.
   fix c'.
   rule move_sup_meas_rule.
    simp!.
   simp ! cblinfun_assoc_right. }

 case c':=c1.

 casesplit a'=0.
 + casesplit c'=0.

   # Case a1=0 c1=0
   - conseq pre: Cla[a1=0 âˆ§ c1=0] âŠ“ ((proj |0âŸ©Â»âŸ¦C1âŸ§ oâ‡©Câ‡©L proj |0âŸ©Â»âŸ¦A1âŸ§) *â‡©S
                   quantum_equality_full
                      id_cblinfun âŸ¦C1,A1,B1âŸ§
                      ((hadamard âŠ—â‡©o id_cblinfun) oâ‡©Câ‡©L assoc_op* oâ‡©Câ‡©L (CNOT âŠ—â‡©o id_cblinfun) oâ‡©Câ‡©L assoc_op oâ‡©Câ‡©L addState EPR) âŸ¦A2âŸ§).
       simp!.
     clear 2.
     clear 1.

     seq 2 0: (proj |0âŸ©Â»âŸ¦C1âŸ§ oâ‡©Câ‡©L proj |0âŸ©Â»âŸ¦A1âŸ§) *â‡©S
                   quantum_equality_full
                      id_cblinfun âŸ¦C1,A1,B1âŸ§
                      ((hadamard âŠ—â‡©o id_cblinfun) oâ‡©Câ‡©L assoc_op* oâ‡©Câ‡©L (CNOT âŠ—â‡©o id_cblinfun) oâ‡©Câ‡©L assoc_op oâ‡©Câ‡©L addState EPR) âŸ¦A2âŸ§.
     wp left.
     wp left.
     skip.
     simp!.

     skip.
     rule teleport_goal2_a0c0.
     simp!.



   # Case a1=0 c1=1
   - conseq pre: Cla[a1=0 âˆ§ c1=1] âŠ“ ((proj |1âŸ©Â»âŸ¦C1âŸ§ oâ‡©Câ‡©L proj |0âŸ©Â»âŸ¦A1âŸ§) *â‡©S
                   quantum_equality_full
                      id_cblinfun âŸ¦C1,A1,B1âŸ§
                      ((hadamard âŠ—â‡©o id_cblinfun) oâ‡©Câ‡©L assoc_op* oâ‡©Câ‡©L (CNOT âŠ—â‡©o id_cblinfun) oâ‡©Câ‡©L assoc_op oâ‡©Câ‡©L addState EPR) âŸ¦A2âŸ§).
       simp!.
     clear 2.
     clear 1.

     seq 2 0: (pauliZÂ»âŸ¦B1âŸ§ oâ‡©Câ‡©L proj |1âŸ©Â»âŸ¦C1âŸ§ oâ‡©Câ‡©L proj |0âŸ©Â»âŸ¦A1âŸ§) *â‡©S
                   quantum_equality_full
                      id_cblinfun âŸ¦C1,A1,B1âŸ§
                      ((hadamard âŠ—â‡©o id_cblinfun) oâ‡©Câ‡©L assoc_op* oâ‡©Câ‡©L (CNOT âŠ—â‡©o id_cblinfun) oâ‡©Câ‡©L assoc_op oâ‡©Câ‡©L addState EPR) âŸ¦A2âŸ§.
     wp left.
     wp left.
     skip.
     simp ! cblinfun_assoc_left.

     skip.
     rule teleport_goal2_a0c1.
     simp!.

 + casesplit c'=0.

   # Case a1=1 c1=0
   - conseq pre: Cla[a1=1 âˆ§ c1=0] âŠ“ ((proj |0âŸ©Â»âŸ¦C1âŸ§ oâ‡©Câ‡©L proj |1âŸ©Â»âŸ¦A1âŸ§) *â‡©S
                   quantum_equality_full
                      id_cblinfun âŸ¦C1,A1,B1âŸ§
                      ((hadamard âŠ—â‡©o id_cblinfun) oâ‡©Câ‡©L assoc_op* oâ‡©Câ‡©L (CNOT âŠ—â‡©o id_cblinfun) oâ‡©Câ‡©L assoc_op oâ‡©Câ‡©L addState EPR) âŸ¦A2âŸ§).
       simp!.
     clear 2.
     clear 1.

     seq 2 0: (pauliXÂ»âŸ¦B1âŸ§ oâ‡©Câ‡©L proj |0âŸ©Â»âŸ¦C1âŸ§ oâ‡©Câ‡©L proj |1âŸ©Â»âŸ¦A1âŸ§) *â‡©S
                   quantum_equality_full
                      id_cblinfun âŸ¦C1,A1,B1âŸ§
                      ((hadamard âŠ—â‡©o id_cblinfun) oâ‡©Câ‡©L assoc_op* oâ‡©Câ‡©L (CNOT âŠ—â‡©o id_cblinfun) oâ‡©Câ‡©L assoc_op oâ‡©Câ‡©L addState EPR) âŸ¦A2âŸ§.
     wp left.
     wp left.
     skip.
     simp ! cblinfun_assoc_left.

     skip.
     rule teleport_goal2_a1c0.
     simp!.


   # Case a1=1 c1=1
   - conseq pre: Cla[a1=1 âˆ§ c1=1] âŠ“ ((proj |1âŸ©Â»âŸ¦C1âŸ§ oâ‡©Câ‡©L proj |1âŸ©Â»âŸ¦A1âŸ§) *â‡©S
                   quantum_equality_full
                      id_cblinfun âŸ¦C1,A1,B1âŸ§
                      ((hadamard âŠ—â‡©o id_cblinfun) oâ‡©Câ‡©L assoc_op* oâ‡©Câ‡©L (CNOT âŠ—â‡©o id_cblinfun) oâ‡©Câ‡©L assoc_op oâ‡©Câ‡©L addState EPR) âŸ¦A2âŸ§).
       simp!.
     clear 2.
     clear 1.

     seq 2 0: (pauliZÂ»âŸ¦B1âŸ§ oâ‡©Câ‡©L pauliXÂ»âŸ¦B1âŸ§ oâ‡©Câ‡©L proj |1âŸ©Â»âŸ¦C1âŸ§ oâ‡©Câ‡©L proj |1âŸ©Â»âŸ¦A1âŸ§) *â‡©S
                   quantum_equality_full
                      id_cblinfun âŸ¦C1,A1,B1âŸ§
                      ((hadamard âŠ—â‡©o id_cblinfun) oâ‡©Câ‡©L assoc_op* oâ‡©Câ‡©L (CNOT âŠ—â‡©o id_cblinfun) oâ‡©Câ‡©L assoc_op oâ‡©Câ‡©L addState EPR) âŸ¦A2âŸ§.
     wp left.
     wp left.
     skip.
     simp ! cblinfun_assoc_left.

     skip.
     rule teleport_goal2_a1c1.
     simp!.

qed.		
