theory Quantum_Reg_Ranges
  imports Quantum_Registers Missing_Bounded_Operators
begin

no_notation Lattice.inf ("\<Sqinter>\<index>_" [90] 90)
unbundle register_syntax

text \<open>The following definition of a valid qregister range is supposed to roughly define
what sets are possible as the range of a qregister, as a preliminary to define the type \<open>QREGISTER\<close> below.
Precisely, this would be a type-I von Neumann algebra factor.
However, we define it as any von Neumann algebra (not necessarily type I factor).
This means, there are "valid qregister ranges" that are not actually the range of a qregister.
We do this so that \<open>QREGISTER_pair\<close> below (defined as the von Neumann algebra generated by the two ranges) can be typed as \<open>QREGISTER\<close>.
(We do not know whether the von Neumann algebra generated by the union of two type I factors is a type I factor,
but the comments in the following two MathOverflow questions indicate that it is not:
\<^url>\<open>https://mathoverflow.net/questions/442854/intersection-of-type-i-von-neumann-algebra-factors\<close>,
\<^url>\<open>https://mathoverflow.net/questions/442906/intersection-of-finitely-many-type-i-von-neumann-algebra-factors\<close>.)

(Note: we also cannot define a "valid qregister range" as a \<^term>\<open>von_neumann_factor\<close> for
the same reason, see \<^url>\<open>https://mathoverflow.net/a/445985/101775\<close>.)\<close>
definition valid_qregister_range :: \<open>'a qupdate set \<Rightarrow> bool\<close> where
  \<open>valid_qregister_range \<FF> \<longleftrightarrow> von_neumann_algebra \<FF>\<close>

lemma valid_qregister_rangeI: \<open>(\<And>a. a\<in>A \<Longrightarrow> a* \<in> A) \<Longrightarrow> commutant (commutant A) \<subseteq> A \<Longrightarrow> valid_qregister_range A\<close>
  using von_neumann_algebraI by (auto simp add: valid_qregister_range_def)

(* lemma valid_qregister_rangeI:
  assumes \<open>von_neumann_algebra A\<close>
  assumes \<open>A \<inter> commutant A \<subseteq> range (\<lambda>c. c *\<^sub>C id_cblinfun)\<close>
  shows \<open>valid_qregister_range A\<close>
  unfolding valid_qregister_range_def using assms by (rule von_neumann_algebraI) *)

(* TODO move *)
lemma register_range_double_commutant: \<open>commutant (commutant (range F)) = range F\<close> if \<open>qregister_raw F\<close>
proof -
  from complement_exists
  have \<open>let 'c::type = register_decomposition_basis F in
        commutant (commutant (range F)) = range F\<close>
  proof (rule with_type_mp)
    from that show \<open>qregister_raw F\<close>
      apply transfer by simp
    assume \<open>\<exists>G :: 'c ell2 \<Rightarrow>\<^sub>C\<^sub>L 'c ell2 \<Rightarrow> 'b ell2 \<Rightarrow>\<^sub>C\<^sub>L 'b ell2. complements F G\<close>
    then obtain G :: \<open>'c ell2 \<Rightarrow>\<^sub>C\<^sub>L 'c ell2 \<Rightarrow> 'b ell2 \<Rightarrow>\<^sub>C\<^sub>L 'b ell2\<close> 
      where \<open>complements F G\<close>
      by auto
    then have \<open>commutant (range F) = range G\<close>
      by (simp add: register_range_complement_commutant)
    moreover have \<open>commutant (range G) = range F\<close>
      by (meson \<open>complements F G\<close> complements_sym register_range_complement_commutant)
    ultimately show \<open>commutant (commutant (range F)) = range F\<close>
      by simp
  qed
  note this[cancel_with_type]
  then show ?thesis
    by -
qed

lemma valid_qregister_range: 
  fixes F :: \<open>('a,'b) qregister\<close>
  assumes \<open>qregister F\<close>
  shows \<open>valid_qregister_range (range (apply_qregister F))\<close>
proof (intro valid_qregister_rangeI von_neumann_algebraI)
  show \<open>a \<in> range (apply_qregister F) \<Longrightarrow> a* \<in> range (apply_qregister F)\<close> for a
    by (metis (mono_tags, lifting) assms image_iff qregister.rep_eq rangeI register_adj)
  show \<open>commutant (commutant (range (apply_qregister F))) \<subseteq> range (apply_qregister F)\<close>
    apply (subst register_range_double_commutant)
    using assms qregister.rep_eq by auto
(* (* Only needed if we add the condition "factor" to valid_qregister_range *)  
show \<open>range (apply_qregister F) \<inter> commutant (range (apply_qregister F))
        \<subseteq> range (\<lambda>c. c *\<^sub>C id_cblinfun)\<close>
  proof (rule subsetI)
    fix x
    assume asm: \<open>x \<in> range (apply_qregister F) \<inter> commutant (range (apply_qregister F))\<close>
    then obtain y where x_def: \<open>x = apply_qregister F y\<close>
      by blast
    with asm have \<open>apply_qregister F y o\<^sub>C\<^sub>L apply_qregister F z = apply_qregister F z o\<^sub>C\<^sub>L apply_qregister F y\<close>
      for z
      by (simp add: commutant_def)
    then have \<open>y o\<^sub>C\<^sub>L z = z o\<^sub>C\<^sub>L y\<close> for z
      apply (simp add: assms flip: qregister_compose)
      using assms inj_qregister range_ex1_eq by fastforce
    then have \<open>y \<in> range (\<lambda>c. c *\<^sub>C id_cblinfun)\<close>
      using commutant_UNIV by (auto simp: commutant_def)
    then show \<open>x \<in> range (\<lambda>c. c *\<^sub>C id_cblinfun)\<close>
      using assms 
      by (auto simp add: x_def apply_qregister_scaleC apply_qregister_of_id)
  qed *)
qed



lemma valid_one_algebra: \<open>valid_qregister_range one_algebra\<close>
proof -
  have 1: \<open>(one_algebra :: 'a qupdate set) = (\<lambda>c. c *\<^sub>C id_cblinfun) ` (one_dim_iso :: unit qupdate \<Rightarrow> _) ` UNIV\<close>
    by (metis (mono_tags, lifting) UNIV_eq_I one_algebra_def one_dim_iso_idem one_dim_scaleC_1 rangeI)
  have 2: \<open>\<dots> = range (apply_qregister (empty_qregister :: (unit,_) qregister))\<close>
    by (simp add: empty_qregister.rep_eq empty_var_def image_image)
  show ?thesis
    apply (simp only: 1 2)
    using empty_qregister_is_register valid_qregister_range by blast
qed


lemma valid_qregister_range_UNIV: \<open>valid_qregister_range UNIV\<close>
  by (auto simp: valid_qregister_range_def von_neumann_algebra_UNIV)

lemma closed_map_sot_register:
  assumes \<open>qregister F\<close>
  shows \<open>closed_map cstrong_operator_topology cstrong_operator_topology (apply_qregister F)\<close>
proof -
  have \<open>qregister_raw (apply_qregister F)\<close>
    using assms qregister.rep_eq by blast
  from register_decomposition[OF this]
  have \<open>let 'c::type = qregister_decomposition_basis F in ?thesis\<close>
  proof (rule with_type_mp)
    assume \<open>\<exists>U :: ('a \<times> 'c) ell2 \<Rightarrow>\<^sub>C\<^sub>L 'b ell2. unitary U \<and> (\<forall>\<theta>. apply_qregister F \<theta> = sandwich U *\<^sub>V \<theta> \<otimes>\<^sub>o id_cblinfun)\<close>
    then obtain U :: \<open>('a \<times> 'c) ell2 \<Rightarrow>\<^sub>C\<^sub>L 'b ell2\<close> where
      \<open>unitary U\<close> and FU: \<open>apply_qregister F \<theta> = sandwich U *\<^sub>V \<theta> \<otimes>\<^sub>o id_cblinfun\<close> for \<theta>
      by metis
    have \<open>closed_map cstrong_operator_topology cstrong_operator_topology (sandwich U o (\<lambda>a. a \<otimes>\<^sub>o id_cblinfun))\<close>
      apply (rule closed_map_compose)
       apply (rule closed_map_sot_tensor_op_id_right)
      using \<open>unitary U\<close> by (rule closed_map_sot_unitary_sandwich)
    then show \<open>closed_map cstrong_operator_topology cstrong_operator_topology (apply_qregister F)\<close>
      by (simp add: FU[abs_def] o_def)
  qed
  from this[cancel_with_type]
  show ?thesis
    by -
qed

typedef 'a QREGISTER = \<open>Collect valid_qregister_range :: 'a qupdate set set\<close>
  using valid_one_algebra by blast
setup_lifting type_definition_QREGISTER

lift_definition QREGISTER_of :: \<open>('a,'b) qregister \<Rightarrow> 'b QREGISTER\<close> is
  \<open>\<lambda>F::('a,'b) qregister. if qregister F then range (apply_qregister F) :: 'b qupdate set else one_algebra\<close>
  by (simp add: valid_one_algebra valid_qregister_range)

instantiation QREGISTER :: (type) order begin
lift_definition less_eq_QREGISTER :: \<open>'a QREGISTER \<Rightarrow> 'a QREGISTER \<Rightarrow> bool\<close> is \<open>(\<subseteq>)\<close>.
lift_definition less_QREGISTER :: \<open>'a QREGISTER \<Rightarrow> 'a QREGISTER \<Rightarrow> bool\<close> is \<open>(\<subset>)\<close>.
instance
  apply (intro_classes; transfer)
  by auto
end

instantiation QREGISTER :: (type) bot begin
lift_definition bot_QREGISTER :: \<open>'a QREGISTER\<close> is one_algebra
  by (simp add: valid_one_algebra)
instance..
end

(* LEGACY *)
abbreviation (input) QREGISTER_unit :: \<open>'a QREGISTER\<close> where \<open>QREGISTER_unit \<equiv> bot\<close>

instantiation QREGISTER :: (type) top begin
lift_definition top_QREGISTER :: \<open>'a QREGISTER\<close> is UNIV
  by (simp add: valid_qregister_range_UNIV)
instance..
end

(* LEGACY *)
abbreviation (input) QREGISTER_all :: \<open>'a QREGISTER\<close> where \<open>QREGISTER_all \<equiv> top\<close>

lemma QREGISTER_of_qregister_id: \<open>QREGISTER_of qregister_id = QREGISTER_all\<close>
  apply (rule Rep_QREGISTER_inject[THEN iffD1])
  by (simp add: QREGISTER_of.rep_eq top_QREGISTER.rep_eq)

lemma QREGISTER_of_empty_qregister[simp]: \<open>QREGISTER_of (empty_qregister :: ('a::{CARD_1,enum},'b) qregister) = QREGISTER_unit\<close>
proof (rule Rep_QREGISTER_inject[THEN iffD1])
  let ?empty = \<open>empty_qregister :: ('a::{CARD_1,enum},'b) qregister\<close>
  have \<open>Rep_QREGISTER (QREGISTER_of ?empty) 
        = (\<lambda>x. x *\<^sub>C id_cblinfun) ` range (one_dim_iso :: 'a qupdate \<Rightarrow> _)\<close>
    by (simp add: QREGISTER_of.rep_eq Quantum_Extra2.empty_var_def image_image empty_qregister.rep_eq)
  also have \<open>\<dots> = (\<lambda>x. x *\<^sub>C id_cblinfun) ` UNIV\<close>
    apply (rule arg_cong[where y=UNIV])
    by (metis one_dim_iso_idem one_dim_iso_inj surjI)
  also have \<open>\<dots> = Rep_QREGISTER QREGISTER_unit\<close>    
    by (simp add: bot_QREGISTER.rep_eq one_algebra_def)
  finally show \<open>Rep_QREGISTER (QREGISTER_of ?empty) = Rep_QREGISTER QREGISTER_unit\<close>
    by -
qed

lemma QREGISTER_unit_smallest[simp]: \<open>(QREGISTER_unit :: 'a QREGISTER) \<le> X\<close>
proof (unfold less_eq_QREGISTER.rep_eq)
  have \<open>Rep_QREGISTER (QREGISTER_unit :: 'a QREGISTER) = one_algebra\<close>
    by (simp add: bot_QREGISTER.rep_eq one_algebra_def)
  also have \<open>\<dots> \<subseteq> commutant (commutant (Rep_QREGISTER X))\<close>
    apply (subst commutant_def) by (auto simp: one_algebra_def)
  also have \<open>\<dots> = Rep_QREGISTER X\<close>
    using Rep_QREGISTER
    by (auto simp: valid_qregister_range_def von_neumann_factor_def von_neumann_algebra_def)
  finally show \<open>Rep_QREGISTER (QREGISTER_unit :: 'a QREGISTER) \<subseteq> Rep_QREGISTER X\<close>
    by -
qed

instantiation QREGISTER :: (type) sup begin
lift_definition sup_QREGISTER :: \<open>'a QREGISTER \<Rightarrow> 'a QREGISTER \<Rightarrow> 'a QREGISTER\<close> is
  \<open>\<lambda>\<FF> \<GG> :: 'a qupdate set. commutant (commutant (\<FF> \<union> \<GG>))\<close>
proof -
  fix \<FF> \<GG> :: \<open>'a qupdate set\<close>
  assume \<open>\<FF> \<in> Collect valid_qregister_range\<close>
  then have [simp]: \<open>adj ` \<FF> = \<FF>\<close>
    apply (auto simp: valid_qregister_range_def von_neumann_factor_def von_neumann_algebra_def)
    by force
  assume \<open>\<GG> \<in> Collect valid_qregister_range\<close>
  then have [simp]: \<open>adj ` \<GG> = \<GG>\<close>
    apply (auto simp: valid_qregister_range_def von_neumann_factor_def von_neumann_algebra_def)
    by force
  have \<open>adj ` commutant (commutant (\<FF> \<union> \<GG>)) = commutant (commutant (\<FF> \<union> \<GG>))\<close>
    by (simp add: commutant_adj image_Un)
  then show \<open>commutant (commutant (\<FF> \<union> \<GG>)) \<in> Collect valid_qregister_range\<close>
    by (auto intro!: valid_qregister_rangeI)
qed
instance..
end

instantiation QREGISTER :: (type) inf begin
lift_definition inf_QREGISTER :: \<open>'a QREGISTER \<Rightarrow> 'a QREGISTER \<Rightarrow> 'a QREGISTER\<close> is Set.inter
  apply simp
  by (smt (verit, best) double_commutant_in_vn_algI inf_le1 inf_le2 le_inf_iff mem_simps(4) valid_qregister_rangeI valid_qregister_range_def von_neumann_algebra_def)
instance..
end

instantiation QREGISTER :: (type) Sup begin
lift_definition Sup_QREGISTER :: \<open>'a QREGISTER set \<Rightarrow> 'a QREGISTER\<close> is
  \<open>\<lambda>\<FF>s :: 'a qupdate set set. commutant (commutant (\<Union>\<FF>s))\<close>
proof -
  fix \<FF>s :: \<open>'a qupdate set set\<close>
  assume \<open>\<FF> \<in> Collect valid_qregister_range\<close> if \<open>\<FF> \<in> \<FF>s\<close> for \<FF>
  then have [simp]: \<open>adj ` \<FF> = \<FF>\<close> if \<open>\<FF> \<in> \<FF>s\<close> for \<FF>
    using that apply (auto simp: valid_qregister_range_def von_neumann_factor_def von_neumann_algebra_def)
    by force
  have \<open>adj ` commutant (commutant (\<Union>\<FF>s)) = commutant (commutant (\<Union>\<FF>s))\<close>
    by (simp add: commutant_adj image_Union)
  then show \<open>commutant (commutant (\<Union>\<FF>s)) \<in> Collect valid_qregister_range\<close>
    by (auto intro!: valid_qregister_rangeI)
qed
instance..
end

(* TODO move to Tensor Product *)
lemma von_neumann_algebra_UNION: \<open>(\<And>A. A \<in> \<AA> \<Longrightarrow> von_neumann_algebra A) \<Longrightarrow> von_neumann_algebra (\<Inter> \<AA>)\<close>
  by (simp add: Inter_greatest Inter_lower double_commutant_in_vn_algI equalityI von_neumann_algebra_def)

instantiation QREGISTER :: (type) Inf begin
lift_definition Inf_QREGISTER :: \<open>'a QREGISTER set \<Rightarrow> 'a QREGISTER\<close> is
  \<open>\<lambda>\<FF>s :: 'a qupdate set set. \<Inter>\<FF>s\<close>
  by (auto intro!: von_neumann_algebra_UNION simp: valid_qregister_range_def)
instance..
end

abbreviation (* LEGACY *) (input) \<open>QREGISTER_pair \<equiv> (sup :: 'a QREGISTER \<Rightarrow> _ \<Rightarrow> _)\<close>

lift_definition QQcompatible :: \<open>'a QREGISTER \<Rightarrow> 'a QREGISTER \<Rightarrow> bool\<close> is
  \<open>\<lambda>F G. \<forall>a\<in>F. \<forall>b\<in>G. a o\<^sub>C\<^sub>L b = b o\<^sub>C\<^sub>L a\<close>.

lift_definition Qqcompatible :: \<open>'a QREGISTER \<Rightarrow> ('b,'a) qregister \<Rightarrow> bool\<close> is
  \<open>\<lambda>F G. qregister_raw G \<and> (\<forall>a\<in>F. \<forall>b. a o\<^sub>C\<^sub>L G b = G b o\<^sub>C\<^sub>L a)\<close>.

lemma Qqcompatible_QQcompatible: \<open>Qqcompatible F G \<longleftrightarrow> qregister G \<and> QQcompatible F (QREGISTER_of G)\<close>
  by (simp add: Qqcompatible.rep_eq QQcompatible.rep_eq QREGISTER_of.rep_eq qregister.rep_eq)

lemma QQcompatible_sym: \<open>QQcompatible F G \<Longrightarrow> QQcompatible G F\<close> for F G :: \<open>'a QREGISTER\<close>
  by (auto simp: QQcompatible_def)

lemma qcompatible_QQcompatible: \<open>qcompatible F G \<longleftrightarrow> qregister F \<and> qregister G \<and> QQcompatible (QREGISTER_of F) (QREGISTER_of G)\<close>
  apply (transfer fixing: F G)
  apply (auto simp add: qcompatible_commute qcompatible_def)
  by (simp add: Laws_Quantum.compatible_def qregister.rep_eq)

lemma QQcompatible_QREGISTER_ofI[simp]: \<open>qcompatible F G \<Longrightarrow> QQcompatible (QREGISTER_of F) (QREGISTER_of G)\<close>
  using qcompatible_QQcompatible by auto

lemma Qqcompatible_comp_right[simp]: "Qqcompatible F G \<Longrightarrow> qregister H \<Longrightarrow> Qqcompatible F (qregister_chain G H)"
  apply transfer by auto

lemma QREGISTER_of_qregister_pair: \<open>QREGISTER_of (qregister_pair F G) = QREGISTER_pair (QREGISTER_of F) (QREGISTER_of G)\<close>
  if [simp]: \<open>qcompatible F G\<close>
proof -
  have [simp]: \<open>qregister F\<close> \<open>qregister G\<close>
    using qcompatible_register1 qcompatible_register2 that by blast+
  define F' G' where FG'_def: \<open>F' = Rep_QREGISTER (QREGISTER_of F)\<close> \<open>G' = Rep_QREGISTER (QREGISTER_of G)\<close>

  have 1: \<open>Rep_QREGISTER (QREGISTER_pair (QREGISTER_of F) (QREGISTER_of G)) \<subseteq> Rep_QREGISTER (QREGISTER_of (qregister_pair F G))\<close>
  proof -
    have \<open>F' \<subseteq> Rep_QREGISTER (QREGISTER_of (qregister_pair F G))\<close>
      apply (auto simp add: FG'_def QREGISTER_of.rep_eq)
      apply (rule range_eqI[where x=\<open>_ \<otimes>\<^sub>o id_cblinfun\<close>])
      by (simp add: apply_qregister_pair)
    moreover have \<open>G' \<subseteq> Rep_QREGISTER (QREGISTER_of (qregister_pair F G))\<close>
      apply (auto simp add: FG'_def QREGISTER_of.rep_eq)
      apply (rule range_eqI[where x=\<open>id_cblinfun \<otimes>\<^sub>o _\<close>])
      by (simp add: apply_qregister_pair)
    ultimately have \<open>F' \<union> G' \<subseteq> Rep_QREGISTER (QREGISTER_of (qregister_pair F G))\<close>
      by (simp add: FG'_def)
    then have \<open>commutant (commutant (F' \<union> G')) \<subseteq> commutant (commutant (Rep_QREGISTER (QREGISTER_of (qregister_pair F G))))\<close>
      by (intro commutant_antimono)
    also have \<open>\<dots> = Rep_QREGISTER (QREGISTER_of (qregister_pair F G))\<close>
      using Rep_QREGISTER by (auto simp: valid_qregister_range_def von_neumann_factor_def von_neumann_algebra_def)
    finally show ?thesis
      by (simp add: sup_QREGISTER.rep_eq FG'_def)
  qed
  have 2: \<open>Rep_QREGISTER (QREGISTER_of (qregister_pair F G)) \<subseteq> Rep_QREGISTER (QREGISTER_pair (QREGISTER_of F) (QREGISTER_of G))\<close>
  proof -
    have \<open>Rep_QREGISTER (QREGISTER_of (qregister_pair F G)) = apply_qregister (qregister_pair F G) ` UNIV\<close>
      by (simp add: QREGISTER_of.rep_eq)
    also have \<open>\<dots> = apply_qregister (qregister_pair F G) ` 
                    (weak_star_topology closure_of cspan (range (\<lambda>(\<xi>, \<eta>). butterfly (ket \<xi>) (ket \<eta>))))\<close>
      by simp
    also have \<open>\<dots> \<subseteq> weak_star_topology closure_of 
                        apply_qregister (qregister_pair F G) ` cspan (range (\<lambda>(\<xi>, \<eta>). butterfly (ket \<xi>) (ket \<eta>)))\<close>
      apply (rule continuous_map_image_closure_subset)
      using qregister.rep_eq that weak_star_cont_register by blast
    also have \<open>\<dots> = weak_star_topology closure_of cspan
                        (apply_qregister (qregister_pair F G) ` (range (\<lambda>(\<xi>, \<eta>). butterfly (ket \<xi>) (ket \<eta>))))\<close>
      apply (subst complex_vector.linear_span_image)
      by simp_all
    also have \<open>\<dots> = weak_star_topology closure_of cspan
                        (apply_qregister (qregister_pair F G) ` {butterfly (ket (a,b)) (ket (c,d)) |a b c d. True})\<close>
      apply (rule arg_cong[where x=\<open>range (\<lambda>(\<xi>, \<eta>). butterfly (ket \<xi>) (ket \<eta>))\<close>])
      by auto
    also have \<open>\<dots> = weak_star_topology closure_of cspan
                        {apply_qregister F (butterfly (ket a) (ket c)) o\<^sub>C\<^sub>L apply_qregister G (butterfly (ket b) (ket d)) |a b c d. True}\<close>
      apply (subst set_compr_4_image_collect)
      apply (subst set_compr_4_image_collect)
      by (simp add: image_image case_prod_unfold apply_qregister_pair
          flip: tensor_ell2_ket tensor_butterfly)
    also have \<open>\<dots> \<subseteq> weak_star_topology closure_of cspan
                        {f o\<^sub>C\<^sub>L g | f g. f \<in> F' \<and> g \<in> G'}\<close>
      apply (rule closure_of_mono)
      apply (rule complex_vector.span_mono)
      by (auto simp: FG'_def QREGISTER_of.rep_eq)
    also have \<open>\<dots> \<subseteq> commutant (commutant {f o\<^sub>C\<^sub>L g | f g. f \<in> F' \<and> g \<in> G'})\<close>
      by (rule weak_star_closure_cspan_in_double_commutant)
    also have \<open>\<dots> \<subseteq> commutant (commutant (F' \<union> G'))\<close>
      apply (rule commutant_antimono)
      apply (auto simp: commutant_def)
      by (metis (no_types, lifting) Un_iff lift_cblinfun_comp(2))
    also have \<open>\<dots> = Rep_QREGISTER (QREGISTER_pair (QREGISTER_of F) (QREGISTER_of G))\<close>
      by (simp add: sup_QREGISTER.rep_eq flip: FG'_def)
    finally show ?thesis
      by -
  qed

  from 1 2 show ?thesis
    by (auto intro!: antisym simp add: less_eq_QREGISTER_def)
qed

lemma QQcompatible3I[simp]: \<open>QQcompatible F G \<Longrightarrow> QQcompatible G H \<Longrightarrow> QQcompatible F H \<Longrightarrow> QQcompatible (QREGISTER_pair F G) H\<close> 
  apply transfer apply (auto simp: commutant_def)
  by (metis Un_iff)

lemma QQcompatible3I'[simp]: \<open>QQcompatible F G \<Longrightarrow> QQcompatible F H \<Longrightarrow> QQcompatible G H \<Longrightarrow> QQcompatible F (QREGISTER_pair G H)\<close> 
  using QQcompatible3I QQcompatible_sym by blast

lemma Qqcompatible3I[simp]: \<open>QQcompatible F G \<Longrightarrow> Qqcompatible G H \<Longrightarrow> Qqcompatible F H \<Longrightarrow> Qqcompatible (QREGISTER_pair F G) H\<close>
  by (simp add: Qqcompatible_QQcompatible)

lemma Qqcompatible3I'[simp]: \<open>Qqcompatible F G \<Longrightarrow> Qqcompatible F H \<Longrightarrow> qcompatible G H \<Longrightarrow> Qqcompatible F (qregister_pair G H)\<close>
  by (simp add: Qqcompatible_QQcompatible QREGISTER_of_qregister_pair)


definition \<open>qregister_le F G = (qregister F \<and> qregister G \<and> QREGISTER_of F \<le> QREGISTER_of G)\<close>

(* TODO: same for cregister *)
lemma qregister_le_empty_qregister[simp]:
  shows \<open>qregister_le empty_qregister Q \<longleftrightarrow> qregister Q\<close>
  by (simp add: qregister_le_def)

lemma qregister_le_pair_leftI[iff]: 
  \<open>qregister_le (qregister_pair F G) H\<close> if \<open>qcompatible F G\<close> \<open>qregister_le F H\<close> \<open>qregister_le G H\<close>
proof -
  define F' G' H' where FGH'_def: \<open>F' = Rep_QREGISTER (QREGISTER_of F)\<close> 
    \<open>G' = Rep_QREGISTER (QREGISTER_of G)\<close> \<open>H' = Rep_QREGISTER (QREGISTER_of H)\<close>
  have \<open>F' \<union> G' \<subseteq> H'\<close>
    by (metis FGH'_def Un_least less_eq_QREGISTER.rep_eq qregister_le_def that(2,3))
  then have \<open>commutant (commutant (F' \<union> G')) \<subseteq> commutant (commutant H')\<close>
    by (auto intro!: commutant_antimono)
  also have \<open>\<dots> = H'\<close>
    using FGH'_def Rep_QREGISTER by (auto simp: valid_qregister_range_def von_neumann_factor_def von_neumann_algebra_def)
  finally have \<open>commutant (commutant (F' \<union> G')) \<subseteq> H'\<close>
    by -
  then show ?thesis
    using that 
    by (simp add: qregister_le_def QREGISTER_of_qregister_pair sup_QREGISTER.rep_eq 
        less_eq_QREGISTER.rep_eq flip: FGH'_def)
qed

lemma qregister_le_pair_rightI1: \<open>qregister_le F (qregister_pair G H)\<close> if \<open>qcompatible G H\<close> \<open>qregister_le F G\<close>
proof -
  define F' G' H' where FGH'_def: \<open>F' = Rep_QREGISTER (QREGISTER_of F)\<close> 
    \<open>G' = Rep_QREGISTER (QREGISTER_of G)\<close> \<open>H' = Rep_QREGISTER (QREGISTER_of H)\<close>
  have \<open>F' \<subseteq> G' \<union> H'\<close>
    using FGH'_def less_eq_QREGISTER.rep_eq qregister_le_def that(2) by blast
  then have \<open>commutant (commutant (G' \<union> H')) \<supseteq> commutant (commutant F')\<close> (is \<open>_ \<supseteq> \<dots>\<close>)
    by (auto intro!: commutant_antimono)
  also have \<open>\<dots> = F'\<close>
    using FGH'_def Rep_QREGISTER by (auto simp: valid_qregister_range_def von_neumann_factor_def von_neumann_algebra_def)
  finally have \<open>commutant (commutant (G' \<union> H')) \<supseteq> F'\<close>
    by -
  then show ?thesis
    using that 
    by (simp add: qregister_le_def QREGISTER_of_qregister_pair sup_QREGISTER.rep_eq 
        less_eq_QREGISTER.rep_eq flip: FGH'_def)
qed

lemma qregister_le_pair_rightI2: \<open>qregister_le F (qregister_pair G H)\<close> if \<open>qcompatible G H\<close> \<open>qregister_le F H\<close>
  using qregister_le_pair_rightI1[OF that(1)[THEN qcompatible_sym] that(2)]
  by (auto simp add: qregister_le_def qcompatible_sym QREGISTER_of_qregister_pair
      less_eq_QREGISTER.rep_eq sup_QREGISTER.rep_eq Un_commute)

lemma qregister_le_refl[iff]: \<open>qregister F \<Longrightarrow> qregister_le F F\<close> (* TODO: could replace this by a simp-rule *)
  unfolding qregister_le_def by simp


lemma QREGISTER_of_iso: \<open>QREGISTER_of I = QREGISTER_all\<close> if \<open>iso_qregister I\<close>
proof -
  have \<open>x \<in> range (apply_qregister I)\<close> for x
    apply (rule range_eqI[where x=\<open>apply_qregister (qregister_inv I) x\<close>])
    by (metis inj_qregister inv_f_eq iso_qregister_def' iso_qregister_inv_iso iso_qregister_inv_iso_apply that)
  then show ?thesis
    apply (transfer fixing: I)
    using that by (auto simp: iso_qregister_def')
qed

lemma qregister_le_iso: \<open>qregister F \<Longrightarrow> iso_qregister G \<Longrightarrow> qregister_le F G\<close>
  by (simp add: qregister_le_def QREGISTER_of_iso less_eq_QREGISTER.rep_eq top_QREGISTER.rep_eq
      iso_qregister_def')

lemma qregister_le_id[iff]: \<open>qregister F \<Longrightarrow> qregister_le F qregister_id\<close> (* TODO: could replace this by a simp-rule *)
  by (simp add: iso_qregister_def qregister_le_iso)

instantiation QREGISTER :: (type) uminus begin
lift_definition uminus_QREGISTER :: \<open>'a QREGISTER \<Rightarrow> 'a QREGISTER\<close> is commutant
  by (auto simp add: valid_qregister_range_def von_neumann_algebra_commutant)
instance..
end

abbreviation (* LEGACY *) (input) \<open>QCOMPLEMENT \<equiv> (uminus :: 'a QREGISTER \<Rightarrow> _)\<close>

lemma Qqcompatible_antimono_left: \<open>A \<le> B \<Longrightarrow> Qqcompatible B C \<Longrightarrow> Qqcompatible A C\<close>
  apply transfer by auto


lemma Qqcompatible_QREGISTER_of: \<open>Qqcompatible (QREGISTER_of A) B \<longleftrightarrow> qcompatible A B \<or> (qregister B \<and> A = non_qregister)\<close>
  unfolding QREGISTER_of.rep_eq Qqcompatible.rep_eq
  apply transfer
  by (auto simp add: non_qregister_raw one_algebra_def qcompatible_raw_def)

lemma Qqcompatible_QREGISTER_ofI[simp]: \<open>qcompatible F G \<Longrightarrow> Qqcompatible (QREGISTER_of F) G\<close>
  by (simp add: Qqcompatible_QREGISTER_of)


lemma QCOMPLEMENT_twice: \<open>QCOMPLEMENT (QCOMPLEMENT F) = F\<close>
  apply (rule Rep_QREGISTER_inject[THEN iffD1])
  using Rep_QREGISTER
  by (auto simp: uminus_QREGISTER.rep_eq valid_qregister_range_def von_neumann_algebra_def)

lemma QCOMPLEMENT_antimono: \<open>QCOMPLEMENT F \<ge> QCOMPLEMENT G\<close> if \<open>F \<le> G\<close>
  using that apply transfer
  by (metis commutant_antimono)

lemma QREGISTER_pair_valid_qregister_range_hull:
  \<open>Rep_QREGISTER (QREGISTER_pair F G) = valid_qregister_range hull (Rep_QREGISTER F \<union> Rep_QREGISTER G)\<close>
  apply (simp add: sup_QREGISTER.rep_eq)
  apply (subst double_commutant_hull')
  using Rep_QREGISTER unfolding valid_qregister_range_def von_neumann_algebra_def by auto

(* TODO: also for CREGISTER *)
instantiation QREGISTER :: (type) semilattice_sup begin
instance
proof intro_classes
  fix x y z :: \<open>'a QREGISTER\<close>
  show \<open>x \<le> x \<squnion> y\<close>
    apply transfer
    by (meson Un_subset_iff double_commutant_grows)
  show \<open>y \<le> x \<squnion> y\<close>
    apply transfer
    by (meson Un_subset_iff double_commutant_grows)
  show \<open>y \<le> x \<Longrightarrow> z \<le> x \<Longrightarrow> y \<squnion> z \<le> x\<close>
    apply transfer
    apply auto
    by (meson double_commutant_in_vn_algI le_sup_iff subsetD valid_qregister_range_def)
qed
end

instantiation QREGISTER :: (type) lattice begin
(* TODO: If we would change valid_qregister_range to mean von Neumann factor, we would even get orthocomplemented_lattice.
   But we don't have a proof that the intersection of two factors is a factor. *)
instance
proof intro_classes
  fix x y z :: \<open>'a QREGISTER\<close>
  show \<open>x \<sqinter> y \<le> x\<close>
    apply transfer by simp
  show \<open>x \<sqinter> y \<le> y\<close>
    apply transfer by simp
  show \<open>x \<le> y \<Longrightarrow> x \<le> z \<Longrightarrow> x \<le> y \<sqinter> z\<close>
    apply transfer by simp
qed
end

instantiation QREGISTER :: (type) bounded_lattice begin
instance
proof intro_classes
  fix x y :: \<open>'a QREGISTER\<close>
  show \<open>\<bottom> \<le> x\<close>
    apply transfer
    by (metis commutant_UNIV commutant_antimono mem_Collect_eq top.extremum valid_qregister_range_def von_neumann_algebra_def)
  show \<open>x \<le> \<top>\<close>
    apply transfer
    by simp
qed
end

instantiation QREGISTER :: (type) complete_lattice begin
instance
proof intro_classes
  fix \<FF>s :: \<open>'a QREGISTER set\<close> and \<GG> :: \<open>'a QREGISTER\<close>
  show \<open>\<GG> \<le> \<Squnion>\<FF>s\<close> if \<open>\<GG> \<in> \<FF>s\<close>
    using that apply transfer
    by (meson Union_upper double_commutant_grows subset_trans)
  show \<open>\<Sqinter>\<FF>s \<le> \<GG>\<close> if \<open>\<GG> \<in> \<FF>s\<close>
    using that apply transfer by blast
  show \<open>(\<And>\<FF>. \<FF> \<in> \<FF>s \<Longrightarrow> \<GG> \<le> \<FF>) \<Longrightarrow> \<GG> \<le> \<Sqinter> \<FF>s\<close>
    apply transfer by auto
  show \<open>(\<And>\<FF>. \<FF> \<in> \<FF>s \<Longrightarrow> \<GG> \<ge> \<FF>) \<Longrightarrow> \<GG> \<ge> \<Squnion> \<FF>s\<close>
    apply transfer apply auto
    by (meson Sup_least double_commutant_in_vn_algI subset_iff valid_qregister_range_def)
  show \<open>\<Sqinter> {} = (\<top> :: 'a QREGISTER)\<close>
    apply transfer by auto
  show \<open>\<Squnion> {} = (\<bottom> :: 'a QREGISTER)\<close>
    apply transfer
    by (simp_all add: commutant_UNIV)
qed
end

definition \<open>actual_qregister_range_aux f a \<longleftrightarrow> 
    (\<forall>x y. snd (f x) \<noteq> snd (f y) \<longrightarrow> ket x \<bullet>\<^sub>C (a *\<^sub>V ket y) = 0)
      \<and> (\<forall>x y x' y'. fst (f x) = fst (f x') \<longrightarrow> fst (f y) = fst (f y') \<longrightarrow> 
                     snd (f x) = snd (f y) \<longrightarrow> snd (f x') = snd (f y') \<longrightarrow>
                         ket x \<bullet>\<^sub>C (a *\<^sub>V ket y) = ket x' \<bullet>\<^sub>C (a *\<^sub>V ket y'))\<close>

text \<open>The following definition captures all \<^typ>\<open>_ QREGISTER\<close> that actually correspond to
  some register (see theorems \<open>qregister_has_actual_qregister_range\<close> and
  \<open>actual_qregister_range_ex_register\<close> below).
  Most likely, this is just equal to saying \<^term>\<open>\<FF>\<close> is a von Neumann type I factor,
  but we use this more elementary but rather unreadable definition instead
  because otherwise we would need to prove more properties about von Neumann type I
  factors.\<close>
definition actual_qregister_range :: \<open>'a qupdate set \<Rightarrow> bool\<close> where
  \<open>actual_qregister_range \<FF> \<longleftrightarrow> (\<exists>(f :: 'a \<Rightarrow> 'a\<times>'a) U L R. unitary U \<and> 
    inj f \<and> range f = L \<times> R \<and>
    \<FF> = {sandwich U a | a. actual_qregister_range_aux f a})\<close>

lemma actual_qregister_range_aux_sandwich:
  assumes \<open>\<And>x. U *\<^sub>V ket x = ket (f x)\<close>
  assumes \<open>unitary U\<close>
  assumes \<open>bij f\<close>
  shows \<open>actual_qregister_range_aux id (sandwich U a) \<longleftrightarrow> actual_qregister_range_aux f a\<close>
proof -
  have [simp]: \<open>U* *\<^sub>V ket x = ket (inv f x)\<close> for x
    by (metis (mono_tags, lifting) \<open>bij f\<close> assms(1) assms(2) bij_betw_imp_surj_on cinner_adj_right cinner_ket_eqI isometry_cinner_both_sides surj_f_inv_f unitary_isometry)

  have \<open>bij (inv f)\<close>
    by (simp add: \<open>bij f\<close> bij_imp_bij_inv)

  show ?thesis
    using assms
    apply (auto simp: sandwich_apply actual_qregister_range_aux_def bij_betw_imp_surj_on surj_f_inv_f
        simp flip: cinner_adj_left)
     apply (metis \<open>bij f\<close>  bij_betw_imp_inj_on invI surjective_pairing)
    by (smt (verit) \<open>bij f\<close>  bij_betw_imp_inj_on inv_f_f surjective_pairing)
qed

(* TODO: generalize (not only "type", rep/abs args) *)
(* TODO move *)
lemma with_type_swap:
  fixes A :: \<open>'c set\<close> and B :: \<open>'d set\<close>
  assumes \<open>A \<noteq> {}\<close> and \<open>B \<noteq> {}\<close>
  shows \<open>(let 'a::type = A in let 'b::type = B in P) \<longleftrightarrow> (let 'b::type = B in let 'a::type = A in P)\<close>
  apply (cases \<open>\<exists>(Rep::'a\<Rightarrow>'c) Abs. type_definition Rep Abs A\<close>; cases \<open>\<exists>(Rep::'b\<Rightarrow>'d) Abs. type_definition Rep Abs B\<close>)
  using assms by (auto simp add: with_type_def WITH_TYPE_CLASS_type_def WITH_TYPE_REL_type_def with_type_wellformed_def)


lemma Collect_actual_qregister_range_aux_id:
  \<open>{a. actual_qregister_range_aux id a} = range (\<lambda>\<theta>. \<theta> \<otimes>\<^sub>o id_cblinfun)\<close>
proof (intro Set.set_eqI iffI)
  fix a :: \<open>('a \<times> 'c) ell2 \<Rightarrow>\<^sub>C\<^sub>L ('a \<times> 'c) ell2\<close>
  assume \<open>a \<in> range (\<lambda>\<theta>. \<theta> \<otimes>\<^sub>o id_cblinfun)\<close>
  then show \<open>a \<in> {a. actual_qregister_range_aux id a}\<close>
    by (auto simp: tensor_op_ell2 tensor_ell2_inner_prod actual_qregister_range_aux_def
        simp flip: tensor_ell2_ket)
next
  fix a
  assume asm: \<open>a \<in> {a. actual_qregister_range_aux id a}\<close>
  define \<theta> where \<open>\<theta> = tensor_ell2_right (ket undefined)* o\<^sub>C\<^sub>L a o\<^sub>C\<^sub>L tensor_ell2_right (ket undefined)\<close>
  have \<open>a = \<theta> \<otimes>\<^sub>o id_cblinfun\<close>
    using asm
    by (auto intro!: equal_ket cinner_ket_eqI 
        simp: tensor_op_ell2 tensor_ell2_inner_prod cinner_ket
        \<theta>_def cinner_adj_right actual_qregister_range_aux_def
        simp flip: tensor_ell2_ket)
  then show \<open>a \<in> range (\<lambda>\<theta>. \<theta> \<otimes>\<^sub>o id_cblinfun)\<close>
    by auto
qed

lemma qregister_has_actual_qregister_range:
  fixes F :: \<open>('a,'b) qregister\<close>
  assumes \<open>qregister F\<close>
  shows \<open>actual_qregister_range (range (apply_qregister F))\<close>
proof -
  define \<FF> where \<open>\<FF> = range (apply_qregister F)\<close>
  have \<open>qregister_raw (apply_qregister F)\<close>
    using assms by (simp add: qregister_raw_apply_qregister)
  from register_decomposition[OF this]
  have \<open>let 'c::type = qregister_decomposition_basis F in
        actual_qregister_range \<FF>\<close>
  proof (rule with_type_mp)
    assume \<open>\<exists>V :: ('a \<times> 'c) ell2 \<Rightarrow>\<^sub>C\<^sub>L 'b ell2. unitary V \<and> (\<forall>\<theta>. apply_qregister F \<theta> = sandwich V *\<^sub>V (\<theta> \<otimes>\<^sub>o id_cblinfun))\<close>
    then obtain V :: \<open>('a \<times> 'c) ell2 \<Rightarrow>\<^sub>C\<^sub>L 'b ell2\<close> where [simp]: \<open>unitary V\<close> and F_decomp: \<open>apply_qregister F \<theta> = sandwich V *\<^sub>V (\<theta> \<otimes>\<^sub>o id_cblinfun)\<close> for \<theta>
      by auto

    obtain g :: \<open>'a \<times> 'c \<Rightarrow> 'b\<close> where [simp]: \<open>bij g\<close>
    proof (atomize_elim, rule exI)
      note bij_betw_trans[trans]
      have \<open>bij_betw ket UNIV (range ket)\<close>
        by (simp add: bij_betw_def)
      also have \<open>bij_betw V (range ket) (V ` range ket)\<close>
        by (auto intro!: inj_on_imp_bij_betw unitary_inj)
      also have \<open>bij_betw (bij_between_bases (V ` range ket) (range ket)) (V ` range ket) (range ket)\<close>
        by (auto intro!: bij_between_bases_bij unitary_image_onb)
      also have \<open>bij_betw (inv ket) (range ket) UNIV\<close>
        by (simp add: inj_imp_bij_betw_inv)
      finally show \<open>bij (inv ket o bij_between_bases (V ` range ket) (range ket) o V o ket)\<close>
        by (simp add: comp_assoc)
    qed
    have [simp]: \<open>range (inv g) = UNIV\<close>
      by (simp add: bij_betw_inv_into bij_is_surj)

    define G where \<open>G = classical_operator (Some o g)\<close>

    obtain ia :: \<open>'a \<Rightarrow> 'b\<close> where \<open>inj ia\<close>
      apply (atomize_elim, rule exI[where x=\<open>\<lambda>a. g (a,undefined)\<close>])
      by (smt (verit) Pair_inject UNIV_I \<open>bij g\<close> bij_betw_iff_bijections injI)
    obtain ic :: \<open>'c \<Rightarrow> 'b\<close> where \<open>inj ic\<close>
      apply (atomize_elim, rule exI[where x=\<open>\<lambda>c. g (undefined,c)\<close>])
      by (smt (verit) UNIV_I \<open>bij g\<close> bij_betw_iff_bijections injI prod.simps(1))
      
    define L R where \<open>L = range ia\<close> and \<open>R = range ic\<close>

    define f :: \<open>'b \<Rightarrow> 'b \<times> 'b\<close> where \<open>f = map_prod ia ic o inv g\<close>

    have [simp]: \<open>fst (f x) = fst (f y) \<longleftrightarrow> fst (inv g x) = fst (inv g y)\<close> for x y
      using \<open>inj ia\<close> f_def injD by fastforce
    have [simp]: \<open>snd (f x) = snd (f y) \<longleftrightarrow> snd (inv g x) = snd (inv g y)\<close> for x y
      using \<open>inj ic\<close> f_def injD by fastforce

    define U :: \<open>'b ell2 \<Rightarrow>\<^sub>C\<^sub>L 'b ell2\<close>
      where \<open>U = V o\<^sub>C\<^sub>L G*\<close>

    have [simp]: \<open>unitary G\<close>
      by (simp add: G_def)
    have \<open>G (ket x) = ket (g x)\<close> for x
      by (simp add: G_def bij_is_inj classical_operator_ket classical_operator_exists_inj)
    then have Gadj_ket: \<open>G* *\<^sub>V (ket x) = ket (inv g x)\<close> for x
      apply (subst unitary_adj_inv)
      by (simp_all add: bij_is_surj inv_f_eq surj_f_inv_f unitary_inj)
    have bij_sandwich_G: \<open>bij (sandwich G)\<close>
      by (auto intro!: o_bij[where g=\<open>sandwich (G*)\<close>] simp flip: sandwich_compose cblinfun_compose.rep_eq)
    have inv_sandwich_G: \<open>inv (sandwich G) = sandwich (G*)\<close>
      by (auto intro!: inv_unique_comp simp flip: sandwich_compose cblinfun_compose.rep_eq)

    have \<open>\<FF> = sandwich V ` range (\<lambda>\<theta>. \<theta> \<otimes>\<^sub>o id_cblinfun)\<close>
      by (simp add: \<FF>_def F_decomp image_image)
    also have \<open>\<dots> = sandwich V ` {a. actual_qregister_range_aux id a}\<close>
      by (simp add: Collect_actual_qregister_range_aux_id)
    also have \<open>\<dots> = sandwich U ` sandwich G ` {a. actual_qregister_range_aux id a}\<close>
      by (simp add: U_def image_image cblinfun_assoc_right unitaryD1
          flip: cblinfun_apply_cblinfun_compose sandwich_compose)
    also have \<open>\<dots> = sandwich U ` {a. actual_qregister_range_aux id (sandwich (G*) a)}\<close>
      by (simp add: bij_image_Collect_eq bij_sandwich_G inv_sandwich_G)
    also have \<open>\<dots> = sandwich U ` {a. actual_qregister_range_aux (inv g) a}\<close>
      by (simp add: actual_qregister_range_aux_sandwich Gadj_ket bij_imp_bij_inv)
    also have \<open>\<dots> = sandwich U ` {a. actual_qregister_range_aux f a}\<close>
      by (simp add: actual_qregister_range_aux_def)
    also have \<open>\<dots> = {sandwich U a | a. actual_qregister_range_aux f a}\<close>
      by auto
    finally have \<FF>_eq: \<open>\<FF> = {sandwich U a | a. actual_qregister_range_aux f a}\<close>
      by -
    moreover have inj_f: \<open>inj f\<close>
      by (auto intro!: inj_compose prod.inj_map
          simp add: bij_betw_inv_into bij_is_inj f_def \<open>inj ia\<close> \<open>inj ic\<close>)
    moreover have range_f: \<open>range f = L \<times> R\<close>
      by (auto simp add: f_def L_def R_def simp flip: image_image)
    moreover have unitary_U: \<open>unitary U\<close>
      by (auto intro!: unitary_cblinfun_compose
          simp add: U_def)
    show \<open>actual_qregister_range \<FF>\<close>
      unfolding actual_qregister_range_def
      apply (rule exI[of _ f], rule exI[of _ U], rule exI[of _ L], rule exI[of _ R])
      by (simp only: unitary_U inj_f range_f \<FF>_eq)
  qed
  from this[cancel_with_type]
  show \<open>actual_qregister_range \<FF>\<close>
    by -
qed

definition \<open>actual_qregister_range_content \<FF> = (SOME L::'a set.
    \<exists>(f :: 'a \<Rightarrow> 'a\<times>'a) U R. unitary U \<and> 
        inj f \<and> range f = L \<times> R \<and>
        \<FF> = {sandwich U a | a. actual_qregister_range_aux f a})\<close>
  for \<FF> :: \<open>('a ell2 \<Rightarrow>\<^sub>C\<^sub>L 'a ell2) set\<close>

lemma actual_qregister_range_ex_register_aux:
    \<comment> \<open>Mainly used for \<open>actual_qregister_range_ex_register\<close> below, but can be useful on its own\<close>
  fixes \<FF> :: \<open>('a ell2 \<Rightarrow>\<^sub>C\<^sub>L 'a ell2) set\<close> and f :: \<open>'a \<Rightarrow> 'b\<times>'c\<close> and L R
  assumes \<open>unitary U\<close> and \<open>inj f\<close> and range_f: \<open>range f = L \<times> R\<close> 
  assumes \<FF>_eq: \<open>\<FF> = {sandwich U a | a. actual_qregister_range_aux f a}\<close>
  shows \<open>let 'l::type = L in let 'r::type = R in
         \<exists>F :: ('l, 'a) qregister. qregister F \<and> range (apply_qregister F) = \<FF> \<and>
              F = qregister_chain (transform_qregister (U o\<^sub>C\<^sub>L (classical_operator (Some o map_prod (inv rep_l) (inv rep_r) o f))*)) qFst\<close>
proof with_type_intro
  from range_f have \<open>L \<noteq> {}\<close> and \<open>R \<noteq> {}\<close>
    by auto
  then show \<open>L \<noteq> {}\<close>
    by simp
  fix RepL :: \<open>'l \<Rightarrow> 'b\<close>
  assume bijL: \<open>bij_betw RepL UNIV L\<close>
  define AbsL where \<open>AbsL = inv RepL\<close>
  with bijL interpret L: type_definition RepL AbsL L
    by (simp add: type_definition_bij_betw_iff)
  show \<open>let 'r::type = R in
          \<exists>F :: ('l, 'a) qregister. qregister F \<and> range (apply_qregister F) = \<FF> \<and>
          F = qregister_chain (transform_qregister (U o\<^sub>C\<^sub>L (classical_operator (Some o map_prod AbsL (inv rep_r) o f))*)) qFst\<close>
  proof with_type_intro
    from \<open>R \<noteq> {}\<close> show \<open>R \<noteq> {}\<close>
      by simp
    fix RepR :: \<open>'r \<Rightarrow> 'c\<close>
    assume bij_R: \<open>bij_betw RepR UNIV R\<close>
    define AbsR where \<open>AbsR = inv RepR\<close>
    with bij_R interpret R: type_definition RepR AbsR R
      using type_definition_bij_betw_iff by blast
    define f' where \<open>f' = map_prod AbsL AbsR o f\<close>
    have \<open>bij f'\<close>
    proof -
      note bij_betw_trans[trans]
      have \<open>bij_betw f UNIV (L \<times> R)\<close>
        by (simp add: \<open>inj f\<close> bij_betw_def range_f)
      also have \<open>bij_betw (map_prod AbsL AbsR) (L \<times> R) (UNIV \<times> UNIV)\<close>
        apply (rule bij_betw_map_prod)
         apply (simp add: AbsL_def bijL bij_betw_inv_into)
        by (smt (verit) R.Abs_inject R.univ UNIV_I bij_betwI' imageE)
      finally show ?thesis
        by (simp add: f'_def)
    qed
    define V where \<open>V = classical_operator (Some o f')\<close>
    have [simp]: \<open>unitary V\<close>
      by (simp add: V_def unitary_classical_operator \<open>bij f'\<close>)
    have V_ket: \<open>V *\<^sub>V ket x = ket (f' x)\<close> for x
      by (simp add: V_def classical_operator_ket classical_operator_exists_inj inj_map_total bij_is_inj \<open>bij f'\<close>)
    then have Vadj_ket: \<open>V* *\<^sub>V ket x = ket (inv f' x)\<close> for x
      apply (subst unitary_adj_inv)
      by (simp_all add: \<open>bij f'\<close> bij_is_surj inv_f_eq surj_f_inv_f unitary_inj)
    have bij_sandwich_Vadj: \<open>bij (sandwich (V*))\<close>
      by (auto intro!: o_bij[where g=\<open>sandwich V\<close>] simp flip: sandwich_compose cblinfun_compose.rep_eq)
    have inv_sandwich_Vadj: \<open>inv (sandwich (V*)) = sandwich V\<close>
      by (auto intro!: inv_unique_comp simp flip: sandwich_compose simp flip: cblinfun_compose.rep_eq)

    define F where \<open>F = qregister_chain (transform_qregister (U o\<^sub>C\<^sub>L V*)) qFst\<close>
    have \<open>qregister F\<close>
      by (auto intro!: qregister_transform_qregister unitary_cblinfun_compose
          simp: F_def \<open>unitary U\<close>)
    moreover have \<open>range (apply_qregister F) = \<FF>\<close>
    proof -
      have aux1: \<open>fst (f' x) = fst (f' y) \<longleftrightarrow> fst (f x) = fst (f y)\<close> for x y
        by (metis L.Abs_inverse comp_apply eq_fst_iff f'_def fst_map_prod mem_Sigma_iff rangeI range_f)
      have aux2: \<open>snd (f' x) = snd (f' y) \<longleftrightarrow> snd (f x) = snd (f y)\<close> for x y
        by (metis R.type_definition_axioms SigmaD2 comp_eq_dest_lhs f'_def rangeI range_f snd_map_prod surjective_pairing type_definition.Abs_inject)

      have \<open>range (apply_qregister F) = sandwich U ` sandwich (V*) ` range (\<lambda>x. x \<otimes>\<^sub>o id_cblinfun)\<close>
        by (auto simp add: F_def apply_qregister_fst apply_qregister_transform_qregister \<open>unitary U\<close>
            sandwich_compose)
      also have \<open>\<dots> = sandwich U ` sandwich (V*) ` {a. actual_qregister_range_aux id a}\<close>
        by (simp add: Collect_actual_qregister_range_aux_id)
      also have \<open>\<dots> = sandwich U ` {a. actual_qregister_range_aux id (sandwich V a)}\<close>
        by (simp add: bij_image_Collect_eq bij_sandwich_Vadj inv_sandwich_Vadj)
      also have \<open>\<dots> = sandwich U ` {a. actual_qregister_range_aux f' a}\<close>
        apply (subst actual_qregister_range_aux_sandwich)
        by (simp_all add: V_ket \<open>unitary V\<close> \<open>bij f'\<close>)
      also have \<open>\<dots> = sandwich U ` {a. actual_qregister_range_aux f a}\<close>
        apply (rule arg_cong[where f=\<open>\<lambda>a. sandwich U ` Collect a\<close>], rule ext)
        by (simp add: actual_qregister_range_aux_def aux1 aux2)
      also have \<open>\<dots> = {sandwich U a | a. actual_qregister_range_aux f a}\<close>
        by blast
      finally show ?thesis
        by (simp add: \<FF>_eq)
    qed
    moreover have \<open>F = qregister_chain (transform_qregister (U o\<^sub>C\<^sub>L (classical_operator (Some o map_prod AbsL AbsR o f))*)) qFst\<close>
      by (simp add: F_def V_def comp_assoc f'_def)
    ultimately show \<open>\<exists>F :: ('l, 'a) qregister. qregister F \<and> range (apply_qregister F) = \<FF>
        \<and> F = qregister_chain (transform_qregister (U o\<^sub>C\<^sub>L (classical_operator (Some o map_prod AbsL AbsR o f))*)) qFst\<close>
      by auto
  qed
qed


lemma actual_qregister_range_ex_register:
  fixes \<FF> :: \<open>('a ell2 \<Rightarrow>\<^sub>C\<^sub>L 'a ell2) set\<close>
  assumes \<open>actual_qregister_range \<FF>\<close>
  shows \<open>let 'l::type = actual_qregister_range_content \<FF> in
         \<exists>F :: ('l, 'a) qregister. qregister F \<and> range (apply_qregister F) = \<FF>\<close>
proof -
  define L where \<open>L = actual_qregister_range_content \<FF>\<close>
  have \<open>\<exists>(f :: 'a \<Rightarrow> 'a\<times>'a) U R. unitary U \<and> 
        inj f \<and> range f = L \<times> R \<and>
        \<FF> = {sandwich U a | a. actual_qregister_range_aux f a}\<close>
    unfolding L_def actual_qregister_range_content_def apply (rule someI_ex)
    using assms unfolding actual_qregister_range_def 
    by blast
  then obtain f :: \<open>'a \<Rightarrow> 'a\<times>'a\<close> and U R where \<open>unitary U\<close> and \<open>inj f\<close> and range_f: \<open>range f = L \<times> R\<close>
    and \<FF>_eq: \<open>\<FF> = {sandwich U a | a. actual_qregister_range_aux f a}\<close>
    by auto
  then have \<open>let 'l::type = L in let 'r::type = R in
         \<exists>F :: ('l, 'a) qregister. qregister F \<and> range (apply_qregister F) = \<FF> \<and>
              F = qregister_chain (transform_qregister (U o\<^sub>C\<^sub>L (classical_operator (Some o map_prod (inv rep_l) (inv rep_r) o f))*)) qFst\<close>
    apply (rule_tac actual_qregister_range_ex_register_aux)
    by (auto simp: L_def)
  then have *: \<open>let 'l::type = L in let 'r::type = R in
         \<exists>F :: ('l, 'a) qregister. qregister F \<and> range (apply_qregister F) = \<FF>\<close> for xxx :: \<open>'r\<close>
    apply (rule with_type_mp)
    apply (rule with_type_mp)
    by blast+
  from range_f have \<open>L \<noteq> {}\<close> and \<open>R \<noteq> {}\<close>
    by auto
  note *[THEN with_type_swap[OF this, THEN iffD1]]
  from this[cancel_with_type]
  show \<open>let 'l::type = L in
         \<exists>F :: ('l, 'a) qregister. qregister F \<and> range (apply_qregister F) = \<FF>\<close>
    by -
qed


lemma actual_qregister_range_is_valid:
  assumes \<open>actual_qregister_range \<FF>\<close>
  shows \<open>valid_qregister_range \<FF>\<close>
proof -
  from actual_qregister_range_ex_register[OF assms]
  have \<open>let 'c::type = actual_qregister_range_content \<FF> in
        valid_qregister_range \<FF>\<close>
  proof (rule with_type_mp)
    assume \<open>\<exists>F :: ('b, 'a) qregister. qregister F \<and> range (apply_qregister F) = \<FF>\<close>
    then obtain F :: \<open>('b, 'a) qregister\<close> where \<open>qregister F\<close> and \<open>range (apply_qregister F) = \<FF>\<close>
      by auto
    then show \<open>valid_qregister_range \<FF>\<close>
      using valid_qregister_range by blast
  qed
  from this[cancel_with_type]
  show ?thesis
    by -
qed


lemma valid_qregister_range_def_sot:
  \<open>valid_qregister_range \<FF> \<longleftrightarrow> 
      (\<forall>a\<in>\<FF>. a* \<in> \<FF>) \<and> csubspace \<FF> \<and> (\<forall>a\<in>\<FF>. \<forall>b\<in>\<FF>. a o\<^sub>C\<^sub>L b \<in> \<FF>) \<and> id_cblinfun \<in> \<FF> \<and>
      closedin cstrong_operator_topology \<FF>\<close>
  by (simp add: valid_qregister_range_def von_neumann_algebra_def_sot)

(* TODO: valid_qregister_range could be a corollary of this *)
lemma valid_qregister_range_pres:
  assumes qreg: \<open>qregister F\<close>
  assumes valid: \<open>valid_qregister_range A\<close>
  shows \<open>valid_qregister_range (apply_qregister F ` A)\<close>
proof (intro valid_qregister_range_def_sot[THEN iffD2] conjI ballI)
  show \<open>a \<in> apply_qregister F ` A \<Longrightarrow> a* \<in> apply_qregister F ` A\<close> for a
    using assms unfolding valid_qregister_range_def von_neumann_algebra_def
    by (metis (no_types, lifting) apply_qregister_adj image_iff)
  show \<open>csubspace (apply_qregister F ` A)\<close>
    using valid
    by (metis clinear_apply_qregister complex_vector.linear_subspace_image csubspace_commutant
        valid_qregister_range_def von_neumann_algebra_def)
  show \<open>a o\<^sub>C\<^sub>L b \<in> apply_qregister F ` A\<close>
    if \<open>a \<in> apply_qregister F ` A\<close> and \<open>b \<in> apply_qregister F ` A\<close> for a b
  proof -
    from that obtain a' where a': \<open>a' \<in> A\<close> and a_def: \<open>a = apply_qregister F a'\<close>
      by auto
    from that obtain b' where b': \<open>b' \<in> A\<close> and b_def: \<open>b = apply_qregister F b'\<close>
      by auto
    from valid have \<open>a' o\<^sub>C\<^sub>L b' \<in> A\<close>
      using that a' b' by (simp add: valid_qregister_range_def_sot)
    then show ?thesis
      using qreg by (simp add: a_def b_def qregister_compose rev_image_eqI)
  qed
  show \<open>id_cblinfun \<in> apply_qregister F ` A\<close>
    using assms 
    by (metis apply_qregister_of_id imageI valid_qregister_range_def von_neumann_algebra_id)
  show \<open>closedin cstrong_operator_topology (apply_qregister F ` A)\<close>
  proof -
    have \<open>closedin cstrong_operator_topology A\<close>
      using valid valid_qregister_range_def_sot by blast
    moreover have \<open>closed_map cstrong_operator_topology cstrong_operator_topology (apply_qregister F)\<close>
      using qreg
      by (simp add: closed_map_sot_register)
    ultimately show ?thesis
      using closed_map_def by blast
  qed
qed

lemma valid_qregister_range_pres_raw:
  assumes qreg: \<open>qregister_raw F\<close>
  assumes valid: \<open>valid_qregister_range A\<close>
  shows \<open>valid_qregister_range (F ` A)\<close>
  by (metis assms(1) assms(2) qregister_Abs_qregister qregister_apply_Abs valid_qregister_range_pres)

lift_definition QREGISTER_chain :: \<open>('a,'b) qregister \<Rightarrow> 'a QREGISTER \<Rightarrow> 'b QREGISTER\<close> is
  \<open>\<lambda>F \<GG>. if qregister_raw F then F ` \<GG> else one_algebra\<close>
  by (auto simp: non_qregister_raw  
      intro!: valid_qregister_range_pres_raw valid_one_algebra)

lift_definition QREGISTER_fst :: \<open>('a\<times>'b) QREGISTER\<close> is
  \<open>(\<lambda>a. a \<otimes>\<^sub>o id_cblinfun) ` UNIV\<close>
  using valid_qregister_range[of qFst]
  by (simp add: apply_qregister_fst[abs_def])
lift_definition QREGISTER_snd :: \<open>('a\<times>'b) QREGISTER\<close> is
  \<open>(\<lambda>a. id_cblinfun \<otimes>\<^sub>o a) ` UNIV\<close>
  using valid_qregister_range[of qSnd]
  by (simp add: apply_qregister_snd[abs_def])

lemma apply_qregister_one_algebra: \<open>qregister F \<Longrightarrow> apply_qregister F ` one_algebra = one_algebra\<close>
  by (auto simp add: image_image one_algebra_def apply_qregister_scaleC)

lemma QREGISTER_of_qregister_chain: \<open>QREGISTER_of (qregister_chain F G) = QREGISTER_chain F (QREGISTER_of G)\<close>
  apply (rule Rep_QREGISTER_inject[THEN iffD1])
  by (auto simp add: QREGISTER_of.rep_eq QREGISTER_chain.rep_eq apply_qregister_one_algebra qregister_raw_apply_qregister)

lemma QREGISTER_of_qFst: \<open>QREGISTER_of qFst = QREGISTER_fst\<close>
  apply (rule Rep_QREGISTER_inject[THEN iffD1])
  by (simp add: QREGISTER_of.rep_eq QREGISTER_fst.rep_eq apply_qregister_fst)
lemma QREGISTER_of_qSnd: \<open>QREGISTER_of qSnd = QREGISTER_snd\<close>
  apply (rule Rep_QREGISTER_inject[THEN iffD1])
  by (simp add: QREGISTER_of.rep_eq QREGISTER_snd.rep_eq apply_qregister_snd)

lemma QREGISTER_pair_sym: \<open>QREGISTER_pair F G = QREGISTER_pair G F\<close>
  apply (rule Rep_QREGISTER_inject[THEN iffD1])
  by (simp add: sup_QREGISTER.rep_eq Un_ac(3))

lemma Rep_QREGISTER_Un_empty1[simp]: \<open>Rep_QREGISTER X \<union> one_algebra = Rep_QREGISTER X\<close>
  using QREGISTER_unit_smallest bot_QREGISTER.rep_eq less_eq_QREGISTER.rep_eq by blast
lemma Rep_QREGISTER_Un_empty2[simp]: \<open>one_algebra \<union> Rep_QREGISTER X = Rep_QREGISTER X\<close>
  using Rep_QREGISTER_Un_empty1 by blast

lemma QREGISTER_chain_non_qregister[simp]: \<open>QREGISTER_chain non_qregister F = bot\<close>
  apply (rule Rep_QREGISTER_inject[THEN iffD1])
  by (simp add: QREGISTER_chain.rep_eq bot_QREGISTER.rep_eq qregister_raw_apply_qregister)

lemma QREGISTER_pair_bot_left[simp]: \<open>QREGISTER_pair \<bottom> F = F\<close>
  by simp

lemma QREGISTER_pair_bot_right[simp]: \<open>QREGISTER_pair F \<bottom> = F\<close>
  by simp

lemma register_double_commutant_commute:
  assumes \<open>qregister F\<close>
  shows \<open>commutant (commutant (apply_qregister F ` X)) = apply_qregister F ` commutant (commutant X)\<close>
proof -
  have \<open>qregister_raw (apply_qregister F)\<close>
    using assms qregister.rep_eq by blast
  from register_decomposition[OF this]
  have \<open>let 'c::type = qregister_decomposition_basis F in ?thesis\<close>
  proof (rule with_type_mp)
    assume \<open>\<exists>U :: ('a \<times> 'c) ell2 \<Rightarrow>\<^sub>C\<^sub>L 'b ell2. unitary U \<and> (\<forall>\<theta>. apply_qregister F \<theta> = sandwich U *\<^sub>V \<theta> \<otimes>\<^sub>o id_cblinfun)\<close>
    then obtain U :: \<open>('a \<times> 'c) ell2 \<Rightarrow>\<^sub>C\<^sub>L 'b ell2\<close> where [simp]: \<open>unitary U\<close> and F_decomp: \<open>apply_qregister F \<theta> = sandwich U *\<^sub>V (\<theta> \<otimes>\<^sub>o id_cblinfun)\<close> for \<theta>
      by auto
    have \<open>commutant (commutant (apply_qregister F ` X))
        = commutant (commutant (sandwich U ` (\<lambda>a. a \<otimes>\<^sub>o id_cblinfun) ` X))\<close>
      by (simp add: image_image F_decomp)
    also have \<open>\<dots> = sandwich U ` commutant (commutant ((\<lambda>a. a \<otimes>\<^sub>o id_cblinfun) ` X))\<close>
      by (simp add: sandwich_unitary_commutant)
    also have \<open>\<dots> = sandwich U ` (\<lambda>a. a \<otimes>\<^sub>o id_cblinfun) ` commutant (commutant (X))\<close>
      using amplification_double_commutant_commute by blast
    also have \<open>\<dots> = apply_qregister F ` commutant (commutant X)\<close>
      by (simp add: image_image F_decomp)
    finally show \<open>commutant (commutant (apply_qregister F ` X)) = apply_qregister F ` commutant (commutant X)\<close>
      by -
  qed
  from this[cancel_with_type]
  show ?thesis
    by -
qed

lemma QREGISTER_pair_QREGISTER_chain: \<open>QREGISTER_pair (QREGISTER_chain F G) (QREGISTER_chain F H)
            = QREGISTER_chain F (QREGISTER_pair G H)\<close>
proof (cases \<open>qregister F\<close>)
  case True
  show ?thesis
    apply (rule_tac Rep_QREGISTER_inject[THEN iffD1])
    by (simp add: sup_QREGISTER.rep_eq QREGISTER_chain.rep_eq qregister_raw_apply_qregister
        register_double_commutant_commute True complex_vector.linear_span_image
        flip: image_Un)
next
  case False
  then show ?thesis
    by (simp add: non_qregister)
qed

lemma QREGISTER_pair_assoc:
  \<open>QREGISTER_pair (QREGISTER_pair F G) H = QREGISTER_pair F (QREGISTER_pair G H)\<close>
  apply (rule Rep_QREGISTER_inject[THEN iffD1])
  by (simp add: QREGISTER_pair_valid_qregister_range_hull Un_ac(1)
      flip: hull_Un_left hull_Un_right)

lemma one_algebra_subset_valid_range: \<open>valid_qregister_range A \<Longrightarrow> one_algebra \<subseteq> A\<close>
  by (auto simp: valid_qregister_range_def_sot one_algebra_def complex_vector.subspace_scale)

instance QREGISTER :: (type) order_bot..

instance QREGISTER :: (type) order_top..

lemma QREGISTER_pair_unit_left: \<open>QREGISTER_pair QREGISTER_unit F = F\<close>
  by simp

lemma QREGISTER_pair_unit_right: \<open>QREGISTER_pair F QREGISTER_unit = F\<close>
  by simp

lemma QREGISTER_pair_all_left: \<open>QREGISTER_pair QREGISTER_all F = QREGISTER_all\<close>
  by simp

lemma QREGISTER_pair_all_right: \<open>QREGISTER_pair F QREGISTER_all = QREGISTER_all\<close>
  by simp

lemma QREGISTER_chain_id_left: \<open>QREGISTER_chain qregister_id F = F\<close>
  apply (rule Rep_QREGISTER_inject[THEN iffD1])
  by (simp add: QREGISTER_chain.rep_eq)

lemma QREGISTER_chain_all_right: \<open>QREGISTER_chain F QREGISTER_all = QREGISTER_of F\<close>
  apply (rule Rep_QREGISTER_inject[THEN iffD1])
  by (simp add: QREGISTER_chain.rep_eq QREGISTER_of.rep_eq top_QREGISTER.rep_eq qregister_raw_apply_qregister)

lemma QREGISTER_pair_fst_snd: \<open>QREGISTER_pair QREGISTER_fst QREGISTER_snd = QREGISTER_all\<close>
  by (simp add: flip: QREGISTER_of_qFst QREGISTER_of_qSnd QREGISTER_of_qregister_pair
      QREGISTER_of_qregister_id)
lemma QREGISTER_pair_snd_fst: \<open>QREGISTER_pair QREGISTER_snd QREGISTER_fst = QREGISTER_all\<close>
  apply (subst QREGISTER_pair_sym)
  by (rule QREGISTER_pair_fst_snd)

lemma QREGISTER_chain_unit_left: \<open>QREGISTER_chain empty_qregister F = QREGISTER_unit\<close>
  apply (rule antisym)
   apply transfer
  by (auto simp: Quantum_Extra2.empty_var_def one_algebra_def)

lemma QREGISTER_chain_unit_right[simp]: \<open>QREGISTER_chain F QREGISTER_unit = QREGISTER_unit\<close>
  apply (rule Rep_QREGISTER_inject[THEN iffD1])
  by (auto simp add: QREGISTER_chain.rep_eq bot_QREGISTER.rep_eq one_algebra_def
      image_image apply_qregister_scaleC)

lemma Rep_QREGISTER_pair_fst_snd:
  \<open>Rep_QREGISTER (QREGISTER_pair (QREGISTER_chain qFst F) (QREGISTER_chain qSnd G))
      = tensor_vn (Rep_QREGISTER F) (Rep_QREGISTER G)\<close>
  by (simp add: sup_QREGISTER.rep_eq QREGISTER_chain.rep_eq apply_qregister_fst apply_qregister_snd tensor_vn_def qregister_raw_apply_qregister)

lift_definition ACTUAL_QREGISTER :: \<open>'a QREGISTER \<Rightarrow> bool\<close> is \<open>actual_qregister_range\<close>.

lemma empty_qregister_range[simp]: \<open>range (apply_qregister empty_qregister) = one_algebra\<close>
  by (metis QREGISTER_of.rep_eq QREGISTER_of_empty_qregister bot_QREGISTER.rep_eq empty_qregister_is_register)


lemma actual_qregister_range_one_algebra[iff]: \<open>actual_qregister_range one_algebra\<close>
proof -
  from empty_qregister_is_register
  have \<open>actual_qregister_range (range (apply_qregister (empty_qregister)))\<close>
    by (rule qregister_has_actual_qregister_range)
  then show ?thesis
    by (simp only: empty_qregister_range)
qed

lemma ACTUAL_QREGISTER_QREGISTER_of[iff]: \<open>ACTUAL_QREGISTER (QREGISTER_of F)\<close>
  apply (cases \<open>qregister F\<close>)
   apply (simp add: ACTUAL_QREGISTER.rep_eq QREGISTER_of.rep_eq qregister_has_actual_qregister_range)
  by (simp add: ACTUAL_QREGISTER.rep_eq QREGISTER_of.rep_eq)

lift_definition ACTUAL_QREGISTER_content :: \<open>'a QREGISTER \<Rightarrow> 'a set\<close> is actual_qregister_range_content.

lemma ACTUAL_QREGISTER_ex_register:
  fixes \<FF> :: \<open>'a QREGISTER\<close>
  assumes \<open>ACTUAL_QREGISTER \<FF>\<close>
  shows \<open>let 'l::type = ACTUAL_QREGISTER_content \<FF> in
         \<exists>F :: ('l, 'a) qregister. qregister F \<and> QREGISTER_of F = \<FF>\<close>
  by (smt (verit, ccfv_threshold) ACTUAL_QREGISTER.rep_eq ACTUAL_QREGISTER_content.rep_eq QREGISTER_of.rep_eq Rep_QREGISTER_inject actual_qregister_range_ex_register assms with_type_mp)

lemma ACTUAL_QREGISTER_chain:
  assumes \<open>qregister F\<close>
  assumes \<open>ACTUAL_QREGISTER \<GG>\<close>
  shows \<open>ACTUAL_QREGISTER (QREGISTER_chain F \<GG>)\<close>
proof -
  have \<open>actual_qregister_range (Rep_QREGISTER \<GG>)\<close>
    using assms by transfer
  from ACTUAL_QREGISTER_ex_register[OF assms(2)]
  have \<open>let 'c::type = ACTUAL_QREGISTER_content \<GG> in
       ACTUAL_QREGISTER (QREGISTER_chain F \<GG>)\<close>
  proof (rule with_type_mp)
    assume \<open>\<exists>G :: ('c, 'a) qregister. qregister G \<and> QREGISTER_of G = \<GG>\<close>
    then obtain G :: \<open>('c, 'a) qregister\<close> where [simp]: \<open>qregister G\<close>
      and rangeG: \<open>QREGISTER_of G = \<GG>\<close>
      by auto
    have \<open>QREGISTER_chain F \<GG> = QREGISTER_of (qregister_chain F G)\<close>
      apply (rule Rep_QREGISTER_inject[THEN iffD1])
      by (simp add: QREGISTER_chain.rep_eq assms QREGISTER_of.rep_eq image_image qregister_raw_apply_qregister flip: rangeG)
    also have \<open>ACTUAL_QREGISTER \<dots>\<close>
      by (simp add: ACTUAL_QREGISTER_QREGISTER_of assms(1))
    finally show \<open>ACTUAL_QREGISTER (QREGISTER_chain F \<GG>)\<close>
      by -
  qed
  from this[cancel_with_type]
  show ?thesis
    by -
qed

lemma ACTUAL_QREGISTER_fst[simp]: \<open>ACTUAL_QREGISTER QREGISTER_fst\<close>
  by (metis ACTUAL_QREGISTER_QREGISTER_of QREGISTER_of_qFst qFst_register)

lemma ACTUAL_QREGISTER_snd[simp]: \<open>ACTUAL_QREGISTER QREGISTER_snd\<close>
  by (metis ACTUAL_QREGISTER_QREGISTER_of QREGISTER_of_qSnd qSnd_register)

lemma ACTUAL_QREGISTER_top[simp]: \<open>ACTUAL_QREGISTER \<top>\<close>
  by (metis ACTUAL_QREGISTER_QREGISTER_of QREGISTER_of_qregister_id qregister_id)

lemma ACTUAL_QREGISTER_bot[simp]: \<open>ACTUAL_QREGISTER \<bottom>\<close>
proof -
  have *: \<open>a \<in> range (\<lambda>c. c *\<^sub>C id_cblinfun)\<close> 
    if offdiag: \<open>\<And>x y. x \<noteq> y \<Longrightarrow> is_orthogonal (ket x) (a *\<^sub>V ket y)\<close> 
      and diag: \<open>\<And>x y. ket x \<bullet>\<^sub>C (a *\<^sub>V ket x) = ket y \<bullet>\<^sub>C (a *\<^sub>V ket y)\<close>
    for a :: \<open>'a ell2 \<Rightarrow>\<^sub>C\<^sub>L 'a ell2\<close>
  proof -
    define c where \<open>c = ket undefined \<bullet>\<^sub>C (a *\<^sub>V ket undefined)\<close>
    from diag have diag_simp: \<open>ket x \<bullet>\<^sub>C (a *\<^sub>V ket x) = ket undefined \<bullet>\<^sub>C (a *\<^sub>V ket undefined)\<close> if \<open>NO_MATCH undefined x\<close> for x
      by simp
    let ?id = \<open>id_cblinfun :: 'a ell2 \<Rightarrow>\<^sub>C\<^sub>L 'a ell2\<close>
    have \<open>ket x \<bullet>\<^sub>C (a *\<^sub>V ket y) = ket x \<bullet>\<^sub>C ((c *\<^sub>C ?id) *\<^sub>V ket y)\<close> for x y
      apply (cases \<open>x = y\<close>)
      by (auto simp add: diag_simp c_def offdiag)
    then have \<open>a = c *\<^sub>C ?id\<close>
      by (meson cinner_ket_eqI equal_ket)
    then show ?thesis
      by auto
  qed
  show ?thesis
    apply transfer
    unfolding actual_qregister_range_def
    apply (rule exI[of _ \<open>\<lambda>x. (undefined,x)\<close>])
    apply (rule exI[of _ id_cblinfun])
    by (auto simp: actual_qregister_range_aux_def one_algebra_def * intro!: injI)
qed

lemma ACTUAL_QREGISTER_pair[simp]:
  assumes actualF: \<open>ACTUAL_QREGISTER \<FF>\<close>
  assumes actualG: \<open>ACTUAL_QREGISTER \<GG>\<close>
  assumes comp: \<open>QQcompatible \<FF> \<GG>\<close>
  shows \<open>ACTUAL_QREGISTER (QREGISTER_pair \<FF> \<GG>)\<close>
proof -
  from ACTUAL_QREGISTER_ex_register[OF actualF]
  have \<open>let 'f::type = ACTUAL_QREGISTER_content \<FF> in
       ACTUAL_QREGISTER (QREGISTER_pair \<FF> \<GG>)\<close>
  proof (rule with_type_mp)
    assume \<open>\<exists>F :: ('f, 'a) qregister. qregister F \<and> QREGISTER_of F = \<FF>\<close>
    then obtain F :: \<open>('f, 'a) qregister\<close> where [simp]: \<open>qregister F\<close> and qregF: \<open>QREGISTER_of F = \<FF>\<close>
      by auto
    from ACTUAL_QREGISTER_ex_register[OF actualG]
    have \<open>let 'g::type = ACTUAL_QREGISTER_content \<GG> in
       ACTUAL_QREGISTER (QREGISTER_pair \<FF> \<GG>)\<close>
    proof (rule with_type_mp)
      assume \<open>\<exists>G :: ('g, 'a) qregister. qregister G \<and> QREGISTER_of G = \<GG>\<close>
      then obtain G :: \<open>('g, 'a) qregister\<close> where [simp]: \<open>qregister G\<close> and qregG: \<open>QREGISTER_of G = \<GG>\<close>
        by auto
      from comp have comp': \<open>qcompatible F G\<close>
        by (simp add: qcompatible_QQcompatible flip: qregG qregF)
      then have \<open>QREGISTER_pair \<FF> \<GG> = QREGISTER_of (qregister_pair F G)\<close>
        by (simp add: QREGISTER_of_qregister_pair qregF qregG)
      also have \<open>ACTUAL_QREGISTER \<dots>\<close>
        by (simp add: ACTUAL_QREGISTER_QREGISTER_of comp')
      finally show \<open>ACTUAL_QREGISTER (QREGISTER_pair \<FF> \<GG>)\<close>
        by -
    qed
    from this[cancel_with_type]
    show \<open>ACTUAL_QREGISTER (QREGISTER_pair \<FF> \<GG>)\<close>
      by -
  qed
  from this[cancel_with_type]
  show \<open>ACTUAL_QREGISTER (QREGISTER_pair \<FF> \<GG>)\<close>
    by -
qed

lemma ACTUAL_QREGISTER_pair_fst_snd: \<open>ACTUAL_QREGISTER (QREGISTER_pair (QREGISTER_chain qFst F) (QREGISTER_chain qSnd G))\<close> if \<open>ACTUAL_QREGISTER F\<close> and \<open>ACTUAL_QREGISTER G\<close>
proof -
  let ?goal = ?thesis
  from ACTUAL_QREGISTER_ex_register[OF \<open>ACTUAL_QREGISTER F\<close>]
  have \<open>let 'f::type = ACTUAL_QREGISTER_content F in ?goal\<close>
  proof (rule with_type_mp)
    assume \<open>\<exists>A :: ('f, 'a) qregister. qregister A \<and> QREGISTER_of A = F\<close>
    then obtain A :: \<open>('f, 'a) qregister\<close> where [simp]: \<open>qregister A\<close> and qregF: \<open>QREGISTER_of A = F\<close>
      by auto
    from ACTUAL_QREGISTER_ex_register[OF \<open>ACTUAL_QREGISTER G\<close>]
    have \<open>let 'g::type = ACTUAL_QREGISTER_content G in ?goal\<close>
    proof (rule with_type_mp)
      assume \<open>\<exists>B :: ('g, 'b) qregister. qregister B \<and> QREGISTER_of B = G\<close>
      then obtain B :: \<open>('g, 'b) qregister\<close> where [simp]: \<open>qregister B\<close> and qregG: \<open>QREGISTER_of B = G\<close>
        by auto
      have \<open>QREGISTER_pair (QREGISTER_chain qFst F) (QREGISTER_chain qSnd G)
          = QREGISTER_of (qregister_pair (qregister_chain qFst A) (qregister_chain qSnd B))\<close>
        by (simp add: QREGISTER_of_qregister_pair QREGISTER_of_qregister_chain qregG qregF)
      then show ?goal
        by (auto intro!: ACTUAL_QREGISTER_QREGISTER_of)
    qed
    from this[cancel_with_type]
    show ?goal
      by -
  qed
  from this[cancel_with_type]
  show ?goal
    by -
qed


lemma QCOMPLEMENT_QREGISTER_of_eqI:
  assumes \<open>qcomplements F G\<close>
  shows \<open>QCOMPLEMENT (QREGISTER_of F) = QREGISTER_of G\<close>
  by (metis uminus_QREGISTER.rep_eq QREGISTER_of.rep_eq Rep_QREGISTER_inverse assms iso_qregister_def' qcompatible_QQcompatible qcomplements.rep_eq qcomplements_def' register_range_complement_commutant)

lemma ACTUAL_QREGISTER_complement: \<open>ACTUAL_QREGISTER (QCOMPLEMENT \<FF>)\<close> if \<open>ACTUAL_QREGISTER \<FF>\<close>
proof -
  let ?goal = ?thesis
  from ACTUAL_QREGISTER_ex_register[OF \<open>ACTUAL_QREGISTER \<FF>\<close>]
  have \<open>let 'f::type = ACTUAL_QREGISTER_content \<FF> in ?goal\<close>
  proof (rule with_type_mp)
    assume \<open>\<exists>F :: ('f, 'a) qregister. qregister F \<and> QREGISTER_of F = \<FF>\<close>
    then obtain F :: \<open>('f, 'a) qregister\<close> where [simp]: \<open>qregister F\<close> and qregF: \<open>QREGISTER_of F = \<FF>\<close>
      by auto
    from qcomplement_exists[OF \<open>qregister F\<close>]
    have \<open>let 'g::type = qregister_decomposition_basis F in ?goal\<close>
    proof (rule with_type_mp)
      assume \<open>\<exists>G :: ('g, 'a) qregister. qcomplements F G\<close>
      then obtain G :: \<open>('g, 'a) qregister\<close> where \<open>qcomplements F G\<close>
        by auto
      then have \<open>qregister G\<close>
        using Laws_Quantum.compatible_register2 complements_def qcomplements.rep_eq qregister_raw_apply_qregister by blast
      then have \<open>ACTUAL_QREGISTER (QREGISTER_of G)\<close>
        by (simp add: ACTUAL_QREGISTER_QREGISTER_of)
      also from \<open>qcomplements F G\<close> have \<open>QREGISTER_of G = QCOMPLEMENT (QREGISTER_of F)\<close>
        using QCOMPLEMENT_QREGISTER_of_eqI by fastforce
      also have \<open>\<dots> = QCOMPLEMENT \<FF>\<close>
        by (simp add: qregF)
      finally show ?goal
        by -
    qed
    from this[cancel_with_type]
    show ?goal
      by -
  qed
  from this[cancel_with_type]
  show ?goal
    by -
qed


lemma ACTUAL_QREGISTER_complement_iff: \<open>ACTUAL_QREGISTER (QCOMPLEMENT \<FF>) \<longleftrightarrow> ACTUAL_QREGISTER \<FF>\<close>
  by (metis ACTUAL_QREGISTER_complement uminus_QREGISTER.rep_eq Rep_QREGISTER Rep_QREGISTER_inverse mem_Collect_eq valid_qregister_range_def von_neumann_algebra_def)

lift_definition equivalent_qregisters :: \<open>('a,'c) qregister \<Rightarrow> ('b,'c) qregister \<Rightarrow> bool\<close> is equivalent_registers.

lemma equivalent_qregisters_trans[trans]:
  assumes \<open>equivalent_qregisters F G\<close>
  assumes \<open>equivalent_qregisters G H\<close>
  shows \<open>equivalent_qregisters F H\<close>
  using assms apply transfer
  using Laws_Quantum.equivalent_registers_trans by blast

lemma equivalent_qregisters_sym[sym]:
  assumes \<open>equivalent_qregisters F G\<close>
  shows \<open>equivalent_qregisters G F\<close>
  using assms apply transfer
  using Laws_Quantum.equivalent_registers_sym by blast

lemma equivalent_qregisters_triple1:
  assumes \<open>qregister (qregister_pair a (qregister_pair b c))\<close>
  shows \<open>equivalent_qregisters (qregister_pair a (qregister_pair b c)) (qregister_pair (qregister_pair a b) c)\<close>
proof -
  define a' b' c' where abc'_def: \<open>a' = apply_qregister a\<close> \<open>b' = apply_qregister b\<close> \<open>c' = apply_qregister c\<close>
  have [simp]: \<open>qcompatible_raw a' b'\<close>
    using abc'_def(1) abc'_def(2) assms qcompatible3' qcompatible_def by blast
  have [simp]: \<open>qcompatible_raw b' c'\<close>
    by (metis abc'_def(2) abc'_def(3) assms qcompatible_def)
  have [simp]: \<open>qcompatible_raw a' (b';c')\<close>
    by (metis abc'_def(1) abc'_def(2) abc'_def(3) assms qcompatible_def qregister_pair.rep_eq)
  have [simp]: \<open>qcompatible_raw (a';b') c'\<close>
    using Laws_Quantum.compatible3 \<open>qcompatible_raw a' b'\<close> \<open>qcompatible_raw b' c'\<close> abc'_def(1) abc'_def(3) assms qcompatible3' qcompatible_def by blast

  have \<open>Laws_Quantum.equivalent_registers (a';(b';c')) ((a';b');c')\<close>
    by (metis Laws_Quantum.equivalent_registers_assoc \<open>qcompatible_raw a' b'\<close> \<open>qcompatible_raw b' c'\<close> abc'_def(1) abc'_def(3) assms qcompatible3' qcompatible_def)
  then show ?thesis
    by (simp add: equivalent_qregisters.rep_eq qregister_pair.rep_eq flip: abc'_def)
qed

lemma equivalent_qregisters_triple2:
  assumes \<open>qregister (qregister_pair F (qregister_pair G H))\<close>
  shows \<open>equivalent_qregisters (qregister_pair (qregister_pair F G) H) (qregister_pair F (qregister_pair G H))\<close>
  using assms equivalent_qregisters_sym equivalent_qregisters_triple1 by blast

lemma equivalent_qregisters_swap:
  assumes \<open>qregister (qregister_pair F G)\<close>
  shows \<open>equivalent_qregisters (qregister_pair F G) (qregister_pair G F)\<close>
  using assms apply transfer
  apply (rule equivalent_registersI[where I=swap])
  by (auto simp: non_qregister_raw Laws_Quantum.compatible_sym)

lemma equivalent_qregisters_refl: \<open>equivalent_qregisters F F\<close> if \<open>qregister F\<close>
  using that apply transfer
  using Laws_Quantum.equivalent_registers_refl by blast

lemma equivalent_qregisters_pair:
  assumes \<open>equivalent_qregisters F F'\<close>
  assumes \<open>equivalent_qregisters G G'\<close>
  assumes \<open>qregister (qregister_pair F G)\<close>
  shows \<open>equivalent_qregisters (qregister_pair F G) (qregister_pair F' G')\<close>
proof -
  from assms(1) obtain I where [simp]: \<open>iso_register I\<close> and FI: \<open>apply_qregister F o I = apply_qregister F'\<close>
    using Laws_Quantum.equivalent_registers_def equivalent_qregisters.rep_eq by blast
  from assms(2) obtain J where [simp]: \<open>iso_register J\<close> and GJ: \<open>apply_qregister G o J = apply_qregister G'\<close>
    using Laws_Quantum.equivalent_registers_def equivalent_qregisters.rep_eq by blast
  have isoIJ: \<open>iso_register (I \<otimes>\<^sub>r J)\<close>
    by simp
  have FG[simp]: \<open>qregister_raw (apply_qregister (qregister_pair F G))\<close>
    using assms(3) by (auto simp: qregister_raw_apply_qregister)
  have FG2[simp]: \<open>qcompatible_raw (apply_qregister F) (apply_qregister G)\<close>
    using assms(3) qcompatible_def by blast
  have [simp]: \<open>qregister (qregister_pair F' G')\<close>
    by (metis Laws_Quantum.equivalent_registers_compatible1 Laws_Quantum.equivalent_registers_compatible2 Laws_Quantum.equivalent_registers_def FG2 assms(1) assms(2) equivalent_qregisters.rep_eq equivalent_qregisters_sym qcompatible_def qregister_raw_apply_qregister)
  then have F'G'[simp]: \<open>qregister_raw (apply_qregister (qregister_pair F' G'))\<close>
    apply transfer by simp
  have [simp]: \<open>qcompatible_raw (apply_qregister F') (apply_qregister G')\<close>
    by (metis F'G' non_qregister_raw qregister_pair.rep_eq)
  have \<open>apply_qregister (qregister_pair F G) o (I \<otimes>\<^sub>r J) = apply_qregister (qregister_pair F' G')\<close>
    by (simp add: qregister_pair.rep_eq Laws_Quantum.iso_register_is_register Laws_Quantum.pair_o_tensor FI GJ)
  with isoIJ FG
  have \<open>equivalent_registers (apply_qregister (qregister_pair F G)) (apply_qregister (qregister_pair F' G'))\<close>
    using Laws_Quantum.equivalent_registersI by blast
  then show ?thesis
    apply transfer by simp
qed

lemma equivalent_qregisters_chain:
  assumes \<open>equivalent_qregisters F G\<close>
  assumes \<open>qregister H\<close>
  shows \<open>equivalent_qregisters (qregister_chain H F) (qregister_chain H G)\<close>
  using assms apply transfer
  by (simp add: Laws_Quantum.equivalent_registers_comp Laws_Quantum.equivalent_registers_register_left Laws_Quantum.equivalent_registers_register_right)
  
lemma iso_qregister_equivalent_id:
  \<open>iso_qregister F \<longleftrightarrow> equivalent_qregisters F qregister_id\<close>
  unfolding iso_qregister_def'
  apply transfer
  by (metis Laws_Quantum.equivalent_registers_sym Laws_Quantum.iso_register_def Laws_Quantum.iso_register_equivalent_id Un_iff mem_Collect_eq)

lemma QREGISTER_chain_fst_top[simp]: \<open>QREGISTER_chain qFst \<top> = QREGISTER_fst\<close>
  apply (rule Rep_QREGISTER_inject[THEN iffD1])
  by (simp add: QREGISTER_chain.rep_eq QREGISTER_fst.rep_eq top_QREGISTER.rep_eq
      apply_qregister_fst qregister_raw_apply_qregister)

lemma QREGISTER_chain_snd_top[simp]: \<open>QREGISTER_chain qSnd \<top> = QREGISTER_snd\<close>
  apply (rule Rep_QREGISTER_inject[THEN iffD1])
  by (simp add: QREGISTER_chain.rep_eq QREGISTER_snd.rep_eq top_QREGISTER.rep_eq
      apply_qregister_snd qregister_raw_apply_qregister)

lemma QCOMPLEMENT_top[simp]: \<open>QCOMPLEMENT \<top> = \<bottom>\<close>
  apply (rule Rep_QREGISTER_inject[THEN iffD1])
  by (simp add: uminus_QREGISTER.rep_eq top_QREGISTER.rep_eq bot_QREGISTER.rep_eq
      commutant_UNIV one_algebra_def)

lemma QCOMPLEMENT_bot[simp]: \<open>QCOMPLEMENT \<bottom> = \<top>\<close>
  apply (rule Rep_QREGISTER_inject[THEN iffD1])
  by (simp add: uminus_QREGISTER.rep_eq top_QREGISTER.rep_eq bot_QREGISTER.rep_eq
      commutant_one_algebra)

lemma QCOMPLEMENT_fst: \<open>QCOMPLEMENT QREGISTER_fst = QREGISTER_snd\<close>
  apply (rule Rep_QREGISTER_inject[THEN iffD1])
  by (simp add: uminus_QREGISTER.rep_eq QREGISTER_snd.rep_eq QREGISTER_fst.rep_eq commutant_tensor1)

lemma QCOMPLEMENT_snd: \<open>QCOMPLEMENT QREGISTER_snd = QREGISTER_fst\<close>
  apply (rule Rep_QREGISTER_inject[THEN iffD1])
  by (simp add: uminus_QREGISTER.rep_eq QREGISTER_snd.rep_eq QREGISTER_fst.rep_eq commutant_tensor1')

lemma QREGISTER_of_non_qregister[simp]: \<open>QREGISTER_of non_qregister = \<bottom>\<close>
  by (simp add: QREGISTER_of.abs_eq bot_QREGISTER_def)

lemma QREGISTER_demorgan1: \<open>- (X \<squnion> Y) = (- X \<sqinter> - Y)\<close> for X Y :: \<open>_ QREGISTER\<close>
  apply transfer
  by (auto simp: valid_qregister_range_def commutant_def)

lemma QCOMPLEMENT_chain: \<open>QCOMPLEMENT (QREGISTER_chain F G)
        = QREGISTER_pair (QCOMPLEMENT (QREGISTER_of F)) (QREGISTER_chain F (QCOMPLEMENT G))\<close>
proof (cases \<open>qregister F\<close>)
  case True
  have 1: \<open>- QREGISTER_of F \<le> - QREGISTER_chain F G\<close>
    by (metis QCOMPLEMENT_antimono QREGISTER_chain_all_right QREGISTER_pair_QREGISTER_chain sup.absorb_iff2 top.extremum)
  have 2: \<open>QREGISTER_chain F (- G) \<le> - QREGISTER_chain F G\<close>
  proof (intro less_eq_QREGISTER.rep_eq[THEN iffD2] Set.subsetI)
    fix Fx assume \<open>Fx \<in> Rep_QREGISTER (QREGISTER_chain F (- G))\<close>
    then obtain x where xG': \<open>x \<in> Rep_QREGISTER (-G)\<close> and Fx_def: \<open>Fx = apply_qregister F x\<close>
      by (auto simp: QREGISTER_chain.rep_eq True qregister_raw_apply_qregister)
    show \<open>Fx \<in> Rep_QREGISTER (- QREGISTER_chain F G)\<close>
    proof (unfold uminus_QREGISTER.rep_eq, rule commutant_memberI)
      fix Fy assume \<open>Fy \<in> Rep_QREGISTER (QREGISTER_chain F G)\<close>
      then obtain y where yG: \<open>y \<in> Rep_QREGISTER G\<close> and Fy_def: \<open>Fy = apply_qregister F y\<close>
        by (auto simp: QREGISTER_chain.rep_eq True qregister_raw_apply_qregister)
      from xG' yG have \<open>x o\<^sub>C\<^sub>L y = y o\<^sub>C\<^sub>L x\<close>
        by (simp add: uminus_QREGISTER.rep_eq commutant_def)
      then show \<open>Fx o\<^sub>C\<^sub>L Fy = Fy o\<^sub>C\<^sub>L Fx\<close>
        by (simp add: Fx_def Fy_def flip: qregister_compose)
    qed
  qed
  have 3: \<open>- QREGISTER_chain F G \<le> - QREGISTER_of F \<squnion> QREGISTER_chain F (- G)\<close>
  proof -
    have \<open>- (- QREGISTER_of F \<squnion> QREGISTER_chain F (- G))
        = QREGISTER_of F \<sqinter> - QREGISTER_chain F (- G)\<close>
      by (simp add: QREGISTER_demorgan1 QCOMPLEMENT_twice)
    also have \<open>\<dots> \<le> QREGISTER_chain F G\<close>
    proof (intro less_eq_QREGISTER.rep_eq[THEN iffD2] Set.subsetI)
      fix Fx assume asm: \<open>Fx \<in> Rep_QREGISTER (QREGISTER_of F \<sqinter> - QREGISTER_chain F (- G))\<close>
      then obtain x where Fx_def: \<open>Fx = apply_qregister F x\<close>
        by (metis IntE QREGISTER_of.rep_eq True imageE inf_QREGISTER.rep_eq)
      with asm have Fx_FG'': \<open>apply_qregister F x \<in> commutant (apply_qregister F ` Rep_QREGISTER (- G))\<close>
        by (simp add: inf_QREGISTER.rep_eq uminus_QREGISTER.rep_eq QREGISTER_chain.rep_eq True qregister_raw_apply_qregister)
      have \<open>x \<in> commutant (Rep_QREGISTER (-G))\<close>
      proof (rule commutant_memberI)
        fix y assume asm_y:\<open>y \<in> Rep_QREGISTER (- G)\<close>
        then have \<open>apply_qregister F y \<in> apply_qregister F ` Rep_QREGISTER (- G)\<close>
          by blast
        with Fx_FG'' asm_y
        have \<open>apply_qregister F x o\<^sub>C\<^sub>L apply_qregister F y = apply_qregister F y o\<^sub>C\<^sub>L apply_qregister F x\<close>
          by (auto simp add: commutant_def)
        with True show \<open>x o\<^sub>C\<^sub>L y = y o\<^sub>C\<^sub>L x\<close>
          by (simp add: apply_qregister_inject' flip: qregister_compose)
      qed
      then have \<open>x \<in> Rep_QREGISTER G\<close>
        by (metis QCOMPLEMENT_twice uminus_QREGISTER.rep_eq)
      then show \<open>Fx \<in> Rep_QREGISTER (QREGISTER_chain F G)\<close>
        by (simp add: QREGISTER_chain.rep_eq True Fx_def qregister_raw_apply_qregister)
    qed
    finally show ?thesis
      by (metis QCOMPLEMENT_antimono QCOMPLEMENT_twice)
  qed
  show ?thesis
    by (auto intro!: antisym 1 2 3)
next
  case False
  then have \<open>F = non_qregister\<close>
    by (simp add: non_qregister)
  then show ?thesis
    by simp
qed

lemma QCOMPLEMENT_pair_fst_snd:
  assumes \<open>ACTUAL_QREGISTER F\<close> \<open>ACTUAL_QREGISTER G\<close> (* TODO comment on assumptions *)
  shows \<open>QCOMPLEMENT (QREGISTER_pair (QREGISTER_chain qFst F) (QREGISTER_chain qSnd G))
    = QREGISTER_pair (QREGISTER_chain qFst (QCOMPLEMENT F)) (QREGISTER_chain qSnd (QCOMPLEMENT G))\<close>

text \<open>The assumptions \<^term>\<open>ACTUAL_QREGISTER F\<close> \<^term>\<open>ACTUAL_QREGISTER G\<close> are actually not
  necessary. The theorem without these assumptions follows from the fact
  \<^prop>\<open>von_neumann_algebra M \<Longrightarrow> von_neumann_algebra N \<Longrightarrow> commutant (tensor_vn M N) = commutant M \<otimes>\<^sub>v\<^sub>N commutant N\<close>
  which is shown in \<^cite>\<open>takesaki\<close>, Theorem IV.5.9.
  We have an aborted proof of that fact in \<^url>\<open>https://github.com/dominique-unruh/qrhl-tool/blob/24188e63b2a064c77501071839c46266cfaa549f/isabelle-thys/Scratch.thy#L574\<close>
  but it turned out to be very hard to prove (many additional facts about von-Neumann algebras needed first).
  So we proved the simpler theorem given here with additional assumptions.\<close>

proof -
  let ?goal = ?thesis
  from ACTUAL_QREGISTER_ex_register[OF \<open>ACTUAL_QREGISTER F\<close>]
  have \<open>let 'f::type = ACTUAL_QREGISTER_content F in ?goal\<close>
  proof (rule with_type_mp)
    assume \<open>\<exists>A :: ('f, 'a) qregister. qregister A \<and> QREGISTER_of A = F\<close>
    then obtain A :: \<open>('f, 'a) qregister\<close> where [simp]: \<open>qregister A\<close> and qregF: \<open>QREGISTER_of A = F\<close>
      by auto
    from ACTUAL_QREGISTER_ex_register[OF \<open>ACTUAL_QREGISTER G\<close>]
    have \<open>let 'g::type = ACTUAL_QREGISTER_content G in ?goal\<close>
    proof (rule with_type_mp)
      assume \<open>\<exists>B :: ('g, 'b) qregister. qregister B \<and> QREGISTER_of B = G\<close>
      then obtain B :: \<open>('g, 'b) qregister\<close> where [simp]: \<open>qregister B\<close> and qregG: \<open>QREGISTER_of B = G\<close>
        by auto
      from qcomplement_exists[OF \<open>qregister A\<close>]
      have \<open>let 'i::type = qregister_decomposition_basis A in ?goal\<close>
      proof (rule with_type_mp)
        assume \<open>\<exists>AC :: ('i, 'a) qregister. qcomplements A AC\<close>
        then obtain AC :: \<open>('i, 'a) qregister\<close> where \<open>qcomplements A AC\<close>
          by auto
        from qcomplement_exists[OF \<open>qregister B\<close>]
        have \<open>let 'j::type = qregister_decomposition_basis B in ?goal\<close>
        proof (rule with_type_mp)
          assume \<open>\<exists>BC :: ('j, 'b) qregister. qcomplements B BC\<close>
          then obtain BC :: \<open>('j, 'b) qregister\<close> where \<open>qcomplements B BC\<close>
            by auto
          from \<open>qcomplements A AC\<close>
          have [simp]: \<open>qregister AC\<close>
            using iso_qregister_def' qcompatible_register2 qcomplements_def' by blast
          from \<open>qcomplements A AC\<close>
          have [simp]: \<open>qcompatible A AC\<close>
            using iso_qregister_def' qcomplements_def' by blast
          from \<open>qcomplements B BC\<close>
          have [simp]: \<open>qregister BC\<close>
            using iso_qregister_def' qcompatible_register2 qcomplements_def' by blast
          from \<open>qcomplements B BC\<close>
          have [simp]: \<open>qcompatible B BC\<close>
            using iso_qregister_def' qcomplements_def' by blast
          have [simp]: \<open>iso_qregister (qregister_pair A AC)\<close>
            using \<open>qcomplements A AC\<close> qcomplements_def' by blast
          have [simp]: \<open>iso_qregister (qregister_pair B BC)\<close>
            using \<open>qcomplements B BC\<close> qcomplements_def' by blast
          have QCOMPLEMENT_A: \<open>QCOMPLEMENT (QREGISTER_of A) = QREGISTER_of AC\<close>
            by (auto intro!: QCOMPLEMENT_QREGISTER_of_eqI \<open>qcomplements A AC\<close>)
          have QCOMPLEMENT_B: \<open>QCOMPLEMENT (QREGISTER_of B) = QREGISTER_of BC\<close>
            by (auto intro!: QCOMPLEMENT_QREGISTER_of_eqI \<open>qcomplements B BC\<close>)
          have \<open>qcomplements (qregister_pair (qregister_chain qFst A) (qregister_chain qSnd B))
                             (qregister_pair (qregister_chain qFst AC) (qregister_chain qSnd BC))\<close>
          proof -
            write equivalent_qregisters (infix "\<approx>" 50)
            have \<open>qregister_pair (qregister_pair (qregister_chain qFst A) (qregister_chain qSnd B))
                    (qregister_pair (qregister_chain qFst AC) (qregister_chain qSnd BC))
                \<approx> qregister_pair (qregister_pair (qregister_chain qFst A) (qregister_chain qSnd B))
                    (qregister_pair (qregister_chain qSnd BC) (qregister_chain qFst AC))\<close>
              apply (rule equivalent_qregisters_pair)
                apply (rule equivalent_qregisters_refl)
                apply simp
               apply (rule equivalent_qregisters_swap)
              by simp_all
            also have \<open>\<dots> \<approx> qregister_pair (qregister_chain qFst A) (qregister_pair (qregister_chain qSnd B)
                    (qregister_pair (qregister_chain qSnd BC) (qregister_chain qFst AC)))\<close>
              apply (rule equivalent_qregisters_triple2)
              by simp
            also have \<open>\<dots> \<approx> qregister_pair (qregister_chain qFst A) (qregister_pair (qregister_pair (qregister_chain qSnd B)
                    (qregister_chain qSnd BC)) (qregister_chain qFst AC))\<close>
              apply (rule equivalent_qregisters_pair)
                apply (rule equivalent_qregisters_refl)
                apply simp
              apply (rule equivalent_qregisters_triple1)
              by simp_all
            also have \<open>\<dots> = qregister_pair (qregister_chain qFst A)
                              (qregister_pair (qregister_chain qSnd (qregister_pair B BC)) (qregister_chain qFst AC))\<close>
              by (simp add: qregister_chain_pair)
            also have \<open>\<dots> \<approx> qregister_pair (qregister_chain qFst A)
                    (qregister_pair (qregister_chain qFst AC) (qregister_chain qSnd (qregister_pair B BC)))\<close>
              apply (rule equivalent_qregisters_pair)
                apply (rule equivalent_qregisters_refl)
                apply simp
               apply (rule equivalent_qregisters_swap)
              by simp_all
            also have \<open>\<dots> \<approx> qregister_pair (qregister_pair (qregister_chain qFst A) (qregister_chain qFst AC))
                             (qregister_chain qSnd (qregister_pair B BC))\<close>
              apply (rule equivalent_qregisters_triple1)
              by simp
            also have \<open>\<dots> = qregister_pair (qregister_chain qFst (qregister_pair A AC))
                             (qregister_chain qSnd (qregister_pair B BC))\<close>
              by (simp add: qregister_chain_pair)
            also have \<open>\<dots> \<approx> qregister_pair (qregister_chain qFst qregister_id)
                             (qregister_chain qSnd qregister_id)\<close>
              apply (rule equivalent_qregisters_pair)
                apply (rule equivalent_qregisters_chain)
                 apply (simp flip: iso_qregister_equivalent_id)
              apply simp
               apply (rule equivalent_qregisters_chain)
              by (simp_all flip: iso_qregister_equivalent_id)
            also have \<open>\<dots> = qregister_id\<close>
              by simp
            finally show ?thesis
              by (simp add: iso_qregister_equivalent_id qcomplements_def')
          qed
          then show ?goal
            by (auto intro!: QCOMPLEMENT_QREGISTER_of_eqI
                simp add: QCOMPLEMENT_A QCOMPLEMENT_B
                simp flip: QREGISTER_of_qregister_chain QREGISTER_of_qregister_pair qregF qregG)
        qed
        from this[cancel_with_type]
        show ?goal
          by -
      qed
      from this[cancel_with_type]
      show ?goal
        by -
    qed
    from this[cancel_with_type]
    show ?goal
      by -
  qed
  from this[cancel_with_type]
  show ?goal
    by -
qed

definition is_swap_on_qupdate_set :: \<open>'a qupdate set \<Rightarrow> ('a\<times>'a) qupdate \<Rightarrow> bool\<close> where
  \<open>is_swap_on_qupdate_set Q U \<longleftrightarrow> U \<in> Q \<otimes>\<^sub>v\<^sub>N Q \<and> unitary U \<and> (\<forall>a\<in>Q. \<forall>b\<in>Q. sandwich U (a \<otimes>\<^sub>o b) = b \<otimes>\<^sub>o a)
       \<and> (\<forall>a. minimal_projection_in Q a \<longrightarrow> U o\<^sub>C\<^sub>L (a \<otimes>\<^sub>o a) = a \<otimes>\<^sub>o a)\<close>

lift_definition swap_QREGISTER :: \<open>'a QREGISTER \<Rightarrow> ('a\<times>'a) qupdate\<close> is
  \<open>\<lambda>Q. the_default 0 (Collect (is_swap_on_qupdate_set Q))\<close>.

lemma range_apply_qregister_factor[iff]:
  fixes F :: \<open>('a, 'b) qregister\<close>
  assumes \<open>qregister F\<close>
  shows \<open>von_neumann_factor (range (apply_qregister F))\<close>
proof -
  from qcomplement_exists[OF assms]
  have \<open>let 'c::type = qregister_decomposition_basis F in
        von_neumann_factor (range (apply_qregister F))\<close>
  proof (rule with_type_mp)
    assume \<open>\<exists>G::('c, 'b) qregister. qcomplements F G\<close>
    then obtain G :: \<open>('c, 'b) qregister\<close> where \<open>qcomplements F G\<close>
      by blast
    define F' G' FG FG' where \<open>F' = apply_qregister F\<close> and \<open>G' = apply_qregister G\<close> and \<open>FG = qregister_pair F G\<close> and \<open>FG' = apply_qregister FG\<close>
    have \<open>iso_qregister FG\<close>
      using FG_def \<open>qcomplements F G\<close> qcomplements_def' by blast
    then have [iff]: \<open>inj FG'\<close>
      using FG'_def inj_qregister iso_qregister_def' by blast
    have vN: \<open>von_neumann_algebra (range F')\<close>
      by (metis assms valid_qregister_range valid_qregister_range_def F'_def)
    have \<open>range F' \<inter> commutant (range F') = range F' \<inter> range G'\<close>
      using F'_def G'_def \<open>qcomplements F G\<close>
      by (metis qcomplements.rep_eq register_range_complement_commutant)
    also have \<open>\<dots> = range (apply_qregister (qregister_chain FG qFst)) \<inter> range (apply_qregister (qregister_chain FG qSnd))\<close>
      apply (simp add: F'_def G'_def FG_def)
      by (metis (no_types, lifting) FG_def \<open>iso_qregister FG\<close> apply_qregister_extend_pair_left
          apply_qregister_extend_pair_right apply_qregister_fst apply_qregister_snd image_cong
          iso_qregister_def' qcompatible_sym)
    also have \<open>\<dots> = FG' ` (range (apply_qregister qFst) \<inter> range (apply_qregister qSnd))\<close>
      by (simp flip: FG'_def add: image_image image_Int)
    also have \<open>\<dots> = FG' ` (range (\<lambda>a. a \<otimes>\<^sub>o id_cblinfun) \<inter> range (\<lambda>b. id_cblinfun \<otimes>\<^sub>o b))\<close>
      by (metis (no_types, lifting) apply_qregister_fst apply_qregister_snd image_cong)
    also have \<open>\<dots> = FG' ` one_algebra\<close>
    proof (intro arg_cong[where f=\<open>image FG'\<close>] Set.set_eqI iffI)
      fix x :: \<open>('a \<times> 'c) ell2 \<Rightarrow>\<^sub>C\<^sub>L ('a \<times> 'c) ell2\<close> assume \<open>x \<in> one_algebra\<close>
      then obtain c where c_def: \<open>x = c *\<^sub>C id_cblinfun\<close>
        by (metis imageE one_algebra_def)
      then show \<open>x \<in> range (\<lambda>a. a \<otimes>\<^sub>o id_cblinfun) \<inter> range (\<lambda>b. id_cblinfun \<otimes>\<^sub>o b)\<close>
        by (auto intro!: exI[of _ \<open>c *\<^sub>C id_cblinfun\<close>]
            simp: image_iff tensor_op_cbilinear.scaleC_left tensor_op_cbilinear.scaleC_right)
    next
      fix x :: \<open>('a \<times> 'c) ell2 \<Rightarrow>\<^sub>C\<^sub>L ('a \<times> 'c) ell2\<close>
      assume asm: \<open>x \<in> range (\<lambda>a. a \<otimes>\<^sub>o id_cblinfun) \<inter> range (\<lambda>b. id_cblinfun \<otimes>\<^sub>o b)\<close>
      show \<open>x \<in> one_algebra\<close>
      proof (cases \<open>x = 0\<close>)
        case True
        then show ?thesis 
          by (auto intro!: exI[of _ 0] simp: one_algebra_def)
      next
        case False
        from asm obtain a b where x_a: \<open>x = a \<otimes>\<^sub>o id_cblinfun\<close> and x_b: \<open>x = id_cblinfun \<otimes>\<^sub>o b\<close>
          by fast
        then obtain c where \<open>b = c *\<^sub>C id_cblinfun\<close>
          apply atomize_elim
          apply (rule tensor_op_almost_injective)
          by (auto intro!: simp: )
        then show \<open>x \<in> one_algebra\<close>
          by (auto simp add: x_b one_algebra_def image_iff tensor_op_cbilinear.scaleC_right)
      qed
    qed
    also have \<open>\<dots> = one_algebra\<close>
      using FG'_def \<open>iso_qregister FG\<close> apply_qregister_one_algebra iso_qregister_def' by blast
    finally have \<open>range F' \<inter> commutant (range F') = one_algebra\<close>
      by -
    with vN show \<open>von_neumann_factor (range F')\<close>
      by (simp add: von_neumann_factor_def)
  qed
  from this[cancel_with_type]
  show ?thesis
    by -
qed

lemma is_swap_on_qupdate_set_unique:
  assumes vN: \<open>von_neumann_algebra Q\<close>
  assumes factor: \<open>von_neumann_factor (Q \<otimes>\<^sub>v\<^sub>N Q)\<close>
  assumes min_proj: \<open>Ex (minimal_projection_in Q)\<close>
  assumes U: \<open>is_swap_on_qupdate_set Q U\<close>
  assumes V: \<open>is_swap_on_qupdate_set Q V\<close>
  shows \<open>U = V\<close>
proof -
  define W where \<open>W = V* o\<^sub>C\<^sub>L U\<close>
  from U have [iff]: \<open>unitary U\<close>
    using is_swap_on_qupdate_set_def by blast
  from V have [iff]: \<open>unitary V\<close>
    using is_swap_on_qupdate_set_def by blast

  have commute_Wab: \<open>W o\<^sub>C\<^sub>L (a \<otimes>\<^sub>o b) = (a \<otimes>\<^sub>o b) o\<^sub>C\<^sub>L W\<close> if \<open>a \<in> Q\<close> and \<open>b \<in> Q\<close> for a b
  proof -
    have \<open>W o\<^sub>C\<^sub>L (a \<otimes>\<^sub>o b) = V* o\<^sub>C\<^sub>L sandwich U (a \<otimes>\<^sub>o b) o\<^sub>C\<^sub>L U\<close>
      by (simp add: W_def sandwich_apply cblinfun_compose_assoc)
    also from that have \<open>\<dots> = V* o\<^sub>C\<^sub>L sandwich V (a \<otimes>\<^sub>o b) o\<^sub>C\<^sub>L U\<close>
      using U V
      by (simp add: is_swap_on_qupdate_set_def)
    also have \<open>\<dots> = (a \<otimes>\<^sub>o b) o\<^sub>C\<^sub>L W\<close>
      by (simp add: W_def sandwich_apply flip: cblinfun_compose_assoc)
    finally show ?thesis
      by -
  qed
  have W_commutant: \<open>W \<in> commutant (Q \<otimes>\<^sub>v\<^sub>N Q)\<close>
  proof -
    from vN
    have \<open>id_cblinfun \<in> Q\<close>
      by (simp add: von_neumann_algebra_id von_neumann_factor_def)
    with commute_Wab have \<open>W \<in> commutant ((\<lambda>a. a \<otimes>\<^sub>o id_cblinfun) ` Q \<union> (\<lambda>a. id_cblinfun \<otimes>\<^sub>o a) ` Q)\<close>    
      by (auto intro!: commutant_memberI)
    also have \<open>\<dots> = commutant (Q \<otimes>\<^sub>v\<^sub>N Q)\<close>
      by (simp add: tensor_vn_def)
    finally show ?thesis
      by -
  qed
  have \<open>W \<in> Q \<otimes>\<^sub>v\<^sub>N Q\<close>
  proof -
    have \<open>U \<in> Q \<otimes>\<^sub>v\<^sub>N Q\<close>
      using U is_swap_on_qupdate_set_def by blast
    moreover have \<open>V \<in> Q \<otimes>\<^sub>v\<^sub>N Q\<close>
      using V is_swap_on_qupdate_set_def by blast
    ultimately show ?thesis
      using vN
      by (metis W_def rev_image_eqI von_neumann_algebra_adj_image von_neumann_algebra_compose von_neumann_algebra_tensor_vn von_neumann_factor_def)
  qed
  with W_commutant factor have \<open>W \<in> one_algebra\<close>
    using von_neumann_factor_def by fastforce
  then obtain c where W_cI: \<open>W = c *\<^sub>C id_cblinfun\<close>
    by (metis imageE one_algebra_def)
  have \<open>W = id_cblinfun\<close>
  proof -
    from min_proj obtain a where min_a: \<open>minimal_projection_in Q a\<close>
      by blast
    have aa_neq0: \<open>a \<otimes>\<^sub>o a \<noteq> 0\<close>
      by (metis min_a minimal_projection_in_def tensor_op_nonzero)
    from U min_a have \<open>U o\<^sub>C\<^sub>L (a \<otimes>\<^sub>o a) = a \<otimes>\<^sub>o a\<close>
      by (simp add: is_swap_on_qupdate_set_def)
    moreover    from V min_a have \<open>V o\<^sub>C\<^sub>L (a \<otimes>\<^sub>o a) = a \<otimes>\<^sub>o a\<close>
      by (simp add: is_swap_on_qupdate_set_def)
    ultimately have \<open>W o\<^sub>C\<^sub>L (a \<otimes>\<^sub>o a) = a \<otimes>\<^sub>o a\<close>
      by (metis W_def \<open>unitary V\<close> cblinfun_assoc_right(1) cblinfun_compose_id_left unitaryD1)
    with W_cI have \<open>c = 1\<close>
      using aa_neq0 apply (auto intro!: simp: )
      by (simp add: complex_vector.scale_right_imp_eq)
    with W_cI show \<open>W = id_cblinfun\<close>
      by fastforce
  qed
  then show \<open>U = V\<close>
    by (metis W_def \<open>unitary V\<close> adj_cblinfun_compose cblinfun_compose_assoc cblinfun_compose_id_right double_adj unitaryD2)
qed

lemma range_qregister_pair:
  assumes \<open>qcompatible F G\<close>
  shows \<open>range (apply_qregister (qregister_pair F G)) = commutant (commutant (range (apply_qregister F) \<union> range (apply_qregister G)))\<close>
proof -
  have \<open>range (apply_qregister (qregister_pair F G)) = Rep_QREGISTER (QREGISTER_of (qregister_pair F G))\<close>
    by (simp add: QREGISTER_of.rep_eq assms)
  also have \<open>\<dots> = Rep_QREGISTER (QREGISTER_of F \<squnion> QREGISTER_of G)\<close>
    by (simp add: QREGISTER_of_qregister_pair assms)
  also have \<open>\<dots> = commutant (commutant (Rep_QREGISTER (QREGISTER_of F) \<union> Rep_QREGISTER (QREGISTER_of G)))\<close>
    by (simp add: sup_QREGISTER.rep_eq)
  also have \<open>\<dots> = commutant (commutant (range (apply_qregister F) \<union> range (apply_qregister G)))\<close>
    using assms apply (simp add: QREGISTER_of.rep_eq)
    using qcompatible_register1 qcompatible_register2 by blast
  finally show ?thesis
    by -
qed

lemma range_qregister_tensor:
  assumes \<open>qregister F\<close> and \<open>qregister G\<close>
  shows \<open>range (apply_qregister (qregister_tensor F G)) = range (apply_qregister F) \<otimes>\<^sub>v\<^sub>N range (apply_qregister G)\<close>
  using assms 
  by (simp add: range_qregister_pair qregister_tensor_pair tensor_vn_def image_image
      qregister_chain_apply apply_qregister_fst apply_qregister_snd)

lemma minimal_projection_in_apply_qregister_preimage:
  assumes \<open>minimal_projection_in (apply_qregister Q ` A) b\<close>
  shows \<open>\<exists>a. minimal_projection_in A a \<and> b = apply_qregister Q a\<close>
proof (cases \<open>qregister Q\<close>)
  case True
  note [iff] = True
  from assms obtain a where baQ: \<open>b = apply_qregister Q a\<close> and \<open>a \<in> A\<close>
    by (auto simp: minimal_projection_in_def)
  from assms have \<open>is_Proj b\<close>
    using minimal_projection_in_def by blast
  with baQ have \<open>is_Proj a\<close>
    by simp
  from assms have \<open>b \<noteq> 0\<close>
    using minimal_projection_in_def by blast
  with baQ have \<open>a \<noteq> 0\<close>
    by force
  have \<open>a' = a\<close> if \<open>a' \<noteq> 0\<close> and \<open>is_Proj a'\<close> and \<open>a' \<in> A\<close> and \<open>a' \<le> a\<close> for a'
  proof -
    from assms have \<open>apply_qregister Q a' \<noteq> 0\<close>
      using apply_qregister_inject' that(1) by fastforce
    moreover from assms have \<open>is_Proj (apply_qregister Q a')\<close>
      by (simp add: that(2))
    moreover from assms have \<open>apply_qregister Q a' \<in> apply_qregister Q ` A\<close>
      using that(3) by blast
    moreover from assms have \<open>apply_qregister Q a' \<le> b\<close>
      using apply_qregister_mono baQ that(4) by blast
    ultimately have \<open>apply_qregister Q a' = b\<close>
      by (metis assms minimal_projection_in_def)
    then show \<open>a' = a\<close>
      by (simp add: baQ apply_qregister_inject')
  qed
  with \<open>a \<in> A\<close> \<open>is_Proj a\<close> \<open>a \<noteq> 0\<close> baQ
  show ?thesis
    by (auto intro!: exI[of _ a] simp: minimal_projection_in_def)
next
  case False
  from assms obtain a where baQ: \<open>b = apply_qregister Q a\<close>
    by (auto simp: minimal_projection_in_def)
  from assms have \<open>b \<noteq> 0\<close>
    using minimal_projection_in_def by blast
  from False baQ have \<open>b = 0\<close>
    by (simp add: non_qregister)
  with \<open>b \<noteq> 0\<close>
  have False
    by simp
  then show ?thesis
    by simp
qed

lemma is_swap_on_qupdate_set_swap_ell2: 
  assumes [iff]: \<open>qregister Q\<close>
  shows \<open>is_swap_on_qupdate_set (range (apply_qregister Q)) (apply_qregister (qregister_tensor Q Q) swap_ell2)\<close>
proof (unfold is_swap_on_qupdate_set_def, intro conjI ballI allI impI)
  show \<open>apply_qregister (qregister_tensor Q Q) swap_ell2 \<in> range (apply_qregister Q) \<otimes>\<^sub>v\<^sub>N range (apply_qregister Q)\<close>
    using range_qregister_tensor[OF assms assms]
    by auto
  show \<open>unitary (apply_qregister (qregister_tensor Q Q) swap_ell2)\<close>
    by (auto intro!: qregister_unitary qregister_qregister_tensor)
  show \<open>sandwich (apply_qregister (qregister_tensor Q Q) swap_ell2) *\<^sub>V a \<otimes>\<^sub>o b = b \<otimes>\<^sub>o a\<close>
    if \<open>a \<in> range (apply_qregister Q)\<close> and \<open>b \<in> range (apply_qregister Q)\<close> for a b
    by (smt (verit, del_insts) apply_qregister_adj adjoint_swap_ell2 imageE qregister_compose qregister_tensor_apply sandwich_apply swap_tensor_op that(1) that(2))
  show \<open>(apply_qregister (qregister_tensor Q Q) swap_ell2) o\<^sub>C\<^sub>L a \<otimes>\<^sub>o a = a \<otimes>\<^sub>o a\<close>
    if \<open>minimal_projection_in (range (apply_qregister Q)) a\<close> for a
  proof -
    from minimal_projection_in_apply_qregister_preimage[OF that]
    obtain b where \<open>minimal_projection_in UNIV b\<close> and a_def: \<open>a = apply_qregister Q b\<close>
      by auto
    from \<open>minimal_projection_in UNIV b\<close> have \<open>rank1 b\<close>
      by (rule minimal_projection_in_UNIV_rank1)
    then obtain \<psi> \<phi> where \<open>b = butterfly \<psi> \<phi>\<close>
      by (auto intro!: simp: rank1_iff_butterfly)
    then have \<open>swap_ell2 o\<^sub>C\<^sub>L (b \<otimes>\<^sub>o b) = b \<otimes>\<^sub>o b\<close>
      by (auto intro!: tensor_ell2_extensionality simp: cblinfun.scaleC_right tensor_butterfly)
    then have \<open>(apply_qregister (qregister_tensor Q Q) swap_ell2) o\<^sub>C\<^sub>L 
                  (apply_qregister (qregister_tensor Q Q) (b \<otimes>\<^sub>o b)) 
                = apply_qregister (qregister_tensor Q Q) (b \<otimes>\<^sub>o b)\<close>
      by (metis qregister_compose)
    moreover have \<open>apply_qregister (qregister_tensor Q Q) (b \<otimes>\<^sub>o b) = a \<otimes>\<^sub>o a\<close>
      by (simp add: a_def qregister_tensor_apply)
    ultimately show \<open>apply_qregister (qregister_tensor Q Q) swap_ell2 o\<^sub>C\<^sub>L a \<otimes>\<^sub>o a = a \<otimes>\<^sub>o a\<close>
      by simp
  qed
qed

lemma apply_qregister_minimal_projection_in:
  assumes \<open>qregister Q\<close>
  assumes \<open>minimal_projection_in A a\<close>
  shows \<open>minimal_projection_in (apply_qregister Q ` A) (apply_qregister Q a)\<close>
proof (unfold minimal_projection_in_def, intro conjI ballI impI)
  show \<open>apply_qregister Q a \<in> apply_qregister Q ` A\<close>
  by (meson assms(2) image_eqI minimal_projection_in_def)
  show \<open>is_Proj (apply_qregister Q a)\<close>
  using apply_qregister_is_Proj' assms(2) minimal_projection_in_def by blast
  show \<open>apply_qregister Q a \<noteq> 0\<close>
    by (metis apply_qregister_inject' apply_qregister_of_0 assms(1) assms(2) minimal_projection_in_def)
  show \<open>b = apply_qregister Q a\<close>
    if \<open>b \<in> apply_qregister Q ` A\<close> and \<open>is_Proj b\<close> and \<open>b \<le> apply_qregister Q a\<close> and \<open>b \<noteq> 0\<close> for b
  proof -
    from that(1) obtain c where bcQ: \<open>b = apply_qregister Q c\<close> and \<open>c \<in> A\<close>
      by blast
    then have \<open>c = a\<close>
      using apply_qregister_mono assms assms minimal_projection_in_def that
      by (metis apply_qregister_is_Proj apply_qregister_of_0)
    then show \<open>b = apply_qregister Q a\<close>
      using bcQ by blast
  qed
qed

lemma is_swap_on_qupdate_set_swap_QREGISTER_of:
  assumes [iff]: \<open>qregister Q\<close>
  shows \<open>is_swap_on_qupdate_set (range (apply_qregister Q)) (swap_QREGISTER (QREGISTER_of Q))\<close>
proof -
  have vN_Q: \<open>von_neumann_algebra (range (apply_qregister Q))\<close>
    using valid_qregister_range valid_qregister_range_def by blast
  have vN_QQ: \<open>von_neumann_factor (range (apply_qregister Q) \<otimes>\<^sub>v\<^sub>N range (apply_qregister Q))\<close>
    by (auto intro!: range_apply_qregister_factor qregister_qregister_tensor simp flip: range_qregister_tensor)
  have min_proj: \<open>Ex (minimal_projection_in (range (apply_qregister Q)))\<close>
    using minimal_projection_in_proj[where A=UNIV and \<psi>=\<open>ket undefined\<close>]
      apply_qregister_minimal_projection_in[where Q=Q and A=UNIV]
    by auto
  have 1: \<open>is_swap_on_qupdate_set (range (apply_qregister Q)) (apply_qregister (qregister_tensor Q Q) swap_ell2)\<close>
    by (simp add: is_swap_on_qupdate_set_swap_ell2) 
  have 2: \<open>U = apply_qregister (qregister_tensor Q Q) swap_ell2\<close>
    if \<open>is_swap_on_qupdate_set (range (\<lambda>a. apply_qregister Q a)) U\<close> for U
    using vN_Q vN_QQ min_proj that 1 by (rule is_swap_on_qupdate_set_unique)
  have \<open>is_swap_on_qupdate_set (range (apply_qregister Q))
     (the_default 0 (Collect (is_swap_on_qupdate_set (range (apply_qregister Q)))))\<close>
    using 1 2 by (rule the_default_CollectI[where a=\<open>apply_qregister (qregister_tensor Q Q) swap_ell2\<close>])
  then show ?thesis
    by (simp add: swap_QREGISTER.rep_eq QREGISTER_of.rep_eq) 
qed

lemma swap_QREGISTER_QREGISTER_of: 
  assumes [simp]: \<open>qregister Q\<close>
  shows \<open>swap_QREGISTER (QREGISTER_of Q) = (apply_qregister (qregister_tensor Q Q) swap_ell2)\<close>
proof (rule is_swap_on_qupdate_set_unique[where Q=\<open>range (apply_qregister Q)\<close>])
  show \<open>von_neumann_algebra (range (apply_qregister Q))\<close>
    using assms valid_qregister_range valid_qregister_range_def by blast
  show \<open>von_neumann_factor (range (apply_qregister Q) \<otimes>\<^sub>v\<^sub>N range (apply_qregister Q))\<close>
    by (auto intro!: range_apply_qregister_factor qregister_qregister_tensor simp flip: range_qregister_tensor)
  show \<open>Ex (minimal_projection_in (range (apply_qregister Q)))\<close>
    using minimal_projection_in_proj[where A=UNIV and \<psi>=\<open>ket undefined\<close>] apply_qregister_minimal_projection_in[where Q=Q and A=UNIV]
    by auto
  show \<open>is_swap_on_qupdate_set (range (apply_qregister Q)) (swap_QREGISTER (QREGISTER_of Q))\<close>
    using assms by (rule is_swap_on_qupdate_set_swap_QREGISTER_of)
  show \<open>is_swap_on_qupdate_set (range (apply_qregister Q)) (apply_qregister (qregister_tensor Q Q) swap_ell2)\<close>
    by (rule is_swap_on_qupdate_set_swap_ell2, simp)
qed

lemma swap_QREGISTER_bot[simp]: \<open>swap_QREGISTER \<bottom> = id_cblinfun\<close>
proof -
  let ?empty = \<open>empty_qregister :: (unit,_) qregister\<close>
  let ?swap = \<open>swap_ell2 :: (unit*unit) ell2 \<Rightarrow>\<^sub>C\<^sub>L _\<close>
  have \<open>swap_QREGISTER \<bottom> = swap_QREGISTER (QREGISTER_of ?empty)\<close>
    by simp
  also have \<open>\<dots> = apply_qregister (qregister_tensor ?empty ?empty) ?swap\<close>
    apply (subst swap_QREGISTER_QREGISTER_of)
    by auto
  also have \<open>\<dots> = apply_qregister (qregister_tensor ?empty ?empty) (one_dim_iso ?swap *\<^sub>C id_cblinfun)\<close>
    by simp
  also have \<open>\<dots> = one_dim_iso ?swap *\<^sub>C apply_qregister (qregister_tensor ?empty ?empty) id_cblinfun\<close>
    by simp
  also have \<open>\<dots> = apply_qregister (qregister_tensor ?empty ?empty) id_cblinfun\<close>
    by simp
  also have \<open>\<dots> = id_cblinfun\<close>
    using apply_qregister_of_id empty_qregister_is_register qregister_qregister_tensor by blast
  finally show ?thesis
    by -
qed

lemma is_swap_on_qupdate_set_swap_QREGISTER:
  assumes \<open>ACTUAL_QREGISTER Q\<close>
  shows \<open>is_swap_on_qupdate_set (Rep_QREGISTER Q) (swap_QREGISTER Q)\<close>
proof -
  from ACTUAL_QREGISTER_ex_register[OF assms]
  have \<open>let 'c::type = ACTUAL_QREGISTER_content Q in
        is_swap_on_qupdate_set (Rep_QREGISTER Q) (swap_QREGISTER Q)\<close>
  proof (rule with_type_mp)
    assume \<open>\<exists>F::('c, 'a) qregister. qregister F \<and> QREGISTER_of F = Q\<close>
    then obtain F :: \<open>('c, 'a) qregister\<close> where [iff]: \<open>qregister F\<close> and Q_def: \<open>Q = QREGISTER_of F\<close>
      by blast
    then have \<open>swap_QREGISTER (QREGISTER_of F) = (apply_qregister (qregister_tensor F F) swap_ell2)\<close>
      using swap_QREGISTER_QREGISTER_of by blast
    moreover have \<open>is_swap_on_qupdate_set (range (apply_qregister F)) (apply_qregister (qregister_tensor F F) swap_ell2)\<close>
      by (simp add: is_swap_on_qupdate_set_swap_ell2)
    ultimately show \<open>is_swap_on_qupdate_set (Rep_QREGISTER Q) (swap_QREGISTER Q)\<close>
      by (simp add: Q_def QREGISTER_of.rep_eq)
  qed
  from this[cancel_with_type]
  show ?thesis
    by -
qed

lemma Qqcompatible_comp_left[simp, intro]: "qcompatible F H \<Longrightarrow> Qqcompatible (QREGISTER_chain F G) H"
  apply transfer
  apply auto
  by (metis (mono_tags, lifting) Laws_Quantum.swap_registers non_qregister_raw)


end
