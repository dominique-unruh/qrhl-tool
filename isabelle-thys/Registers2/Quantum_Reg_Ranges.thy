theory Quantum_Reg_Ranges
  imports Quantum_Registers Missing_Bounded_Operators
begin


text \<open>The following definition of a valid qregister range is supposed to roughly define
what sets are possible as the range of a qregister, as a preliminary to define the type \<open>QREGISTER\<close> below.
Precisely, this would be a type-I von Neumann algebra factor.
However, we define it as any von Neumann algebra (not necessarily type I factor).
This means, there are "valid qregister ranges" that are not actually the range of a qregister.
We do this so that \<open>QREGISTER_pair\<close> below (defined as the von Neumann algebra generated by the two ranges) can be typed as \<open>QREGISTER\<close>.
(We do not know whether the von Neumann algebra generated by the union of two type I factors is a type I factor,
but the comments in the following two MathOverflow questions indicate that it is not:
\<^url>\<open>https://mathoverflow.net/questions/442854/intersection-of-type-i-von-neumann-algebra-factors\<close>,
\<^url>\<open>https://mathoverflow.net/questions/442906/intersection-of-finitely-many-type-i-von-neumann-algebra-factors\<close>.)

A possible alternative definition could be as a \<^term>\<open>von_neumann_factor\<close>, but then we have to prove that the bicommutant of the union of two factors is a factor.
I don't know whether that holds.
\<close>
definition valid_qregister_range :: \<open>'a qupdate set \<Rightarrow> bool\<close> where
  \<open>valid_qregister_range \<FF> \<longleftrightarrow> von_neumann_algebra \<FF>\<close>

lemma valid_qregister_rangeI: \<open>(\<And>a. a\<in>A \<Longrightarrow> a* \<in> A) \<Longrightarrow> commutant (commutant A) \<subseteq> A \<Longrightarrow> valid_qregister_range A\<close>
  using von_neumann_algebraI by (auto simp add: valid_qregister_range_def)

(* lemma valid_qregister_rangeI:
  assumes \<open>von_neumann_algebra A\<close>
  assumes \<open>A \<inter> commutant A \<subseteq> range (\<lambda>c. c *\<^sub>C id_cblinfun)\<close>
  shows \<open>valid_qregister_range A\<close>
  unfolding valid_qregister_range_def using assms by (rule von_neumann_algebraI) *)

(* TODO move *)
lemma register_range_complement_commutant: \<open>commutant (range F) = range G\<close> if \<open>complements F G\<close>
  apply (rule complement_range[symmetric])
  using that by (simp_all add: complements_def)

(* TODO move *)
lemma register_range_double_commutant: \<open>commutant (commutant (range F)) = range F\<close> if \<open>qregister_raw F\<close>
proof -
  from complement_exists
  have \<open>\<forall>\<^sub>\<tau> 'c::type = register_decomposition_basis F.
        commutant (commutant (range F)) = range F\<close>
  proof (rule with_type_mp)
    from that show \<open>qregister_raw F\<close>
      apply transfer by simp
    assume \<open>\<exists>G :: 'c ell2 \<Rightarrow>\<^sub>C\<^sub>L 'c ell2 \<Rightarrow> 'b ell2 \<Rightarrow>\<^sub>C\<^sub>L 'b ell2. complements F G\<close>
    then obtain G :: \<open>'c ell2 \<Rightarrow>\<^sub>C\<^sub>L 'c ell2 \<Rightarrow> 'b ell2 \<Rightarrow>\<^sub>C\<^sub>L 'b ell2\<close> 
      where \<open>complements F G\<close>
      by auto
    then have \<open>commutant (range F) = range G\<close>
      by (simp add: register_range_complement_commutant)
    moreover have \<open>commutant (range G) = range F\<close>
      by (meson \<open>complements F G\<close> complements_sym register_range_complement_commutant)
    ultimately show \<open>commutant (commutant (range F)) = range F\<close>
      by simp
  qed
  note this[cancel_with_type]
  then show ?thesis
    by -
qed

lemma valid_qregister_range: 
  fixes F :: \<open>('a,'b) qregister\<close>
  assumes \<open>qregister F\<close>
  shows \<open>valid_qregister_range (range (apply_qregister F))\<close>
proof (intro valid_qregister_rangeI von_neumann_algebraI)
  show \<open>a \<in> range (apply_qregister F) \<Longrightarrow> a* \<in> range (apply_qregister F)\<close> for a
    by (metis (mono_tags, lifting) assms image_iff qregister.rep_eq rangeI register_adj)
  show \<open>commutant (commutant (range (apply_qregister F))) \<subseteq> range (apply_qregister F)\<close>
    apply (subst register_range_double_commutant)
    using assms qregister.rep_eq by auto
(* (* Only needed if we add the condition "factor" to valid_qregister_range *)  
show \<open>range (apply_qregister F) \<inter> commutant (range (apply_qregister F))
        \<subseteq> range (\<lambda>c. c *\<^sub>C id_cblinfun)\<close>
  proof (rule subsetI)
    fix x
    assume asm: \<open>x \<in> range (apply_qregister F) \<inter> commutant (range (apply_qregister F))\<close>
    then obtain y where x_def: \<open>x = apply_qregister F y\<close>
      by blast
    with asm have \<open>apply_qregister F y o\<^sub>C\<^sub>L apply_qregister F z = apply_qregister F z o\<^sub>C\<^sub>L apply_qregister F y\<close>
      for z
      by (simp add: commutant_def)
    then have \<open>y o\<^sub>C\<^sub>L z = z o\<^sub>C\<^sub>L y\<close> for z
      apply (simp add: assms flip: qregister_compose)
      using assms inj_qregister range_ex1_eq by fastforce
    then have \<open>y \<in> range (\<lambda>c. c *\<^sub>C id_cblinfun)\<close>
      using commutant_UNIV by (auto simp: commutant_def)
    then show \<open>x \<in> range (\<lambda>c. c *\<^sub>C id_cblinfun)\<close>
      using assms 
      by (auto simp add: x_def apply_qregister_scaleC apply_qregister_of_id)
  qed *)
qed



lemma valid_one_algebra: \<open>valid_qregister_range one_algebra\<close>
proof -
  have 1: \<open>(one_algebra :: 'a qupdate set) = (\<lambda>c. c *\<^sub>C id_cblinfun) ` (one_dim_iso :: unit qupdate \<Rightarrow> _) ` UNIV\<close>
    by (metis (mono_tags, lifting) UNIV_eq_I one_algebra_def one_dim_iso_idem one_dim_scaleC_1 rangeI)
  have 2: \<open>\<dots> = range (apply_qregister (empty_qregister :: (unit,_) qregister))\<close>
    by (simp add: empty_qregister.rep_eq empty_var_def image_image)
  show ?thesis
    by (simp add: 1 2 valid_qregister_range)
qed


lemma valid_qregister_range_UNIV: \<open>valid_qregister_range UNIV\<close>
  by (auto simp: valid_qregister_range_def von_neumann_algebra_UNIV)

lemma closed_map_sot_register:
  assumes \<open>qregister F\<close>
  shows \<open>closed_map cstrong_operator_topology cstrong_operator_topology (apply_qregister F)\<close>
proof -
  have \<open>qregister_raw (apply_qregister F)\<close>
    using assms qregister.rep_eq by blast
  from register_decomposition[OF this]
  have \<open>\<forall>\<^sub>\<tau> 'c::type = qregister_decomposition_basis F. ?thesis\<close>
  proof (rule with_type_mp)
    assume \<open>\<exists>U :: ('a \<times> 'c) ell2 \<Rightarrow>\<^sub>C\<^sub>L 'b ell2. unitary U \<and> (\<forall>\<theta>. apply_qregister F \<theta> = sandwich U *\<^sub>V \<theta> \<otimes>\<^sub>o id_cblinfun)\<close>
    then obtain U :: \<open>('a \<times> 'c) ell2 \<Rightarrow>\<^sub>C\<^sub>L 'b ell2\<close> where
      \<open>unitary U\<close> and FU: \<open>apply_qregister F \<theta> = sandwich U *\<^sub>V \<theta> \<otimes>\<^sub>o id_cblinfun\<close> for \<theta>
      by metis
    have \<open>closed_map cstrong_operator_topology cstrong_operator_topology (sandwich U o (\<lambda>a. a \<otimes>\<^sub>o id_cblinfun))\<close>
      apply (rule closed_map_compose)
       apply (rule closed_map_sot_tensor_op_id_right)
      using \<open>unitary U\<close> by (rule closed_map_sot_unitary_sandwich)
    then show \<open>closed_map cstrong_operator_topology cstrong_operator_topology (apply_qregister F)\<close>
      by (simp add: FU[abs_def] o_def)
  qed
  from this[cancel_with_type]
  show ?thesis
    by -
qed

typedef 'a QREGISTER = \<open>Collect valid_qregister_range :: 'a qupdate set set\<close>
  using valid_one_algebra by blast
setup_lifting type_definition_QREGISTER

lift_definition QREGISTER_of :: \<open>('a,'b) qregister \<Rightarrow> 'b QREGISTER\<close> is
  \<open>\<lambda>F::('a,'b) qregister. if qregister F then range (apply_qregister F) :: 'b qupdate set else one_algebra\<close>
  by (simp add: valid_one_algebra valid_qregister_range)

instantiation QREGISTER :: (type) order begin
lift_definition less_eq_QREGISTER :: \<open>'a QREGISTER \<Rightarrow> 'a QREGISTER \<Rightarrow> bool\<close> is \<open>(\<subseteq>)\<close>.
lift_definition less_QREGISTER :: \<open>'a QREGISTER \<Rightarrow> 'a QREGISTER \<Rightarrow> bool\<close> is \<open>(\<subset>)\<close>.
instance
  apply (intro_classes; transfer)
  by auto
end

instantiation QREGISTER :: (type) bot begin
lift_definition bot_QREGISTER :: \<open>'a QREGISTER\<close> is one_algebra
  by (simp add: valid_one_algebra)
instance..
end

(* LEGACY *)
abbreviation (input) QREGISTER_unit :: \<open>'a QREGISTER\<close> where \<open>QREGISTER_unit \<equiv> bot\<close>

instantiation QREGISTER :: (type) top begin
lift_definition top_QREGISTER :: \<open>'a QREGISTER\<close> is UNIV
  by (simp add: valid_qregister_range_UNIV)
instance..
end

(* LEGACY *)
abbreviation (input) QREGISTER_all :: \<open>'a QREGISTER\<close> where \<open>QREGISTER_all \<equiv> top\<close>

lemma QREGISTER_of_qregister_id: \<open>QREGISTER_of qregister_id = QREGISTER_all\<close>
  apply (rule Rep_QREGISTER_inject[THEN iffD1])
  by (simp add: QREGISTER_of.rep_eq top_QREGISTER.rep_eq)

lemma QREGISTER_of_empty_qregister[simp]: \<open>QREGISTER_of (empty_qregister :: ('a::{CARD_1,enum},'b) qregister) = QREGISTER_unit\<close>
proof (rule Rep_QREGISTER_inject[THEN iffD1])
  let ?empty = \<open>empty_qregister :: ('a::{CARD_1,enum},'b) qregister\<close>
  have \<open>Rep_QREGISTER (QREGISTER_of ?empty) 
        = (\<lambda>x. x *\<^sub>C id_cblinfun) ` range (one_dim_iso :: 'a qupdate \<Rightarrow> _)\<close>
    by (simp add: QREGISTER_of.rep_eq Quantum_Extra2.empty_var_def image_image empty_qregister.rep_eq)
  also have \<open>\<dots> = (\<lambda>x. x *\<^sub>C id_cblinfun) ` UNIV\<close>
    apply (rule arg_cong[where y=UNIV])
    by (metis one_dim_iso_idem one_dim_iso_inj surjI)
  also have \<open>\<dots> = Rep_QREGISTER QREGISTER_unit\<close>    
    by (simp add: bot_QREGISTER.rep_eq one_algebra_def)
  finally show \<open>Rep_QREGISTER (QREGISTER_of ?empty) = Rep_QREGISTER QREGISTER_unit\<close>
    by -
qed

lemma QREGISTER_unit_smallest[simp]: \<open>(QREGISTER_unit :: 'a QREGISTER) \<le> X\<close>
proof (unfold less_eq_QREGISTER.rep_eq)
  have \<open>Rep_QREGISTER (QREGISTER_unit :: 'a QREGISTER) = one_algebra\<close>
    by (simp add: bot_QREGISTER.rep_eq one_algebra_def)
  also have \<open>\<dots> \<subseteq> commutant (commutant (Rep_QREGISTER X))\<close>
    apply (subst commutant_def) by (auto simp: one_algebra_def)
  also have \<open>\<dots> = Rep_QREGISTER X\<close>
    using Rep_QREGISTER
    by (auto simp: valid_qregister_range_def von_neumann_factor_def von_neumann_algebra_def)
  finally show \<open>Rep_QREGISTER (QREGISTER_unit :: 'a QREGISTER) \<subseteq> Rep_QREGISTER X\<close>
    by -
qed

instantiation QREGISTER :: (type) sup begin
lift_definition sup_QREGISTER :: \<open>'a QREGISTER \<Rightarrow> 'a QREGISTER \<Rightarrow> 'a QREGISTER\<close> is
  \<open>\<lambda>\<FF> \<GG> :: 'a qupdate set. commutant (commutant (\<FF> \<union> \<GG>))\<close>
proof -
  fix \<FF> \<GG> :: \<open>'a qupdate set\<close>
  assume \<open>\<FF> \<in> Collect valid_qregister_range\<close>
  then have [simp]: \<open>adj ` \<FF> = \<FF>\<close>
    apply (auto simp: valid_qregister_range_def von_neumann_factor_def von_neumann_algebra_def)
    by force
  assume \<open>\<GG> \<in> Collect valid_qregister_range\<close>
  then have [simp]: \<open>adj ` \<GG> = \<GG>\<close>
    apply (auto simp: valid_qregister_range_def von_neumann_factor_def von_neumann_algebra_def)
    by force
  have \<open>adj ` commutant (commutant (\<FF> \<union> \<GG>)) = commutant (commutant (\<FF> \<union> \<GG>))\<close>
    by (simp add: commutant_adj image_Un)
  then show \<open>commutant (commutant (\<FF> \<union> \<GG>)) \<in> Collect valid_qregister_range\<close>
    by (auto intro!: valid_qregister_rangeI)
qed
instance..
end

abbreviation (* LEGACY *) (input) \<open>QREGISTER_pair \<equiv> (sup :: 'a QREGISTER \<Rightarrow> _ \<Rightarrow> _)\<close>

lift_definition QQcompatible :: \<open>'a QREGISTER \<Rightarrow> 'a QREGISTER \<Rightarrow> bool\<close> is
  \<open>\<lambda>F G. \<forall>a\<in>F. \<forall>b\<in>G. a o\<^sub>C\<^sub>L b = b o\<^sub>C\<^sub>L a\<close>.

lift_definition Qqcompatible :: \<open>'a QREGISTER \<Rightarrow> ('b,'a) qregister \<Rightarrow> bool\<close> is
  \<open>\<lambda>F G. qregister_raw G \<and> (\<forall>a\<in>F. \<forall>b. a o\<^sub>C\<^sub>L G b = G b o\<^sub>C\<^sub>L a)\<close>.

lemma Qqcompatible_QQcompatible: \<open>Qqcompatible F G \<longleftrightarrow> qregister G \<and> QQcompatible F (QREGISTER_of G)\<close>
  by (simp add: Qqcompatible.rep_eq QQcompatible.rep_eq QREGISTER_of.rep_eq qregister.rep_eq)

lemma QQcompatible_sym: \<open>QQcompatible F G \<Longrightarrow> QQcompatible G F\<close> for F G :: \<open>'a QREGISTER\<close>
  by (auto simp: QQcompatible_def)

lemma qcompatible_QQcompatible: \<open>qcompatible F G \<longleftrightarrow> qregister F \<and> qregister G \<and> QQcompatible (QREGISTER_of F) (QREGISTER_of G)\<close>
  apply (transfer fixing: F G)
  apply (auto simp add: qcompatible_commute qcompatible_def)
  by (simp add: Laws_Quantum.compatible_def qregister.rep_eq)

lemma QQcompatible_QREGISTER_ofI[simp]: \<open>qcompatible F G \<Longrightarrow> QQcompatible (QREGISTER_of F) (QREGISTER_of G)\<close>
  using qcompatible_QQcompatible by auto

lemma Qqcompatible_comp_right[simp]: "Qqcompatible F G \<Longrightarrow> qregister H \<Longrightarrow> Qqcompatible F (qregister_chain G H)"
  apply transfer by auto

lemma QREGISTER_of_qregister_pair: \<open>QREGISTER_of (qregister_pair F G) = QREGISTER_pair (QREGISTER_of F) (QREGISTER_of G)\<close>
  if [simp]: \<open>qcompatible F G\<close>
proof -
  have [simp]: \<open>qregister F\<close> \<open>qregister G\<close>
    using qcompatible_register1 qcompatible_register2 that by blast+
  define F' G' where FG'_def: \<open>F' = Rep_QREGISTER (QREGISTER_of F)\<close> \<open>G' = Rep_QREGISTER (QREGISTER_of G)\<close>

  have 1: \<open>Rep_QREGISTER (QREGISTER_pair (QREGISTER_of F) (QREGISTER_of G)) \<subseteq> Rep_QREGISTER (QREGISTER_of (qregister_pair F G))\<close>
  proof -
    have \<open>F' \<subseteq> Rep_QREGISTER (QREGISTER_of (qregister_pair F G))\<close>
      apply (auto simp add: FG'_def QREGISTER_of.rep_eq)
      apply (rule range_eqI[where x=\<open>_ \<otimes>\<^sub>o id_cblinfun\<close>])
      by (simp add: apply_qregister_pair)
    moreover have \<open>G' \<subseteq> Rep_QREGISTER (QREGISTER_of (qregister_pair F G))\<close>
      apply (auto simp add: FG'_def QREGISTER_of.rep_eq)
      apply (rule range_eqI[where x=\<open>id_cblinfun \<otimes>\<^sub>o _\<close>])
      by (simp add: apply_qregister_pair)
    ultimately have \<open>F' \<union> G' \<subseteq> Rep_QREGISTER (QREGISTER_of (qregister_pair F G))\<close>
      by (simp add: FG'_def)
    then have \<open>commutant (commutant (F' \<union> G')) \<subseteq> commutant (commutant (Rep_QREGISTER (QREGISTER_of (qregister_pair F G))))\<close>
      by (intro commutant_antimono)
    also have \<open>\<dots> = Rep_QREGISTER (QREGISTER_of (qregister_pair F G))\<close>
      using Rep_QREGISTER by (auto simp: valid_qregister_range_def von_neumann_factor_def von_neumann_algebra_def)
    finally show ?thesis
      by (simp add: sup_QREGISTER.rep_eq FG'_def)
  qed
  have 2: \<open>Rep_QREGISTER (QREGISTER_of (qregister_pair F G)) \<subseteq> Rep_QREGISTER (QREGISTER_pair (QREGISTER_of F) (QREGISTER_of G))\<close>
  proof -
    have \<open>Rep_QREGISTER (QREGISTER_of (qregister_pair F G)) = apply_qregister (qregister_pair F G) ` UNIV\<close>
      by (simp add: QREGISTER_of.rep_eq)
    also have \<open>\<dots> = apply_qregister (qregister_pair F G) ` 
                    (weak_star_topology closure_of cspan {butterket \<xi> \<eta> |\<xi> \<eta>. True})\<close>
      apply (subst butterkets_weak_star_dense) by simp
    also have \<open>\<dots> \<subseteq> weak_star_topology closure_of 
                        apply_qregister (qregister_pair F G) ` cspan {butterket \<xi> \<eta> |\<xi> \<eta>. True}\<close>
      apply (rule continuous_map_image_closure_subset)
      using qregister.rep_eq that weak_star_cont_register by blast
    also have \<open>\<dots> = weak_star_topology closure_of cspan
                        (apply_qregister (qregister_pair F G) ` {butterket \<xi> \<eta> |\<xi> \<eta>. True})\<close>
      apply (subst complex_vector.linear_span_image)
      by simp_all
    also have \<open>\<dots> = weak_star_topology closure_of cspan
                        (apply_qregister (qregister_pair F G) ` {butterket (a,b) (c,d) |a b c d. True})\<close>
      apply (rule arg_cong[where x=\<open>{butterket \<xi> \<eta> |\<xi> \<eta>. True}\<close>])
      by auto
    also have \<open>\<dots> = weak_star_topology closure_of cspan
                        {apply_qregister F (butterket a c) o\<^sub>C\<^sub>L apply_qregister G (butterket b d) |a b c d. True}\<close>
      apply (subst set_compr_4_image_collect)
      apply (subst set_compr_4_image_collect)
      by (simp add: image_image case_prod_unfold apply_qregister_pair
          flip: tensor_ell2_ket tensor_butterfly)
    also have \<open>\<dots> \<subseteq> weak_star_topology closure_of cspan
                        {f o\<^sub>C\<^sub>L g | f g. f \<in> F' \<and> g \<in> G'}\<close>
      apply (rule closure_of_mono)
      apply (rule complex_vector.span_mono)
      by (auto simp: FG'_def QREGISTER_of.rep_eq)
    also have \<open>\<dots> \<subseteq> commutant (commutant {f o\<^sub>C\<^sub>L g | f g. f \<in> F' \<and> g \<in> G'})\<close>
      by (rule weak_star_closure_cspan_in_double_commutant)
    also have \<open>\<dots> \<subseteq> commutant (commutant (F' \<union> G'))\<close>
      apply (rule commutant_antimono)
      apply (auto simp: commutant_def)
      by (metis (no_types, lifting) Un_iff lift_cblinfun_comp(2))
    also have \<open>\<dots> = Rep_QREGISTER (QREGISTER_pair (QREGISTER_of F) (QREGISTER_of G))\<close>
      by (simp add: sup_QREGISTER.rep_eq flip: FG'_def)
    finally show ?thesis
      by -
  qed

  from 1 2 show ?thesis
    by (auto intro!: antisym simp add: less_eq_QREGISTER_def)
qed

lemma QQcompatible3I[simp]: \<open>QQcompatible F G \<Longrightarrow> QQcompatible G H \<Longrightarrow> QQcompatible F H \<Longrightarrow> QQcompatible (QREGISTER_pair F G) H\<close> 
  apply transfer apply (auto simp: commutant_def)
  by (metis Un_iff)

lemma QQcompatible3I'[simp]: \<open>QQcompatible F G \<Longrightarrow> QQcompatible F H \<Longrightarrow> QQcompatible G H \<Longrightarrow> QQcompatible F (QREGISTER_pair G H)\<close> 
  using QQcompatible3I QQcompatible_sym by blast

lemma Qqcompatible3I[simp]: \<open>QQcompatible F G \<Longrightarrow> Qqcompatible G H \<Longrightarrow> Qqcompatible F H \<Longrightarrow> Qqcompatible (QREGISTER_pair F G) H\<close>
  by (simp add: Qqcompatible_QQcompatible)

lemma Qqcompatible3I'[simp]: \<open>Qqcompatible F G \<Longrightarrow> Qqcompatible F H \<Longrightarrow> qcompatible G H \<Longrightarrow> Qqcompatible F (qregister_pair G H)\<close>
  by (simp add: Qqcompatible_QQcompatible QREGISTER_of_qregister_pair)


definition \<open>qregister_le F G = (qregister F \<and> qregister G \<and> QREGISTER_of F \<le> QREGISTER_of G)\<close>

(* TODO: same for cregister *)
lemma qregister_le_empty_qregister[simp]:
  shows \<open>qregister_le empty_qregister Q \<longleftrightarrow> qregister Q\<close>
  by (simp add: qregister_le_def)

lemma qregister_le_pair_leftI[iff]: 
  \<open>qregister_le (qregister_pair F G) H\<close> if \<open>qcompatible F G\<close> \<open>qregister_le F H\<close> \<open>qregister_le G H\<close>
proof -
  define F' G' H' where FGH'_def: \<open>F' = Rep_QREGISTER (QREGISTER_of F)\<close> 
    \<open>G' = Rep_QREGISTER (QREGISTER_of G)\<close> \<open>H' = Rep_QREGISTER (QREGISTER_of H)\<close>
  have \<open>F' \<union> G' \<subseteq> H'\<close>
    by (metis FGH'_def Un_least less_eq_QREGISTER.rep_eq qregister_le_def that(2,3))
  then have \<open>commutant (commutant (F' \<union> G')) \<subseteq> commutant (commutant H')\<close>
    by (auto intro!: commutant_antimono)
  also have \<open>\<dots> = H'\<close>
    using FGH'_def Rep_QREGISTER by (auto simp: valid_qregister_range_def von_neumann_factor_def von_neumann_algebra_def)
  finally have \<open>commutant (commutant (F' \<union> G')) \<subseteq> H'\<close>
    by -
  then show ?thesis
    using that 
    by (simp add: qregister_le_def QREGISTER_of_qregister_pair sup_QREGISTER.rep_eq 
        less_eq_QREGISTER.rep_eq flip: FGH'_def)
qed

lemma qregister_le_pair_rightI1: \<open>qregister_le F (qregister_pair G H)\<close> if \<open>qcompatible G H\<close> \<open>qregister_le F G\<close>
proof -
  define F' G' H' where FGH'_def: \<open>F' = Rep_QREGISTER (QREGISTER_of F)\<close> 
    \<open>G' = Rep_QREGISTER (QREGISTER_of G)\<close> \<open>H' = Rep_QREGISTER (QREGISTER_of H)\<close>
  have \<open>F' \<subseteq> G' \<union> H'\<close>
    using FGH'_def less_eq_QREGISTER.rep_eq qregister_le_def that(2) by blast
  then have \<open>commutant (commutant (G' \<union> H')) \<supseteq> commutant (commutant F')\<close> (is \<open>_ \<supseteq> \<dots>\<close>)
    by (auto intro!: commutant_antimono)
  also have \<open>\<dots> = F'\<close>
    using FGH'_def Rep_QREGISTER by (auto simp: valid_qregister_range_def von_neumann_factor_def von_neumann_algebra_def)
  finally have \<open>commutant (commutant (G' \<union> H')) \<supseteq> F'\<close>
    by -
  then show ?thesis
    using that 
    by (simp add: qregister_le_def QREGISTER_of_qregister_pair sup_QREGISTER.rep_eq 
        less_eq_QREGISTER.rep_eq flip: FGH'_def)
qed

lemma qregister_le_pair_rightI2: \<open>qregister_le F (qregister_pair G H)\<close> if \<open>qcompatible G H\<close> \<open>qregister_le F H\<close>
  using qregister_le_pair_rightI1[OF that(1)[THEN qcompatible_sym] that(2)]
  by (auto simp add: qregister_le_def qcompatible_sym QREGISTER_of_qregister_pair
      less_eq_QREGISTER.rep_eq sup_QREGISTER.rep_eq Un_commute)

lemma qregister_le_refl[iff]: \<open>qregister F \<Longrightarrow> qregister_le F F\<close> (* TODO: could replace this by a simp-rule *)
  unfolding qregister_le_def by simp


lemma QREGISTER_of_iso: \<open>QREGISTER_of I = QREGISTER_all\<close> if \<open>iso_qregister I\<close>
proof -
  have \<open>x \<in> range (apply_qregister I)\<close> for x
    apply (rule range_eqI[where x=\<open>apply_qregister (qregister_inv I) x\<close>])
    by (metis inj_qregister inv_f_eq iso_qregister_def iso_qregister_inv_iso iso_qregister_inv_iso_apply that)
  then show ?thesis
    apply (transfer fixing: I)
    using that by (auto simp: iso_qregister_def)
qed

lemma qregister_le_iso: \<open>qregister F \<Longrightarrow> iso_qregister G \<Longrightarrow> qregister_le F G\<close>
  by (simp add: qregister_le_def QREGISTER_of_iso less_eq_QREGISTER.rep_eq top_QREGISTER.rep_eq
      iso_qregister_def)

lemma qregister_le_id[iff]: \<open>qregister F \<Longrightarrow> qregister_le F qregister_id\<close> (* TODO: could replace this by a simp-rule *)
  by (simp add: iso_qregister_def qregister_le_iso)



end