isabelle /opt/Isabelle2016-1, theory PrgEnc.

classical var k : key.
classical var s : key.


# Variables for adversary communication
classical var m : msg.
classical var c : msg.
classical var r : msg.
classical var b : key.

quantum var qstateA : string.
classical var stateA : string.

# TODO: make A1,A2 abstract

# inputs: none; outputs m
program A1 := { c <- c; m <- m; stateA <- stateA; on qstateA apply undefined; b <- b; }.

# inputs: c; outputs: b
program A2 := { call A1; }.

# inputs: r; outputs: b
program B := { call A1; c <- r+m; call A2; }.


program rorcpa0 := {
  k <$ uniform UNIV;
  call A1;
  c <- enc(k,m);
  call A2;
}.

program rorcpa1 := {
  k <$ uniform UNIV;
  call A1;
  r <$ uniform UNIV;
  c <- enc(k,r);
  call A2;
}.

program prg0 := {
  s <$ uniform UNIV;
  r <- G(s);
  call B;
}.

program prg1 := {
  r <$ uniform UNIV;
  call B;
}.

qrhl {Cla[b1=b2 ∧ c1=c2 ∧ m1=m2 ∧ stateA1=stateA2] ⊓ ⟦qstateA1⟧ ≡𝔮 ⟦qstateA2⟧}
        call rorcpa0; ~ call prg0;
     {Cla[b1=b2]}.
 inline rorcpa0.
 inline prg0.
 inline B.
 call.
 wp left.
 wp right.
 call.
 simp.
 wp right.
 simp.
 rnd.
 skip.
 simp.
 true.
qed.

qrhl {Cla[b1=b2 ∧ c1=c2 ∧ m1=m2 ∧ stateA1=stateA2] ⊓ ⟦qstateA1⟧ ≡𝔮 ⟦qstateA2⟧}
        call rorcpa1; ~ call prg1;
     {Cla[b1=b2]}.
 inline rorcpa1.
 inline prg1.
 inline B.
 call.
 simp.
 wp left.
 wp right.
 simp.
# TODO: need to swap lines in right prog
# TODO: need rnd with non-trivial mapping
    