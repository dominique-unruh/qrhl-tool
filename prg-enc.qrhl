isabelle /opt/Isabelle2016-1.

# TODO: use constants
# TODO: use other types
ambient var G : bool => bit.
ambient var enc : bool * bit => bit.


#assumption ∀k x. enc(k,x) = G(k) + x.


classical var k : bool.
classical var s : bool.


# Variables for adversary communication
classical var m : bit.
classical var c : bit.
classical var r : bit.
classical var b : bool.

# TODO: remove once we have abstract A1,A2
quantum var qglobA : string.
classical var cglobA : string.

# TODO: all-quantified
# A: inputs: none; outputs m
program A1 := { c <- c; m <- m; cglobA <- cglobA; on qglobA apply undefined; b <- b; }.
# A: inputs: c; outputs: b
program A2 := { call A1; }.
# B: inputs: r; outputs: b
program B := { call A1; c <- r+m; call A2; }.


# TODO use this:  c <- enc(k,m);
program rorcpa0 := {
  k <$ uniform UNIV;
  call A1;
  c <- G(k) + m;
  call A2;
}.

# TODO use this:  c <- enc(k,r);
program rorcpa1 := {
  k <$ uniform UNIV;
  call A1;
  r <$ uniform UNIV;
  c <- G(k) + r;
  call A2;
}.

program prg0 := {
  s <$ uniform UNIV;
  r <- G(s);
  call B;
}.

program prg1 := {
  r <$ uniform UNIV;
  call B;
}.

qrhl {Cla[b1=b2 ∧ c1=c2 ∧ m1=m2 ∧ cglobA1=cglobA2] ⊓ ⟦qglobA1⟧ ≡𝔮 ⟦qglobA2⟧}
        call rorcpa0; ~ call prg0;
     {Cla[b1=b2]}.
 inline rorcpa0.
 inline prg0.
 inline B.
 call.
 wp left.
 wp right.
 call.
 simp.
 wp right.
 simp.
 rnd.
 skip.
 simp.
 true.
qed.

qrhl {Cla[b1=b2 ∧ c1=c2 ∧ m1=m2 ∧ cglobA1=cglobA2] ⊓ ⟦qglobA1⟧ ≡𝔮 ⟦qglobA2⟧}
        call rorcpa1; ~ call prg1;
     {Cla[b1=b2]}.
 inline rorcpa1.
 inline prg1.
 inline B.
 call.
 simp.
 wp left.
 wp right.
 simp.
# TODO: need to swap lines in right prog
# TODO: need rnd with non-trivial mapping
    