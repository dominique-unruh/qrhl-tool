isabelle /opt/Isabelle2016-1, theory PrgEnc.

classical var k : key.
classical var s : key.


# Variables for adversary communication
classical var m : msg.
classical var c : msg.
classical var r : msg.
classical var b : key.

quantum var qglobA : string.
classical var cglobA : string.

# TODO: all-quantified
# A: inputs: none; outputs m
program A1 := { c <- c; m <- m; cglobA <- cglobA; on qglobA apply undefined; b <- b; }.
# A: inputs: c; outputs: b
program A2 := { call A1; }.
# B: inputs: r; outputs: b
program B := { call A1; c <- r+m; call A2; }.


program rorcpa0 := {
  k <$ uniform UNIV;
  call A1;
  c <- enc(k,m);
  call A2;
}.

program rorcpa1 := {
  k <$ uniform UNIV;
  call A1;
  r <$ uniform UNIV;
  c <- enc(k,r);
  call A2;
}.

program prg0 := {
  s <$ uniform UNIV;
  r <- G(s);
  call B;
}.

program prg1 := {
  r <$ uniform UNIV;
  call B;
}.

qrhl {Cla[b1=b2 ∧ c1=c2 ∧ m1=m2 ∧ cglobA1=cglobA2] ⊓ ⟦qglobA1⟧ ≡𝔮 ⟦qglobA2⟧}
        call rorcpa0; ~ call prg0;
     {Cla[b1=b2]}.
    
 inline rorcpa0.
 inline prg0.
 inline B.
 call.
 wp left.
 wp right.
 call.
 simp.
 wp right.
 simp.
 rnd.
 skip.
 simp.
 true.
qed.

qrhl {Cla[b1=b2 ∧ c1=c2 ∧ m1=m2 ∧ cglobA1=cglobA2] ⊓ ⟦qglobA1⟧ ≡𝔮 ⟦qglobA2⟧}
        call rorcpa1; ~ call prg1;
     {Cla[b1=b2]}.
    
 inline rorcpa1.
 inline prg1.
 inline B.
 call.
 simp.
 wp left.
 wp right.
 simp.
 swap right.
 rnd r,r <- map_distr (%r. (r,r+G k1+m2)) (uniform UNIV).
 simp my_simp.
 call.
 wp left.
 skip.
 simp.
 simp aux_bij.
 true.
qed.
    
    