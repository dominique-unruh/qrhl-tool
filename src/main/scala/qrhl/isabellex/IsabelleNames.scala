/* generated by Isabelle */

/*

Source is in isabelle-thys/Scala.thy

Run

Run `sbt createIsabelleNames` to recreate/update

to recreate/update

*/

package qrhl.isabellex

object IsabelleTypes {
  val dummy = "dummy" 
  val nat = "Nat.nat"
  val int = "Int.int"
  val bool = "HOL.bool"
  val set = "Set.set"
  val ell2 = "Complex_L2.ell2"
  val bit = "Z2.bit"
  val ccsubspace = "Complex_Vector_Spaces.ccsubspace"
  val mem2 = "Prog_Variables.mem2"
  val program = "Programs.program"
  val oracle_program = "Programs.oracle_program"
  val distr = "Discrete_Distributions.distr"
  val bounded = "Complex_Bounded_Linear_Function0.cblinfun"
  val measurement = "QRHL_Core.measurement"
  val list = "List.list"
  val variable = "Prog_Variables.variable"
  val variables = "Prog_Variables.variables"
  val expression = "Expressions.expression"
  val prop = "prop"
  val unit = "Product_Type.unit"
  val prod = "Product_Type.prod"
  val char = "String.char"
  val real = "Real.real"
  val program_state = "Programs.program_state"
  val infinite = "QRHL_Core.infinite"
}

object IsabelleConsts {
  val Cons = "List.list.Cons"
  val Nil = "List.list.Nil"
  val classical_subspace = "QRHL_Core.classical_subspace"
  val Inf = "Complete_Lattices.Inf_class.Inf"
  val image = "Set.image"
  val inf = "Lattices.inf_class.inf"
  val sup = "Lattices.sup_class.sup"
  val plus = "Groups.plus_class.plus"
  val bot = "Orderings.bot_class.bot"
  val top = "Orderings.top_class.top"
  val zero = "Ring.ring.zero"
  val block = "Programs.block"
  val instantiateOracles = "Programs.instantiateOracles"
  val assign = "Programs.assign"
  val sample = "Programs.sample"
  val ifthenelse = "Programs.ifthenelse"
  val `while` = "Programs.while"
  val imp = "Pure.imp"
  val qrhl = "Relational_Hoare.qrhl"
  val qinit = "Programs.qinit"
  val qapply = "Programs.qapply"
  val implies = "HOL.implies"
  val measurement = "Programs.measurement"
  val variable_unit = "Prog_Variables.variable_unit"
  val variable_singleton = "Prog_Variables.variable_singleton"
  val variable_concat = "Prog_Variables.variable_concat"
  val one = "Groups.one_class.one"
  val True = "HOL.True"
  val False = "HOL.False"
  val probability = "Programs.probability"
  val eq = "HOL.eq"
  val numOne = "Num.num.One"
  val numBit0 = "Num.num.Bit0"
  val numBit1 = "Num.num.Bit1"
  val Char = "String.char.Char"
  val quantum_equality_full = "QRHL_Core.quantum_equality_full"
  val idOp = "Bounded_Operators.idOp"
  val less_eq = "Orderings.ord_class.less_eq"
  val tensorOp = "Tensor_Product.tensorOp"
  val unitary = "Bounded_Operators.unitary"
  val swap_variables_subspace = "QRHL_Core.swap_variables_subspace"
  val default = "HOL.default_class.default"
  val ket = "Complex_L2.ket"
  val not = "HOL.Not"
  val undefined = "HOL.undefined"
  val ccspan = "Complex_Vector_Spaces.ccspan"
  val liftSpace = "QRHL_Core.liftSpace"
  val insert = "Set.insert"
  val conj = "HOL.conj"
  val disj = "HOL.disj"
}
