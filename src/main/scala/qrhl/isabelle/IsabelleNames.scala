/* generated by Isabelle */

/*

Source is in isabelle-thys/Scala.thy

Run

/opt/Isabelle2019/bin/isabelle export -d . -O src/main/scala/qrhl/isabelle/ -x QRHL-Scala.Scala:IsabelleNames.scala -p 1 QRHL-Scala

to recreate/update

*/

package qrhl.isabelle

object IsabelleTypes {
  val dummy = "dummy" 
  val nat = "Nat.nat"
  val ell2 = "Complex_L2.ell2"
  val bit = "Bit.bit"
  val linear_space = "Complex_Vector_Spaces.linear_space"
  val mem2 = "Prog_Variables.mem2"
  val program = "Programs.program"
  val oracle_program = "Programs.oracle_program"
  val distr = "Discrete_Distributions.distr"
  val bounded = "Bounded_Operators.bounded"
  val measurement = "QRHL_Core.measurement"
  val list = "List.list"
  val variable = "Prog_Variables.variable"
  val variables = "Prog_Variables.variables"
  val expression = "Expressions.expression"
  val prop = "prop"
  val unit = "Product_Type.unit"
  val prod = "Product_Type.prod"
  val char = "String.char"
  val real = "Real.real"
  val program_state = "Programs.program_state"
}

object IsabelleConsts {
  val Cons = "List.list.Cons"
  val Nil = "List.list.Nil"
  val classical_subspace = "QRHL_Core.classical_subspace"
  val inf = "Lattices.inf_class.inf"
  val sup = "Lattices.sup_class.sup"
  val plus = "Groups.plus_class.plus"
  val bot = "Orderings.bot_class.bot"
  val top = "Orderings.top_class.top"
  val zero = "Ring.ring.zero"
  val block = "Programs.block"
  val instantiateOracles = "Programs.instantiateOracles"
  val assign = "Programs.assign"
  val sample = "Programs.sample"
  val ifthenelse = "Programs.ifthenelse"
  val `while` = "Programs.while"
  val imp = "Pure.imp"
  val qrhl = "Relational_Hoare.qrhl"
  val qinit = "Programs.qinit"
  val qapply = "Programs.qapply"
  val implies = "HOL.implies"
  val measurement = "Programs.measurement"
  val variable_unit = "Prog_Variables.variable_unit"
  val variable_singleton = "Prog_Variables.variable_singleton"
  val variable_concat = "Prog_Variables.variable_concat"
  val one = "Groups.one_class.one"
  val True = "HOL.True"
  val False = "HOL.False"
  val probability = "Programs.probability"
  val eq = "HOL.eq"
  val numOne = "Num.num.One"
  val numBit0 = "Num.num.Bit0"
  val numBit1 = "Num.num.Bit1"
  val Char = "String.char.Char"
  val quantum_equality_full = "QRHL_Core.quantum_equality_full"
  val idOp = "Bounded_Operators.idOp"
  val less_eq = "Orderings.ord_class.less_eq"
  val tensorOp = "Tensor_Product.tensorOp"
  val unitary = "Bounded_Operators.unitary"
  val swap_variables_subspace = "QRHL_Core.swap_variables_subspace"
  val default = "HOL.default_class.default"
  val ket = "Complex_L2.ket"
  val not = "HOL.Not"
}
